
test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001da  00800100  0000419c  00004230  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000419c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000118  008002da  008002da  0000440a  2**0
                  ALLOC
  3 .stab         0000429c  00000000  00000000  0000440c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001cb3  00000000  00000000  000086a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000a35b  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000a36c  2**2
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0f c1       	rjmp	.+542    	; 0x220 <__ctors_end>
       2:	00 00       	nop
       4:	2a c1       	rjmp	.+596    	; 0x25a <__bad_interrupt>
       6:	00 00       	nop
       8:	28 c1       	rjmp	.+592    	; 0x25a <__bad_interrupt>
       a:	00 00       	nop
       c:	26 c1       	rjmp	.+588    	; 0x25a <__bad_interrupt>
       e:	00 00       	nop
      10:	24 c1       	rjmp	.+584    	; 0x25a <__bad_interrupt>
      12:	00 00       	nop
      14:	22 c1       	rjmp	.+580    	; 0x25a <__bad_interrupt>
      16:	00 00       	nop
      18:	20 c1       	rjmp	.+576    	; 0x25a <__bad_interrupt>
      1a:	00 00       	nop
      1c:	1e c1       	rjmp	.+572    	; 0x25a <__bad_interrupt>
      1e:	00 00       	nop
      20:	1c c1       	rjmp	.+568    	; 0x25a <__bad_interrupt>
      22:	00 00       	nop
      24:	1a c1       	rjmp	.+564    	; 0x25a <__bad_interrupt>
      26:	00 00       	nop
      28:	18 c1       	rjmp	.+560    	; 0x25a <__bad_interrupt>
      2a:	00 00       	nop
      2c:	17 c1       	rjmp	.+558    	; 0x25c <__vector_11>
      2e:	00 00       	nop
      30:	14 c1       	rjmp	.+552    	; 0x25a <__bad_interrupt>
      32:	00 00       	nop
      34:	12 c1       	rjmp	.+548    	; 0x25a <__bad_interrupt>
      36:	00 00       	nop
      38:	10 c1       	rjmp	.+544    	; 0x25a <__bad_interrupt>
      3a:	00 00       	nop
      3c:	0e c1       	rjmp	.+540    	; 0x25a <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c c1       	rjmp	.+536    	; 0x25a <__bad_interrupt>
      42:	00 00       	nop
      44:	0a c1       	rjmp	.+532    	; 0x25a <__bad_interrupt>
      46:	00 00       	nop
      48:	0c 94 3f 11 	jmp	0x227e	; 0x227e <__vector_18>
      4c:	06 c1       	rjmp	.+524    	; 0x25a <__bad_interrupt>
      4e:	00 00       	nop
      50:	04 c1       	rjmp	.+520    	; 0x25a <__bad_interrupt>
      52:	00 00       	nop
      54:	02 c1       	rjmp	.+516    	; 0x25a <__bad_interrupt>
      56:	00 00       	nop
      58:	00 c1       	rjmp	.+512    	; 0x25a <__bad_interrupt>
      5a:	00 00       	nop
      5c:	fe c0       	rjmp	.+508    	; 0x25a <__bad_interrupt>
      5e:	00 00       	nop
      60:	fc c0       	rjmp	.+504    	; 0x25a <__bad_interrupt>
      62:	00 00       	nop
      64:	fa c0       	rjmp	.+500    	; 0x25a <__bad_interrupt>
      66:	00 00       	nop
      68:	08 4a       	sbci	r16, 0xA8	; 168
      6a:	d7 3b       	cpi	r29, 0xB7	; 183
      6c:	3b ce       	rjmp	.-906    	; 0xfffffce4 <__eeprom_end+0xff7efce4>
      6e:	01 6e       	ori	r16, 0xE1	; 225
      70:	84 bc       	out	0x24, r8	; 36
      72:	bf fd       	.word	0xfdbf	; ????
      74:	c1 2f       	mov	r28, r17
      76:	3d 6c       	ori	r19, 0xCD	; 205
      78:	74 31       	cpi	r23, 0x14	; 20
      7a:	9a bd       	out	0x2a, r25	; 42
      7c:	56 83       	std	Z+6, r21	; 0x06
      7e:	3d da       	rcall	.-2950   	; 0xfffff4fa <__eeprom_end+0xff7ef4fa>
      80:	3d 00       	.word	0x003d	; ????
      82:	c7 7f       	andi	r28, 0xF7	; 247
      84:	11 be       	out	0x31, r1	; 49
      86:	d9 e4       	ldi	r29, 0x49	; 73
      88:	bb 4c       	sbci	r27, 0xCB	; 203
      8a:	3e 91       	ld	r19, -X
      8c:	6b aa       	std	Y+51, r6	; 0x33
      8e:	aa be       	out	0x3a, r10	; 58
      90:	00 00       	nop
      92:	00 80       	ld	r0, Z
      94:	3f 00       	.word	0x003f	; ????

00000096 <__trampolines_end>:
      96:	6e 61       	ori	r22, 0x1E	; 30
      98:	6e 00       	.word	0x006e	; ????

0000009a <__c.2177>:
      9a:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
      aa:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
      ba:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
      ca:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
      da:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
      ea:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
      fa:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     10a:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     11a:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     12a:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     13a:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     14a:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     15a:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     16a:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     17a:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     18a:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00000198 <pstr_nan>:
     198:	4e 41 4e                                            NAN

0000019b <pstr_inity>:
     19b:	49 4e 49 54 59                                      INITY

000001a0 <pstr_inf>:
     1a0:	49 4e 46                                            INF

000001a3 <pwr_m10>:
     1a3:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     1b3:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

000001bb <pwr_p10>:
     1bb:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     1cb:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

000001d3 <__c.2374>:
     1d3:	63 64 69 6e 6f 70 73 75 78 58 5b 65 66 67 45 46     cdinopsuxX[efgEF
     1e3:	47 00                                               G.

000001e5 <pstr_an>:
     1e5:	61 6e 00                                            an.

000001e8 <pstr_nfinity>:
     1e8:	6e 66 69 6e 69 74 79 00                             nfinity.

000001f0 <pwr_m10>:
     1f0:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     200:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

00000208 <pwr_p10>:
     208:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     218:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

00000220 <__ctors_end>:
     220:	11 24       	eor	r1, r1
     222:	1f be       	out	0x3f, r1	; 63
     224:	cf ef       	ldi	r28, 0xFF	; 255
     226:	d8 e0       	ldi	r29, 0x08	; 8
     228:	de bf       	out	0x3e, r29	; 62
     22a:	cd bf       	out	0x3d, r28	; 61

0000022c <__do_copy_data>:
     22c:	12 e0       	ldi	r17, 0x02	; 2
     22e:	a0 e0       	ldi	r26, 0x00	; 0
     230:	b1 e0       	ldi	r27, 0x01	; 1
     232:	ec e9       	ldi	r30, 0x9C	; 156
     234:	f1 e4       	ldi	r31, 0x41	; 65
     236:	02 c0       	rjmp	.+4      	; 0x23c <__do_copy_data+0x10>
     238:	05 90       	lpm	r0, Z+
     23a:	0d 92       	st	X+, r0
     23c:	aa 3d       	cpi	r26, 0xDA	; 218
     23e:	b1 07       	cpc	r27, r17
     240:	d9 f7       	brne	.-10     	; 0x238 <__do_copy_data+0xc>

00000242 <__do_clear_bss>:
     242:	23 e0       	ldi	r18, 0x03	; 3
     244:	aa ed       	ldi	r26, 0xDA	; 218
     246:	b2 e0       	ldi	r27, 0x02	; 2
     248:	01 c0       	rjmp	.+2      	; 0x24c <.do_clear_bss_start>

0000024a <.do_clear_bss_loop>:
     24a:	1d 92       	st	X+, r1

0000024c <.do_clear_bss_start>:
     24c:	a2 3f       	cpi	r26, 0xF2	; 242
     24e:	b2 07       	cpc	r27, r18
     250:	e1 f7       	brne	.-8      	; 0x24a <.do_clear_bss_loop>
     252:	0e 94 ab 11 	call	0x2356	; 0x2356 <main>
     256:	0c 94 cc 20 	jmp	0x4198	; 0x4198 <_exit>

0000025a <__bad_interrupt>:
     25a:	d2 ce       	rjmp	.-604    	; 0x0 <__vectors>

0000025c <__vector_11>:
#define DISABLE_LED LED_PORT &= ~(1<<LED_PIN_NUM);
#define ENABLE_LED LED_PORT |= (1<<LED_PIN_NUM);
#define TOGGLE_LED LED_PORT ^= (1<<LED_PIN_NUM);

//16bit timer interrupt
ISR(TIMER1_COMPA_vect){
     25c:	1f 92       	push	r1
     25e:	0f 92       	push	r0
     260:	0f b6       	in	r0, 0x3f	; 63
     262:	0f 92       	push	r0
     264:	11 24       	eor	r1, r1
//    TOGGLE_LED
}
     266:	0f 90       	pop	r0
     268:	0f be       	out	0x3f, r0	; 63
     26a:	0f 90       	pop	r0
     26c:	1f 90       	pop	r1
     26e:	18 95       	reti

00000270 <initSystemTimer>:
    //TCCR1B = 0x08 + 0x05; //WGM12 = 1, WGM 13 = 0        => CTC mode, Clock divider 1024 = 0x05
    //OCR1AH = 0x05; //Zero this when tests are done
    //OCR1AL = 0x64;  // interrupt 100 times per second 15625/156~about 100 
    //Set interrupt to TIMER1 COMPA
    //TIMSK1 = 0x02; //OCIEA enabled
    GTCCR = 0x00;    
     270:	13 bc       	out	0x23, r1	; 35
     272:	08 95       	ret

00000274 <initLED>:
}
void initLED(void){
    LED_DDR |= (1<<LED_PIN_NUM); 
     274:	25 9a       	sbi	0x04, 5	; 4
     276:	08 95       	ret

00000278 <put_char0>:



int put_char0(char c, FILE *stream){
	 //if (c == '\n') put_char0('\r', stream);
	 loop_until_bit_is_set(UCSR0A, UDRE0);
     278:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     27c:	95 ff       	sbrs	r25, 5
     27e:	fc cf       	rjmp	.-8      	; 0x278 <put_char0>
	 UDR0 = c;
     280:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	 return 0;
}
     284:	80 e0       	ldi	r24, 0x00	; 0
     286:	90 e0       	ldi	r25, 0x00	; 0
     288:	08 95       	ret

0000028a <USART_Init>:
	 loop_until_bit_is_set(UCSR3A, UDRE3);
	 UDR3 = c;
	 return 0;
}
*/
void USART_Init(FILE *port0, uint32_t br0){
     28a:	cf 93       	push	r28
     28c:	df 93       	push	r29
     28e:	ec 01       	movw	r28, r24
	uint32_t MYUBRR = 0;
	//int MYUBRR = 16; // 16 = 115200, 34 = 57600
	if (port0 != NULL){
     290:	89 2b       	or	r24, r25
     292:	09 f4       	brne	.+2      	; 0x296 <USART_Init+0xc>
     294:	41 c0       	rjmp	.+130    	; 0x318 <USART_Init+0x8e>
		MYUBRR = F_CPU/(8*br0)-1;
     296:	44 0f       	add	r20, r20
     298:	55 1f       	adc	r21, r21
     29a:	66 1f       	adc	r22, r22
     29c:	77 1f       	adc	r23, r23
     29e:	44 0f       	add	r20, r20
     2a0:	55 1f       	adc	r21, r21
     2a2:	66 1f       	adc	r22, r22
     2a4:	77 1f       	adc	r23, r23
     2a6:	9a 01       	movw	r18, r20
     2a8:	ab 01       	movw	r20, r22
     2aa:	22 0f       	add	r18, r18
     2ac:	33 1f       	adc	r19, r19
     2ae:	44 1f       	adc	r20, r20
     2b0:	55 1f       	adc	r21, r21
     2b2:	60 e0       	ldi	r22, 0x00	; 0
     2b4:	74 e2       	ldi	r23, 0x24	; 36
     2b6:	84 ef       	ldi	r24, 0xF4	; 244
     2b8:	90 e0       	ldi	r25, 0x00	; 0
     2ba:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <__udivmodsi4>
     2be:	ba 01       	movw	r22, r20
     2c0:	a9 01       	movw	r20, r18
     2c2:	41 50       	subi	r20, 0x01	; 1
     2c4:	51 09       	sbc	r21, r1
     2c6:	61 09       	sbc	r22, r1
     2c8:	71 09       	sbc	r23, r1
		//DEbug serial
		DDRD |= 0x02; //TXD0 output
     2ca:	51 9a       	sbi	0x0a, 1	; 10
		DDRD &= ~(1<<0); //RXD0 input
     2cc:	50 98       	cbi	0x0a, 0	; 10
		UBRR0H = (uint8_t)(MYUBRR>>8);
     2ce:	bb 27       	eor	r27, r27
     2d0:	a7 2f       	mov	r26, r23
     2d2:	96 2f       	mov	r25, r22
     2d4:	85 2f       	mov	r24, r21
     2d6:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		UBRR0L = (uint8_t)MYUBRR;
     2da:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		UCSR0B |= (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0); //|(1<<TXCIE0);
     2de:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     2e2:	88 69       	ori	r24, 0x98	; 152
     2e4:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		UCSR0C |= (1<<UCSZ01)|(1<<UCSZ00);
     2e8:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
     2ec:	86 60       	ori	r24, 0x06	; 6
     2ee:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		UCSR0A |= (1<<U2X0);
     2f2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     2f6:	82 60       	ori	r24, 0x02	; 2
     2f8:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
		*port0 = serial_port0;
     2fc:	8e e0       	ldi	r24, 0x0E	; 14
     2fe:	e0 e0       	ldi	r30, 0x00	; 0
     300:	f1 e0       	ldi	r31, 0x01	; 1
     302:	de 01       	movw	r26, r28
     304:	01 90       	ld	r0, Z+
     306:	0d 92       	st	X+, r0
     308:	8a 95       	dec	r24
     30a:	e1 f7       	brne	.-8      	; 0x304 <USART_Init+0x7a>
		//if (defaultport == 0){
		stdout = &serial_port0; //Required for printf init
     30c:	80 e0       	ldi	r24, 0x00	; 0
     30e:	91 e0       	ldi	r25, 0x01	; 1
     310:	90 93 ed 03 	sts	0x03ED, r25	; 0x8003ed <__iob+0x3>
     314:	80 93 ec 03 	sts	0x03EC, r24	; 0x8003ec <__iob+0x2>
		*port3 = serial_port3;
		if (defaultport == 3){
			stdout = &serial_port3; //Required for printf init
		}
	}*/
}
     318:	df 91       	pop	r29
     31a:	cf 91       	pop	r28
     31c:	08 95       	ret

0000031e <USART_Transmit0>:

void USART_Transmit0( unsigned char data ){
	while ( !( UCSR0A & (1<<UDRE0)) );
     31e:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     322:	95 ff       	sbrs	r25, 5
     324:	fc cf       	rjmp	.-8      	; 0x31e <USART_Transmit0>
	UDR0 = data;
     326:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     32a:	08 95       	ret

0000032c <USART0_Flush>:
/*void USART_Transmit(unsigned char data){   
	while ( !( UCSR0A & (1<<UDRE0)) );
	UDR0 = data;
}*/

void USART0_Flush( void ){
     32c:	02 c0       	rjmp	.+4      	; 0x332 <USART0_Flush+0x6>
	unsigned char dummy;
	while ( UCSR0A & (1<<RXC0) ){
		dummy = UDR0;
     32e:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	UDR0 = data;
}*/

void USART0_Flush( void ){
	unsigned char dummy;
	while ( UCSR0A & (1<<RXC0) ){
     332:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     336:	87 fd       	sbrc	r24, 7
     338:	fa cf       	rjmp	.-12     	; 0x32e <USART0_Flush+0x2>
     33a:	08 95       	ret

0000033c <uart_getchar>:
}
*/

unsigned char uart_getchar(void)
{
    while( !(UCSR0A & (1<<RXC0)) );
     33c:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     340:	87 ff       	sbrs	r24, 7
     342:	fc cf       	rjmp	.-8      	; 0x33c <uart_getchar>
    return(UDR0);
     344:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
}
     348:	08 95       	ret

0000034a <waitResponce>:


void waitResponce(const char *string, uint8_t length){
     34a:	ac 01       	movw	r20, r24
	cli();
     34c:	f8 94       	cli
	uint8_t match=0;
     34e:	20 e0       	ldi	r18, 0x00	; 0
	while(length != match){
     350:	62 17       	cp	r22, r18
     352:	a9 f0       	breq	.+42     	; 0x37e <waitResponce+0x34>
#include <avr/io.h>	

#define USART_FREQ 16000000UL

__attribute__((always_inline)) inline static uint8_t USART_Receive0(void) {
	while ( !(UCSR0A & (1<<RXC0)) );
     354:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     358:	97 ff       	sbrs	r25, 7
     35a:	fc cf       	rjmp	.-8      	; 0x354 <waitResponce+0xa>
	return UDR0;
     35c:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		if (USART_Receive0() == pgm_read_byte(string+match)){
     360:	fa 01       	movw	r30, r20
     362:	e2 0f       	add	r30, r18
     364:	f1 1d       	adc	r31, r1
     366:	e4 91       	lpm	r30, Z
     368:	e9 17       	cp	r30, r25
     36a:	79 f0       	breq	.+30     	; 0x38a <waitResponce+0x40>
			match ++;
		}
		else{
			match = 0;
     36c:	20 e0       	ldi	r18, 0x00	; 0


void waitResponce(const char *string, uint8_t length){
	cli();
	uint8_t match=0;
	while(length != match){
     36e:	61 11       	cpse	r22, r1
     370:	f1 cf       	rjmp	.-30     	; 0x354 <waitResponce+0xa>
	UDR0 = data;
}*/

void USART0_Flush( void ){
	unsigned char dummy;
	while ( UCSR0A & (1<<RXC0) ){
     372:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     376:	87 ff       	sbrs	r24, 7
     378:	06 c0       	rjmp	.+12     	; 0x386 <waitResponce+0x3c>
		dummy = UDR0;
     37a:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	UDR0 = data;
}*/

void USART0_Flush( void ){
	unsigned char dummy;
	while ( UCSR0A & (1<<RXC0) ){
     37e:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     382:	87 fd       	sbrc	r24, 7
     384:	fa cf       	rjmp	.-12     	; 0x37a <waitResponce+0x30>
		else{
			match = 0;
		}
	}
	USART0_Flush();
	sei();
     386:	78 94       	sei
     388:	08 95       	ret
void waitResponce(const char *string, uint8_t length){
	cli();
	uint8_t match=0;
	while(length != match){
		if (USART_Receive0() == pgm_read_byte(string+match)){
			match ++;
     38a:	2f 5f       	subi	r18, 0xFF	; 255
     38c:	e1 cf       	rjmp	.-62     	; 0x350 <waitResponce+0x6>

0000038e <GetVoltage>:
#define ADC_PORT PORTC
#define ADC_DIR  DDRC

uint16_t GetVoltage(uint8_t Sensor, uint8_t ADCRange)
{
    ADMUX = Sensor+ADCRange;
     38e:	86 0f       	add	r24, r22
     390:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
    ADCSRA = 0b11000111; //tämä toimi AC kanssa 128 jakaja
     394:	87 ec       	ldi	r24, 0xC7	; 199
     396:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
    
    do {} while (bit_is_set(ADCSRA,6));
     39a:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
     39e:	86 fd       	sbrc	r24, 6
     3a0:	fc cf       	rjmp	.-8      	; 0x39a <GetVoltage+0xc>
    
    return ADCW;     
     3a2:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     3a6:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
}
     3aa:	08 95       	ret

000003ac <initADC>:

void initADC(void){
    ADC_DIR = 0x00;  //All input
     3ac:	17 b8       	out	0x07, r1	; 7
    ADC_PORT = 0x00; //Pulldown
     3ae:	18 b8       	out	0x08, r1	; 8
     3b0:	08 95       	ret

000003b2 <AVGVoltage>:
}


uint16_t AVGVoltage(uint8_t Sensor, uint8_t ADCRange, uint8_t num_of_samples){
     3b2:	cf 92       	push	r12
     3b4:	df 92       	push	r13
     3b6:	ef 92       	push	r14
     3b8:	ff 92       	push	r15
     3ba:	24 2f       	mov	r18, r20
#define ADC_PORT PORTC
#define ADC_DIR  DDRC

uint16_t GetVoltage(uint8_t Sensor, uint8_t ADCRange)
{
    ADMUX = Sensor+ADCRange;
     3bc:	86 0f       	add	r24, r22
     3be:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
    ADCSRA = 0b11000111; //tämä toimi AC kanssa 128 jakaja
     3c2:	97 ec       	ldi	r25, 0xC7	; 199
     3c4:	90 93 7a 00 	sts	0x007A, r25	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
    
    do {} while (bit_is_set(ADCSRA,6));
     3c8:	90 91 7a 00 	lds	r25, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
     3cc:	96 fd       	sbrc	r25, 6
     3ce:	fc cf       	rjmp	.-8      	; 0x3c8 <AVGVoltage+0x16>
    
    return ADCW;     
     3d0:	40 91 78 00 	lds	r20, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     3d4:	50 91 79 00 	lds	r21, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>


uint16_t AVGVoltage(uint8_t Sensor, uint8_t ADCRange, uint8_t num_of_samples){
    GetVoltage(Sensor,ADCRange);    
    uint32_t res = 0;
    for (uint8_t i=0; i<num_of_samples; i++){
     3d8:	22 23       	and	r18, r18
     3da:	59 f1       	breq	.+86     	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
     3dc:	30 e0       	ldi	r19, 0x00	; 0
     3de:	c1 2c       	mov	r12, r1
     3e0:	d1 2c       	mov	r13, r1
     3e2:	76 01       	movw	r14, r12
#define ADC_DIR  DDRC

uint16_t GetVoltage(uint8_t Sensor, uint8_t ADCRange)
{
    ADMUX = Sensor+ADCRange;
    ADCSRA = 0b11000111; //tämä toimi AC kanssa 128 jakaja
     3e4:	47 ec       	ldi	r20, 0xC7	; 199
#define ADC_PORT PORTC
#define ADC_DIR  DDRC

uint16_t GetVoltage(uint8_t Sensor, uint8_t ADCRange)
{
    ADMUX = Sensor+ADCRange;
     3e6:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
    ADCSRA = 0b11000111; //tämä toimi AC kanssa 128 jakaja
     3ea:	40 93 7a 00 	sts	0x007A, r20	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
    
    do {} while (bit_is_set(ADCSRA,6));
     3ee:	90 91 7a 00 	lds	r25, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
     3f2:	96 fd       	sbrc	r25, 6
     3f4:	fc cf       	rjmp	.-8      	; 0x3ee <AVGVoltage+0x3c>
    
    return ADCW;     
     3f6:	e0 91 78 00 	lds	r30, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     3fa:	f0 91 79 00 	lds	r31, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>

uint16_t AVGVoltage(uint8_t Sensor, uint8_t ADCRange, uint8_t num_of_samples){
    GetVoltage(Sensor,ADCRange);    
    uint32_t res = 0;
    for (uint8_t i=0; i<num_of_samples; i++){
        res += GetVoltage(Sensor, ADCRange);
     3fe:	ce 0e       	add	r12, r30
     400:	df 1e       	adc	r13, r31
     402:	e1 1c       	adc	r14, r1
     404:	f1 1c       	adc	r15, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     406:	e7 ec       	ldi	r30, 0xC7	; 199
     408:	f0 e0       	ldi	r31, 0x00	; 0
     40a:	31 97       	sbiw	r30, 0x01	; 1
     40c:	f1 f7       	brne	.-4      	; 0x40a <__FUSE_REGION_LENGTH__+0xa>
     40e:	00 c0       	rjmp	.+0      	; 0x410 <__FUSE_REGION_LENGTH__+0x10>
     410:	00 00       	nop


uint16_t AVGVoltage(uint8_t Sensor, uint8_t ADCRange, uint8_t num_of_samples){
    GetVoltage(Sensor,ADCRange);    
    uint32_t res = 0;
    for (uint8_t i=0; i<num_of_samples; i++){
     412:	3f 5f       	subi	r19, 0xFF	; 255
     414:	32 13       	cpse	r19, r18
     416:	e7 cf       	rjmp	.-50     	; 0x3e6 <AVGVoltage+0x34>
        res += GetVoltage(Sensor, ADCRange);
        _delay_us(50);
    }
    uint16_t final = res/num_of_samples;
     418:	30 e0       	ldi	r19, 0x00	; 0
     41a:	40 e0       	ldi	r20, 0x00	; 0
     41c:	50 e0       	ldi	r21, 0x00	; 0
     41e:	c7 01       	movw	r24, r14
     420:	b6 01       	movw	r22, r12
     422:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <__udivmodsi4>
    return final;
}
     426:	c9 01       	movw	r24, r18
     428:	ff 90       	pop	r15
     42a:	ef 90       	pop	r14
     42c:	df 90       	pop	r13
     42e:	cf 90       	pop	r12
     430:	08 95       	ret
}


uint16_t AVGVoltage(uint8_t Sensor, uint8_t ADCRange, uint8_t num_of_samples){
    GetVoltage(Sensor,ADCRange);    
    uint32_t res = 0;
     432:	c1 2c       	mov	r12, r1
     434:	d1 2c       	mov	r13, r1
     436:	76 01       	movw	r14, r12
     438:	ef cf       	rjmp	.-34     	; 0x418 <__FUSE_REGION_LENGTH__+0x18>

0000043a <Actuator_ADC>:
    }
    uint16_t final = res/num_of_samples;
    return final;
}

uint32_t Actuator_ADC(uint8_t Sensor, uint8_t ADCRange){
     43a:	86 0f       	add	r24, r22
     43c:	2a e0       	ldi	r18, 0x0A	; 10
    uint32_t res = 0;
     43e:	40 e0       	ldi	r20, 0x00	; 0
     440:	50 e0       	ldi	r21, 0x00	; 0
     442:	ba 01       	movw	r22, r20
#define ADC_DIR  DDRC

uint16_t GetVoltage(uint8_t Sensor, uint8_t ADCRange)
{
    ADMUX = Sensor+ADCRange;
    ADCSRA = 0b11000111; //tämä toimi AC kanssa 128 jakaja
     444:	37 ec       	ldi	r19, 0xC7	; 199
#define ADC_PORT PORTC
#define ADC_DIR  DDRC

uint16_t GetVoltage(uint8_t Sensor, uint8_t ADCRange)
{
    ADMUX = Sensor+ADCRange;
     446:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
    ADCSRA = 0b11000111; //tämä toimi AC kanssa 128 jakaja
     44a:	30 93 7a 00 	sts	0x007A, r19	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
    
    do {} while (bit_is_set(ADCSRA,6));
     44e:	90 91 7a 00 	lds	r25, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
     452:	96 fd       	sbrc	r25, 6
     454:	fc cf       	rjmp	.-8      	; 0x44e <Actuator_ADC+0x14>
    
    return ADCW;     
     456:	e0 91 78 00 	lds	r30, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     45a:	f0 91 79 00 	lds	r31, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
}

uint32_t Actuator_ADC(uint8_t Sensor, uint8_t ADCRange){
    uint32_t res = 0;
    for (uint8_t i=0; i<10;i++){
        res += GetVoltage(Sensor, ADCRange);
     45e:	4e 0f       	add	r20, r30
     460:	5f 1f       	adc	r21, r31
     462:	61 1d       	adc	r22, r1
     464:	71 1d       	adc	r23, r1
     466:	21 50       	subi	r18, 0x01	; 1
    return final;
}

uint32_t Actuator_ADC(uint8_t Sensor, uint8_t ADCRange){
    uint32_t res = 0;
    for (uint8_t i=0; i<10;i++){
     468:	71 f7       	brne	.-36     	; 0x446 <Actuator_ADC+0xc>
        res += GetVoltage(Sensor, ADCRange);
    }
    return res;
}
     46a:	cb 01       	movw	r24, r22
     46c:	ba 01       	movw	r22, r20
     46e:	08 95       	ret

00000470 <angleConversion>:
}



//Returns angle between -90.0 - 90.0, input value is in millimeters.
float angleConversion(uint16_t f){
     470:	4f 92       	push	r4
     472:	5f 92       	push	r5
     474:	6f 92       	push	r6
     476:	7f 92       	push	r7
     478:	8f 92       	push	r8
     47a:	9f 92       	push	r9
     47c:	af 92       	push	r10
     47e:	bf 92       	push	r11
     480:	cf 92       	push	r12
     482:	df 92       	push	r13
     484:	ef 92       	push	r14
     486:	ff 92       	push	r15
     488:	ac 01       	movw	r20, r24
    return -(360L*atan((2*ANGLE_C*ANGLE_X-sqrt((-ANGLE_C*ANGLE_C + 2*ANGLE_C*f - pow(f,2.0) + ANGLE_X*ANGLE_X + ANGLE_Y*ANGLE_Y)*
     48a:	9c 01       	movw	r18, r24
     48c:	ac e7       	ldi	r26, 0x7C	; 124
     48e:	b1 e0       	ldi	r27, 0x01	; 1
     490:	0e 94 96 1c 	call	0x392c	; 0x392c <__umulhisi3>
     494:	6b 01       	movw	r12, r22
     496:	7c 01       	movw	r14, r24
     498:	ba 01       	movw	r22, r20
     49a:	80 e0       	ldi	r24, 0x00	; 0
     49c:	90 e0       	ldi	r25, 0x00	; 0
     49e:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
     4a2:	9b 01       	movw	r18, r22
     4a4:	ac 01       	movw	r20, r24
     4a6:	0e 94 b7 1b 	call	0x376e	; 0x376e <__mulsf3>
     4aa:	4b 01       	movw	r8, r22
     4ac:	5c 01       	movw	r10, r24
     4ae:	c7 01       	movw	r24, r14
     4b0:	b6 01       	movw	r22, r12
     4b2:	64 50       	subi	r22, 0x04	; 4
     4b4:	7d 48       	sbci	r23, 0x8D	; 141
     4b6:	81 09       	sbc	r24, r1
     4b8:	91 09       	sbc	r25, r1
            (ANGLE_C*ANGLE_C + 2*ANGLE_C*f + pow(f,2.0)- ANGLE_X*ANGLE_X - ANGLE_Y*ANGLE_Y)))/
     4ba:	24 e0       	ldi	r18, 0x04	; 4
     4bc:	c2 0e       	add	r12, r18
     4be:	2d e8       	ldi	r18, 0x8D	; 141
     4c0:	d2 1e       	adc	r13, r18
     4c2:	e1 1c       	adc	r14, r1
     4c4:	f1 1c       	adc	r15, r1



//Returns angle between -90.0 - 90.0, input value is in millimeters.
float angleConversion(uint16_t f){
    return -(360L*atan((2*ANGLE_C*ANGLE_X-sqrt((-ANGLE_C*ANGLE_C + 2*ANGLE_C*f - pow(f,2.0) + ANGLE_X*ANGLE_X + ANGLE_Y*ANGLE_Y)*
     4c6:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <__floatsisf>
     4ca:	a5 01       	movw	r20, r10
     4cc:	94 01       	movw	r18, r8
     4ce:	0e 94 b0 19 	call	0x3360	; 0x3360 <__subsf3>
     4d2:	20 e0       	ldi	r18, 0x00	; 0
     4d4:	32 e4       	ldi	r19, 0x42	; 66
     4d6:	4f ee       	ldi	r20, 0xEF	; 239
     4d8:	58 e4       	ldi	r21, 0x48	; 72
     4da:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     4de:	20 e0       	ldi	r18, 0x00	; 0
     4e0:	30 e0       	ldi	r19, 0x00	; 0
     4e2:	48 ec       	ldi	r20, 0xC8	; 200
     4e4:	51 e4       	ldi	r21, 0x41	; 65
     4e6:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     4ea:	2b 01       	movw	r4, r22
     4ec:	3c 01       	movw	r6, r24
            (ANGLE_C*ANGLE_C + 2*ANGLE_C*f + pow(f,2.0)- ANGLE_X*ANGLE_X - ANGLE_Y*ANGLE_Y)))/
     4ee:	c7 01       	movw	r24, r14
     4f0:	b6 01       	movw	r22, r12
     4f2:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <__floatsisf>
     4f6:	a5 01       	movw	r20, r10
     4f8:	94 01       	movw	r18, r8
     4fa:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     4fe:	20 e0       	ldi	r18, 0x00	; 0
     500:	32 e4       	ldi	r19, 0x42	; 66
     502:	4f ee       	ldi	r20, 0xEF	; 239
     504:	58 e4       	ldi	r21, 0x48	; 72
     506:	0e 94 b0 19 	call	0x3360	; 0x3360 <__subsf3>
     50a:	20 e0       	ldi	r18, 0x00	; 0
     50c:	30 e0       	ldi	r19, 0x00	; 0
     50e:	48 ec       	ldi	r20, 0xC8	; 200
     510:	51 e4       	ldi	r21, 0x41	; 65
     512:	0e 94 b0 19 	call	0x3360	; 0x3360 <__subsf3>
     516:	9b 01       	movw	r18, r22
     518:	ac 01       	movw	r20, r24



//Returns angle between -90.0 - 90.0, input value is in millimeters.
float angleConversion(uint16_t f){
    return -(360L*atan((2*ANGLE_C*ANGLE_X-sqrt((-ANGLE_C*ANGLE_C + 2*ANGLE_C*f - pow(f,2.0) + ANGLE_X*ANGLE_X + ANGLE_Y*ANGLE_Y)*
     51a:	c3 01       	movw	r24, r6
     51c:	b2 01       	movw	r22, r4
     51e:	0e 94 b7 1b 	call	0x376e	; 0x376e <__mulsf3>
     522:	0e 94 1e 1c 	call	0x383c	; 0x383c <sqrt>
     526:	9b 01       	movw	r18, r22
     528:	ac 01       	movw	r20, r24
     52a:	60 e0       	ldi	r22, 0x00	; 0
     52c:	72 ee       	ldi	r23, 0xE2	; 226
     52e:	81 e8       	ldi	r24, 0x81	; 129
     530:	98 e4       	ldi	r25, 0x48	; 72
     532:	0e 94 b0 19 	call	0x3360	; 0x3360 <__subsf3>
     536:	6b 01       	movw	r12, r22
     538:	7c 01       	movw	r14, r24
            (ANGLE_C*ANGLE_C + 2*ANGLE_C*f + pow(f,2.0)- ANGLE_X*ANGLE_X - ANGLE_Y*ANGLE_Y)))/
            (ANGLE_C*ANGLE_C + 2*ANGLE_C*ANGLE_Y - pow(f,2.0) + ANGLE_X*ANGLE_X + ANGLE_Y*ANGLE_Y)))/M_PI;
     53a:	a5 01       	movw	r20, r10
     53c:	94 01       	movw	r18, r8
     53e:	60 e0       	ldi	r22, 0x00	; 0
     540:	70 e7       	ldi	r23, 0x70	; 112
     542:	84 e1       	ldi	r24, 0x14	; 20
     544:	97 e4       	ldi	r25, 0x47	; 71
     546:	0e 94 b0 19 	call	0x3360	; 0x3360 <__subsf3>
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	32 e4       	ldi	r19, 0x42	; 66
     54e:	4f ee       	ldi	r20, 0xEF	; 239
     550:	58 e4       	ldi	r21, 0x48	; 72
     552:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     556:	20 e0       	ldi	r18, 0x00	; 0
     558:	30 e0       	ldi	r19, 0x00	; 0
     55a:	48 ec       	ldi	r20, 0xC8	; 200
     55c:	51 e4       	ldi	r21, 0x41	; 65
     55e:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     562:	9b 01       	movw	r18, r22
     564:	ac 01       	movw	r20, r24



//Returns angle between -90.0 - 90.0, input value is in millimeters.
float angleConversion(uint16_t f){
    return -(360L*atan((2*ANGLE_C*ANGLE_X-sqrt((-ANGLE_C*ANGLE_C + 2*ANGLE_C*f - pow(f,2.0) + ANGLE_X*ANGLE_X + ANGLE_Y*ANGLE_Y)*
     566:	c7 01       	movw	r24, r14
     568:	b6 01       	movw	r22, r12
     56a:	0e 94 41 1a 	call	0x3482	; 0x3482 <__divsf3>
     56e:	0e 94 15 1a 	call	0x342a	; 0x342a <atan>
     572:	20 e0       	ldi	r18, 0x00	; 0
     574:	30 e0       	ldi	r19, 0x00	; 0
     576:	44 eb       	ldi	r20, 0xB4	; 180
     578:	53 e4       	ldi	r21, 0x43	; 67
     57a:	0e 94 b7 1b 	call	0x376e	; 0x376e <__mulsf3>
     57e:	90 58       	subi	r25, 0x80	; 128
     580:	2b ed       	ldi	r18, 0xDB	; 219
     582:	3f e0       	ldi	r19, 0x0F	; 15
     584:	49 e4       	ldi	r20, 0x49	; 73
     586:	50 e4       	ldi	r21, 0x40	; 64
     588:	0e 94 41 1a 	call	0x3482	; 0x3482 <__divsf3>
            (ANGLE_C*ANGLE_C + 2*ANGLE_C*f + pow(f,2.0)- ANGLE_X*ANGLE_X - ANGLE_Y*ANGLE_Y)))/
            (ANGLE_C*ANGLE_C + 2*ANGLE_C*ANGLE_Y - pow(f,2.0) + ANGLE_X*ANGLE_X + ANGLE_Y*ANGLE_Y)))/M_PI;
}
     58c:	ff 90       	pop	r15
     58e:	ef 90       	pop	r14
     590:	df 90       	pop	r13
     592:	cf 90       	pop	r12
     594:	bf 90       	pop	r11
     596:	af 90       	pop	r10
     598:	9f 90       	pop	r9
     59a:	8f 90       	pop	r8
     59c:	7f 90       	pop	r7
     59e:	6f 90       	pop	r6
     5a0:	5f 90       	pop	r5
     5a2:	4f 90       	pop	r4
     5a4:	08 95       	ret

000005a6 <tiltConversion>:

//Returns tilt angle between 0 to 90 degrees positive. input values in millimeters 
float tiltConversion(uint16_t f){
     5a6:	4f 92       	push	r4
     5a8:	5f 92       	push	r5
     5aa:	6f 92       	push	r6
     5ac:	7f 92       	push	r7
     5ae:	8f 92       	push	r8
     5b0:	9f 92       	push	r9
     5b2:	af 92       	push	r10
     5b4:	bf 92       	push	r11
     5b6:	cf 92       	push	r12
     5b8:	df 92       	push	r13
     5ba:	ef 92       	push	r14
     5bc:	ff 92       	push	r15
     5be:	ac 01       	movw	r20, r24
    return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_X*TILT_X + TILT_Y*TILT_Y)*
     5c0:	9c 01       	movw	r18, r24
     5c2:	a4 e5       	ldi	r26, 0x54	; 84
     5c4:	b1 e0       	ldi	r27, 0x01	; 1
     5c6:	0e 94 96 1c 	call	0x392c	; 0x392c <__umulhisi3>
     5ca:	6b 01       	movw	r12, r22
     5cc:	7c 01       	movw	r14, r24
     5ce:	ba 01       	movw	r22, r20
     5d0:	80 e0       	ldi	r24, 0x00	; 0
     5d2:	90 e0       	ldi	r25, 0x00	; 0
     5d4:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
     5d8:	9b 01       	movw	r18, r22
     5da:	ac 01       	movw	r20, r24
     5dc:	0e 94 b7 1b 	call	0x376e	; 0x376e <__mulsf3>
     5e0:	4b 01       	movw	r8, r22
     5e2:	5c 01       	movw	r10, r24
     5e4:	c7 01       	movw	r24, r14
     5e6:	b6 01       	movw	r22, r12
     5e8:	64 5e       	subi	r22, 0xE4	; 228
     5ea:	70 47       	sbci	r23, 0x70	; 112
     5ec:	81 09       	sbc	r24, r1
     5ee:	91 09       	sbc	r25, r1
              (TILT_C*TILT_C + 2L*TILT_C*f + pow(f,2.0)- TILT_X*TILT_X - TILT_Y*TILT_Y)))/
     5f0:	24 ee       	ldi	r18, 0xE4	; 228
     5f2:	c2 0e       	add	r12, r18
     5f4:	20 e7       	ldi	r18, 0x70	; 112
     5f6:	d2 1e       	adc	r13, r18
     5f8:	e1 1c       	adc	r14, r1
     5fa:	f1 1c       	adc	r15, r1
            (ANGLE_C*ANGLE_C + 2*ANGLE_C*ANGLE_Y - pow(f,2.0) + ANGLE_X*ANGLE_X + ANGLE_Y*ANGLE_Y)))/M_PI;
}

//Returns tilt angle between 0 to 90 degrees positive. input values in millimeters 
float tiltConversion(uint16_t f){
    return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_X*TILT_X + TILT_Y*TILT_Y)*
     5fc:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <__floatsisf>
     600:	a5 01       	movw	r20, r10
     602:	94 01       	movw	r18, r8
     604:	0e 94 b0 19 	call	0x3360	; 0x3360 <__subsf3>
     608:	20 e0       	ldi	r18, 0x00	; 0
     60a:	31 e0       	ldi	r19, 0x01	; 1
     60c:	4e e7       	ldi	r20, 0x7E	; 126
     60e:	58 e4       	ldi	r21, 0x48	; 72
     610:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     614:	20 e0       	ldi	r18, 0x00	; 0
     616:	30 e0       	ldi	r19, 0x00	; 0
     618:	a9 01       	movw	r20, r18
     61a:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     61e:	2b 01       	movw	r4, r22
     620:	3c 01       	movw	r6, r24
              (TILT_C*TILT_C + 2L*TILT_C*f + pow(f,2.0)- TILT_X*TILT_X - TILT_Y*TILT_Y)))/
     622:	c7 01       	movw	r24, r14
     624:	b6 01       	movw	r22, r12
     626:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <__floatsisf>
     62a:	a5 01       	movw	r20, r10
     62c:	94 01       	movw	r18, r8
     62e:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     632:	20 e0       	ldi	r18, 0x00	; 0
     634:	31 e0       	ldi	r19, 0x01	; 1
     636:	4e e7       	ldi	r20, 0x7E	; 126
     638:	58 e4       	ldi	r21, 0x48	; 72
     63a:	0e 94 b0 19 	call	0x3360	; 0x3360 <__subsf3>
     63e:	9b 01       	movw	r18, r22
     640:	ac 01       	movw	r20, r24
            (ANGLE_C*ANGLE_C + 2*ANGLE_C*ANGLE_Y - pow(f,2.0) + ANGLE_X*ANGLE_X + ANGLE_Y*ANGLE_Y)))/M_PI;
}

//Returns tilt angle between 0 to 90 degrees positive. input values in millimeters 
float tiltConversion(uint16_t f){
    return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_X*TILT_X + TILT_Y*TILT_Y)*
     642:	c3 01       	movw	r24, r6
     644:	b2 01       	movw	r22, r4
     646:	0e 94 b7 1b 	call	0x376e	; 0x376e <__mulsf3>
     64a:	0e 94 1e 1c 	call	0x383c	; 0x383c <sqrt>
     64e:	9b 01       	movw	r18, r22
     650:	ac 01       	movw	r20, r24
     652:	60 e0       	ldi	r22, 0x00	; 0
     654:	76 e5       	ldi	r23, 0x56	; 86
     656:	89 e2       	ldi	r24, 0x29	; 41
     658:	98 e4       	ldi	r25, 0x48	; 72
     65a:	0e 94 b0 19 	call	0x3360	; 0x3360 <__subsf3>
     65e:	6b 01       	movw	r12, r22
     660:	7c 01       	movw	r14, r24
              (TILT_C*TILT_C + 2L*TILT_C*f + pow(f,2.0)- TILT_X*TILT_X - TILT_Y*TILT_Y)))/
              (TILT_C*TILT_C + 2L*TILT_C*TILT_Y - pow(f,2.0) + TILT_X*TILT_X + TILT_Y*TILT_Y)))/M_PI;
     662:	a5 01       	movw	r20, r10
     664:	94 01       	movw	r18, r8
     666:	60 e0       	ldi	r22, 0x00	; 0
     668:	78 ec       	ldi	r23, 0xC8	; 200
     66a:	81 ee       	ldi	r24, 0xE1	; 225
     66c:	96 e4       	ldi	r25, 0x46	; 70
     66e:	0e 94 b0 19 	call	0x3360	; 0x3360 <__subsf3>
     672:	20 e0       	ldi	r18, 0x00	; 0
     674:	31 e0       	ldi	r19, 0x01	; 1
     676:	4e e7       	ldi	r20, 0x7E	; 126
     678:	58 e4       	ldi	r21, 0x48	; 72
     67a:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     67e:	20 e0       	ldi	r18, 0x00	; 0
     680:	30 e0       	ldi	r19, 0x00	; 0
     682:	a9 01       	movw	r20, r18
     684:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     688:	9b 01       	movw	r18, r22
     68a:	ac 01       	movw	r20, r24
            (ANGLE_C*ANGLE_C + 2*ANGLE_C*ANGLE_Y - pow(f,2.0) + ANGLE_X*ANGLE_X + ANGLE_Y*ANGLE_Y)))/M_PI;
}

//Returns tilt angle between 0 to 90 degrees positive. input values in millimeters 
float tiltConversion(uint16_t f){
    return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_X*TILT_X + TILT_Y*TILT_Y)*
     68c:	c7 01       	movw	r24, r14
     68e:	b6 01       	movw	r22, r12
     690:	0e 94 41 1a 	call	0x3482	; 0x3482 <__divsf3>
     694:	0e 94 15 1a 	call	0x342a	; 0x342a <atan>
     698:	20 e0       	ldi	r18, 0x00	; 0
     69a:	30 e0       	ldi	r19, 0x00	; 0
     69c:	44 eb       	ldi	r20, 0xB4	; 180
     69e:	53 e4       	ldi	r21, 0x43	; 67
     6a0:	0e 94 b7 1b 	call	0x376e	; 0x376e <__mulsf3>
              (TILT_C*TILT_C + 2L*TILT_C*f + pow(f,2.0)- TILT_X*TILT_X - TILT_Y*TILT_Y)))/
              (TILT_C*TILT_C + 2L*TILT_C*TILT_Y - pow(f,2.0) + TILT_X*TILT_X + TILT_Y*TILT_Y)))/M_PI;
     6a4:	2b ed       	ldi	r18, 0xDB	; 219
     6a6:	3f e0       	ldi	r19, 0x0F	; 15
     6a8:	49 e4       	ldi	r20, 0x49	; 73
     6aa:	50 e4       	ldi	r21, 0x40	; 64
     6ac:	0e 94 41 1a 	call	0x3482	; 0x3482 <__divsf3>
     6b0:	9b 01       	movw	r18, r22
     6b2:	ac 01       	movw	r20, r24
            (ANGLE_C*ANGLE_C + 2*ANGLE_C*ANGLE_Y - pow(f,2.0) + ANGLE_X*ANGLE_X + ANGLE_Y*ANGLE_Y)))/M_PI;
}

//Returns tilt angle between 0 to 90 degrees positive. input values in millimeters 
float tiltConversion(uint16_t f){
    return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_X*TILT_X + TILT_Y*TILT_Y)*
     6b4:	60 e0       	ldi	r22, 0x00	; 0
     6b6:	70 e0       	ldi	r23, 0x00	; 0
     6b8:	84 eb       	ldi	r24, 0xB4	; 180
     6ba:	92 e4       	ldi	r25, 0x42	; 66
     6bc:	0e 94 b0 19 	call	0x3360	; 0x3360 <__subsf3>
              (TILT_C*TILT_C + 2L*TILT_C*f + pow(f,2.0)- TILT_X*TILT_X - TILT_Y*TILT_Y)))/
              (TILT_C*TILT_C + 2L*TILT_C*TILT_Y - pow(f,2.0) + TILT_X*TILT_X + TILT_Y*TILT_Y)))/M_PI;
}
     6c0:	ff 90       	pop	r15
     6c2:	ef 90       	pop	r14
     6c4:	df 90       	pop	r13
     6c6:	cf 90       	pop	r12
     6c8:	bf 90       	pop	r11
     6ca:	af 90       	pop	r10
     6cc:	9f 90       	pop	r9
     6ce:	8f 90       	pop	r8
     6d0:	7f 90       	pop	r7
     6d2:	6f 90       	pop	r6
     6d4:	5f 90       	pop	r5
     6d6:	4f 90       	pop	r4
     6d8:	08 95       	ret

000006da <getAngle>:


float getAngle(void){
    return motors[ANGLE_MOTOR].current_position;
     6da:	60 91 3b 01 	lds	r22, 0x013B	; 0x80013b <motors+0x2d>
     6de:	70 91 3c 01 	lds	r23, 0x013C	; 0x80013c <motors+0x2e>
     6e2:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <motors+0x2f>
     6e6:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <motors+0x30>
}
     6ea:	08 95       	ret

000006ec <getTilt>:

float getTilt(void){
    return motors[TILT_MOTOR].current_position;
     6ec:	60 91 a0 01 	lds	r22, 0x01A0	; 0x8001a0 <motors+0x92>
     6f0:	70 91 a1 01 	lds	r23, 0x01A1	; 0x8001a1 <motors+0x93>
     6f4:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <motors+0x94>
     6f8:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <motors+0x95>
}
     6fc:	08 95       	ret

000006fe <setAngle>:

/*
    This function is used to set wanted Angle value
*/
uint8_t setAngle(float angle){
     6fe:	cf 92       	push	r12
     700:	df 92       	push	r13
     702:	ef 92       	push	r14
     704:	ff 92       	push	r15
     706:	6b 01       	movw	r12, r22
     708:	7c 01       	movw	r14, r24
    return setMotorPosition(&motors[TILT_MOTOR], tilt);
}

uint8_t setMotorPosition(volatile motor *m, float angle){
    //vefify that angle is in between valid range
    if (angle >= m->min_angle && angle <= (m->min_angle + m->angle_range)){
     70a:	20 91 4e 01 	lds	r18, 0x014E	; 0x80014e <motors+0x40>
     70e:	30 91 4f 01 	lds	r19, 0x014F	; 0x80014f <motors+0x41>
     712:	40 91 50 01 	lds	r20, 0x0150	; 0x800150 <motors+0x42>
     716:	50 91 51 01 	lds	r21, 0x0151	; 0x800151 <motors+0x43>
     71a:	0e 94 ac 1b 	call	0x3758	; 0x3758 <__gesf2>
     71e:	87 ff       	sbrs	r24, 7
     720:	06 c0       	rjmp	.+12     	; 0x72e <setAngle+0x30>
        m->set_position = angle;
        m->timeout_value = 0; //Clear timeout value on every angle change
        return 0;
    }
    else{
        return 1;
     722:	81 e0       	ldi	r24, 0x01	; 1
/*
    This function is used to set wanted Angle value
*/
uint8_t setAngle(float angle){
    return setMotorPosition(&motors[ANGLE_MOTOR], angle);
}
     724:	ff 90       	pop	r15
     726:	ef 90       	pop	r14
     728:	df 90       	pop	r13
     72a:	cf 90       	pop	r12
     72c:	08 95       	ret
    return setMotorPosition(&motors[TILT_MOTOR], tilt);
}

uint8_t setMotorPosition(volatile motor *m, float angle){
    //vefify that angle is in between valid range
    if (angle >= m->min_angle && angle <= (m->min_angle + m->angle_range)){
     72e:	60 91 4e 01 	lds	r22, 0x014E	; 0x80014e <motors+0x40>
     732:	70 91 4f 01 	lds	r23, 0x014F	; 0x80014f <motors+0x41>
     736:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <motors+0x42>
     73a:	90 91 51 01 	lds	r25, 0x0151	; 0x800151 <motors+0x43>
     73e:	20 91 52 01 	lds	r18, 0x0152	; 0x800152 <motors+0x44>
     742:	30 91 53 01 	lds	r19, 0x0153	; 0x800153 <motors+0x45>
     746:	40 91 54 01 	lds	r20, 0x0154	; 0x800154 <motors+0x46>
     74a:	50 91 55 01 	lds	r21, 0x0155	; 0x800155 <motors+0x47>
     74e:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     752:	9b 01       	movw	r18, r22
     754:	ac 01       	movw	r20, r24
     756:	c7 01       	movw	r24, r14
     758:	b6 01       	movw	r22, r12
     75a:	0e 94 3d 1a 	call	0x347a	; 0x347a <__cmpsf2>
     75e:	18 16       	cp	r1, r24
     760:	04 f3       	brlt	.-64     	; 0x722 <setAngle+0x24>
        m->set_position = angle;
     762:	c0 92 3f 01 	sts	0x013F, r12	; 0x80013f <motors+0x31>
     766:	d0 92 40 01 	sts	0x0140, r13	; 0x800140 <motors+0x32>
     76a:	e0 92 41 01 	sts	0x0141, r14	; 0x800141 <motors+0x33>
     76e:	f0 92 42 01 	sts	0x0142, r15	; 0x800142 <motors+0x34>
        m->timeout_value = 0; //Clear timeout value on every angle change
     772:	10 92 69 01 	sts	0x0169, r1	; 0x800169 <motors+0x5b>
     776:	10 92 68 01 	sts	0x0168, r1	; 0x800168 <motors+0x5a>
        return 0;
     77a:	80 e0       	ldi	r24, 0x00	; 0
/*
    This function is used to set wanted Angle value
*/
uint8_t setAngle(float angle){
    return setMotorPosition(&motors[ANGLE_MOTOR], angle);
}
     77c:	ff 90       	pop	r15
     77e:	ef 90       	pop	r14
     780:	df 90       	pop	r13
     782:	cf 90       	pop	r12
     784:	08 95       	ret

00000786 <setTilt>:

/*
    This function is used to set wanted TILT angle
*/
uint8_t setTilt(float tilt){
     786:	cf 92       	push	r12
     788:	df 92       	push	r13
     78a:	ef 92       	push	r14
     78c:	ff 92       	push	r15
     78e:	6b 01       	movw	r12, r22
     790:	7c 01       	movw	r14, r24
    return setMotorPosition(&motors[TILT_MOTOR], tilt);
}

uint8_t setMotorPosition(volatile motor *m, float angle){
    //vefify that angle is in between valid range
    if (angle >= m->min_angle && angle <= (m->min_angle + m->angle_range)){
     792:	20 91 b3 01 	lds	r18, 0x01B3	; 0x8001b3 <motors+0xa5>
     796:	30 91 b4 01 	lds	r19, 0x01B4	; 0x8001b4 <motors+0xa6>
     79a:	40 91 b5 01 	lds	r20, 0x01B5	; 0x8001b5 <motors+0xa7>
     79e:	50 91 b6 01 	lds	r21, 0x01B6	; 0x8001b6 <motors+0xa8>
     7a2:	0e 94 ac 1b 	call	0x3758	; 0x3758 <__gesf2>
     7a6:	87 ff       	sbrs	r24, 7
     7a8:	06 c0       	rjmp	.+12     	; 0x7b6 <setTilt+0x30>
        m->set_position = angle;
        m->timeout_value = 0; //Clear timeout value on every angle change
        return 0;
    }
    else{
        return 1;
     7aa:	81 e0       	ldi	r24, 0x01	; 1
/*
    This function is used to set wanted TILT angle
*/
uint8_t setTilt(float tilt){
    return setMotorPosition(&motors[TILT_MOTOR], tilt);
}
     7ac:	ff 90       	pop	r15
     7ae:	ef 90       	pop	r14
     7b0:	df 90       	pop	r13
     7b2:	cf 90       	pop	r12
     7b4:	08 95       	ret

uint8_t setMotorPosition(volatile motor *m, float angle){
    //vefify that angle is in between valid range
    if (angle >= m->min_angle && angle <= (m->min_angle + m->angle_range)){
     7b6:	60 91 b3 01 	lds	r22, 0x01B3	; 0x8001b3 <motors+0xa5>
     7ba:	70 91 b4 01 	lds	r23, 0x01B4	; 0x8001b4 <motors+0xa6>
     7be:	80 91 b5 01 	lds	r24, 0x01B5	; 0x8001b5 <motors+0xa7>
     7c2:	90 91 b6 01 	lds	r25, 0x01B6	; 0x8001b6 <motors+0xa8>
     7c6:	20 91 b7 01 	lds	r18, 0x01B7	; 0x8001b7 <motors+0xa9>
     7ca:	30 91 b8 01 	lds	r19, 0x01B8	; 0x8001b8 <motors+0xaa>
     7ce:	40 91 b9 01 	lds	r20, 0x01B9	; 0x8001b9 <motors+0xab>
     7d2:	50 91 ba 01 	lds	r21, 0x01BA	; 0x8001ba <motors+0xac>
     7d6:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     7da:	9b 01       	movw	r18, r22
     7dc:	ac 01       	movw	r20, r24
     7de:	c7 01       	movw	r24, r14
     7e0:	b6 01       	movw	r22, r12
     7e2:	0e 94 3d 1a 	call	0x347a	; 0x347a <__cmpsf2>
     7e6:	18 16       	cp	r1, r24
     7e8:	04 f3       	brlt	.-64     	; 0x7aa <setTilt+0x24>
        m->set_position = angle;
     7ea:	c0 92 a4 01 	sts	0x01A4, r12	; 0x8001a4 <motors+0x96>
     7ee:	d0 92 a5 01 	sts	0x01A5, r13	; 0x8001a5 <motors+0x97>
     7f2:	e0 92 a6 01 	sts	0x01A6, r14	; 0x8001a6 <motors+0x98>
     7f6:	f0 92 a7 01 	sts	0x01A7, r15	; 0x8001a7 <motors+0x99>
        m->timeout_value = 0; //Clear timeout value on every angle change
     7fa:	10 92 ce 01 	sts	0x01CE, r1	; 0x8001ce <motors+0xc0>
     7fe:	10 92 cd 01 	sts	0x01CD, r1	; 0x8001cd <motors+0xbf>
        return 0;
     802:	80 e0       	ldi	r24, 0x00	; 0
/*
    This function is used to set wanted TILT angle
*/
uint8_t setTilt(float tilt){
    return setMotorPosition(&motors[TILT_MOTOR], tilt);
}
     804:	ff 90       	pop	r15
     806:	ef 90       	pop	r14
     808:	df 90       	pop	r13
     80a:	cf 90       	pop	r12
     80c:	08 95       	ret

0000080e <setMotorPosition>:

uint8_t setMotorPosition(volatile motor *m, float angle){
     80e:	a0 e0       	ldi	r26, 0x00	; 0
     810:	b0 e0       	ldi	r27, 0x00	; 0
     812:	ed e0       	ldi	r30, 0x0D	; 13
     814:	f4 e0       	ldi	r31, 0x04	; 4
     816:	0c 94 af 1c 	jmp	0x395e	; 0x395e <__prologue_saves__+0x14>
     81a:	ec 01       	movw	r28, r24
     81c:	6a 01       	movw	r12, r20
     81e:	7b 01       	movw	r14, r22
    //vefify that angle is in between valid range
    if (angle >= m->min_angle && angle <= (m->min_angle + m->angle_range)){
     820:	8c 01       	movw	r16, r24
     822:	00 5c       	subi	r16, 0xC0	; 192
     824:	1f 4f       	sbci	r17, 0xFF	; 255
     826:	f8 01       	movw	r30, r16
     828:	60 81       	ld	r22, Z
     82a:	71 81       	ldd	r23, Z+1	; 0x01
     82c:	82 81       	ldd	r24, Z+2	; 0x02
     82e:	93 81       	ldd	r25, Z+3	; 0x03
     830:	a7 01       	movw	r20, r14
     832:	96 01       	movw	r18, r12
     834:	0e 94 3d 1a 	call	0x347a	; 0x347a <__cmpsf2>
     838:	18 16       	cp	r1, r24
     83a:	1c f1       	brlt	.+70     	; 0x882 <setMotorPosition+0x74>
     83c:	f8 01       	movw	r30, r16
     83e:	60 81       	ld	r22, Z
     840:	71 81       	ldd	r23, Z+1	; 0x01
     842:	82 81       	ldd	r24, Z+2	; 0x02
     844:	93 81       	ldd	r25, Z+3	; 0x03
     846:	34 96       	adiw	r30, 0x04	; 4
     848:	20 81       	ld	r18, Z
     84a:	31 81       	ldd	r19, Z+1	; 0x01
     84c:	42 81       	ldd	r20, Z+2	; 0x02
     84e:	53 81       	ldd	r21, Z+3	; 0x03
     850:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     854:	9b 01       	movw	r18, r22
     856:	ac 01       	movw	r20, r24
     858:	c7 01       	movw	r24, r14
     85a:	b6 01       	movw	r22, r12
     85c:	0e 94 3d 1a 	call	0x347a	; 0x347a <__cmpsf2>
     860:	18 16       	cp	r1, r24
     862:	7c f0       	brlt	.+30     	; 0x882 <setMotorPosition+0x74>
        m->set_position = angle;
     864:	c9 aa       	std	Y+49, r12	; 0x31
     866:	da aa       	std	Y+50, r13	; 0x32
     868:	eb aa       	std	Y+51, r14	; 0x33
     86a:	fc aa       	std	Y+52, r15	; 0x34
        m->timeout_value = 0; //Clear timeout value on every angle change
     86c:	c6 5a       	subi	r28, 0xA6	; 166
     86e:	df 4f       	sbci	r29, 0xFF	; 255
     870:	19 82       	std	Y+1, r1	; 0x01
     872:	18 82       	st	Y, r1
        return 0;
     874:	80 e0       	ldi	r24, 0x00	; 0
    }
    else{
        return 1;
    }
}   
     876:	cd b7       	in	r28, 0x3d	; 61
     878:	de b7       	in	r29, 0x3e	; 62
     87a:	e8 e0       	ldi	r30, 0x08	; 8
     87c:	0c 94 cb 1c 	jmp	0x3996	; 0x3996 <__epilogue_restores__+0x14>
     880:	06 c0       	rjmp	.+12     	; 0x88e <getSetAngle>
        m->set_position = angle;
        m->timeout_value = 0; //Clear timeout value on every angle change
        return 0;
    }
    else{
        return 1;
     882:	81 e0       	ldi	r24, 0x01	; 1
    }
}   
     884:	cd b7       	in	r28, 0x3d	; 61
     886:	de b7       	in	r29, 0x3e	; 62
     888:	e8 e0       	ldi	r30, 0x08	; 8
     88a:	0c 94 cb 1c 	jmp	0x3996	; 0x3996 <__epilogue_restores__+0x14>

0000088e <getSetAngle>:

/*
    Returns current Angle Set value
*/
float getSetAngle(void){
    return motors[ANGLE_MOTOR].set_position;
     88e:	60 91 3f 01 	lds	r22, 0x013F	; 0x80013f <motors+0x31>
     892:	70 91 40 01 	lds	r23, 0x0140	; 0x800140 <motors+0x32>
     896:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <motors+0x33>
     89a:	90 91 42 01 	lds	r25, 0x0142	; 0x800142 <motors+0x34>
}
     89e:	08 95       	ret

000008a0 <getSetTilt>:

/*
    Returns current Tilt Set value  
*/
float getSetTilt(void){
    return motors[TILT_MOTOR].set_position;
     8a0:	60 91 a4 01 	lds	r22, 0x01A4	; 0x8001a4 <motors+0x96>
     8a4:	70 91 a5 01 	lds	r23, 0x01A5	; 0x8001a5 <motors+0x97>
     8a8:	80 91 a6 01 	lds	r24, 0x01A6	; 0x8001a6 <motors+0x98>
     8ac:	90 91 a7 01 	lds	r25, 0x01A7	; 0x8001a7 <motors+0x99>
}
     8b0:	08 95       	ret

000008b2 <getAngleMotorStatus>:

/*
    Returns Angle motor status  
*/
motor_status getAngleMotorStatus(void){
    return motors[ANGLE_MOTOR].status;
     8b2:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <motors+0x5c>
}
     8b6:	08 95       	ret

000008b8 <getTiltMotorStatus>:

/*
    Returns Tilt motor status,   
*/
motor_status getTiltMotorStatus(void){
    return motors[TILT_MOTOR].status;
     8b8:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <motors+0xc1>
}
     8bc:	08 95       	ret

000008be <delayLoop_us>:
        _delay_ms(50);
    }
}

void delayLoop_us(uint16_t delay){
    for (uint16_t i = 0; i < delay/50; i++){
     8be:	9c 01       	movw	r18, r24
     8c0:	36 95       	lsr	r19
     8c2:	27 95       	ror	r18
     8c4:	ab e7       	ldi	r26, 0x7B	; 123
     8c6:	b4 e1       	ldi	r27, 0x14	; 20
     8c8:	0e 94 96 1c 	call	0x392c	; 0x392c <__umulhisi3>
     8cc:	96 95       	lsr	r25
     8ce:	87 95       	ror	r24
     8d0:	00 97       	sbiw	r24, 0x00	; 0
     8d2:	59 f0       	breq	.+22     	; 0x8ea <delayLoop_us+0x2c>
     8d4:	20 e0       	ldi	r18, 0x00	; 0
     8d6:	30 e0       	ldi	r19, 0x00	; 0
     8d8:	4a ef       	ldi	r20, 0xFA	; 250
     8da:	4a 95       	dec	r20
     8dc:	f1 f7       	brne	.-4      	; 0x8da <delayLoop_us+0x1c>
     8de:	00 c0       	rjmp	.+0      	; 0x8e0 <delayLoop_us+0x22>
     8e0:	2f 5f       	subi	r18, 0xFF	; 255
     8e2:	3f 4f       	sbci	r19, 0xFF	; 255
     8e4:	28 17       	cp	r18, r24
     8e6:	39 07       	cpc	r19, r25
     8e8:	b9 f7       	brne	.-18     	; 0x8d8 <delayLoop_us+0x1a>
     8ea:	08 95       	ret

000008ec <disableMotorPWM>:
    //motors[ANGLE_MOTOR].current_position = getAngle();
    //motors[TILT_MOTOR].current_position  = getTilt();    
    
   // GTCCR = 0x00;       //Start Counter
}
void disableMotorPWM(volatile motor *m){
     8ec:	fc 01       	movw	r30, r24

    *m->enable_port_addr &= ~(1<<m->enable_pin); //Disable motor => clear enable port
     8ee:	36 8d       	ldd	r19, Z+30	; 0x1e
     8f0:	a2 8d       	ldd	r26, Z+26	; 0x1a
     8f2:	b3 8d       	ldd	r27, Z+27	; 0x1b
     8f4:	2c 91       	ld	r18, X
     8f6:	81 e0       	ldi	r24, 0x01	; 1
     8f8:	90 e0       	ldi	r25, 0x00	; 0
     8fa:	02 c0       	rjmp	.+4      	; 0x900 <__stack+0x1>
     8fc:	88 0f       	add	r24, r24
     8fe:	99 1f       	adc	r25, r25
     900:	3a 95       	dec	r19
     902:	e2 f7       	brpl	.-8      	; 0x8fc <disableMotorPWM+0x10>
     904:	80 95       	com	r24
     906:	90 95       	com	r25
     908:	82 23       	and	r24, r18
     90a:	8c 93       	st	X, r24
    *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
     90c:	a5 81       	ldd	r26, Z+5	; 0x05
     90e:	b6 81       	ldd	r27, Z+6	; 0x06
     910:	1c 92       	st	X, r1
    *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
     912:	a0 85       	ldd	r26, Z+8	; 0x08
     914:	b1 85       	ldd	r27, Z+9	; 0x09
     916:	1c 92       	st	X, r1
    *m->fwd_OCR_addr = 0x00; //Init PWM to zero
     918:	a3 85       	ldd	r26, Z+11	; 0x0b
     91a:	b4 85       	ldd	r27, Z+12	; 0x0c
     91c:	1c 92       	st	X, r1
    
    //Init reverse PWM settings
    *m->rev_TCCRA_addr = 0x00;//m.rev_TCCRA_value;
     91e:	a2 89       	ldd	r26, Z+18	; 0x12
     920:	b3 89       	ldd	r27, Z+19	; 0x13
     922:	1c 92       	st	X, r1
    *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
     924:	a5 89       	ldd	r26, Z+21	; 0x15
     926:	b6 89       	ldd	r27, Z+22	; 0x16
     928:	1c 92       	st	X, r1
    *m->rev_OCR_addr = 0x00; //Init PWM to zero
     92a:	a0 8d       	ldd	r26, Z+24	; 0x18
     92c:	b1 8d       	ldd	r27, Z+25	; 0x19
     92e:	1c 92       	st	X, r1
    m->current_pwm = 0; //set PWM to zero
     930:	13 a6       	std	Z+43, r1	; 0x2b
    m->timeout_value = 0; //Reset timeout values
     932:	e6 5a       	subi	r30, 0xA6	; 166
     934:	ff 4f       	sbci	r31, 0xFF	; 255
     936:	11 82       	std	Z+1, r1	; 0x01
     938:	10 82       	st	Z, r1
     93a:	08 95       	ret

0000093c <setMotor>:
    
} 
//volatile uint8_t *OCRC_ADDR[] = {&OCR1CL, &OCR4AL }
//volatile uint8_t *OCRB_ADDR[] = {&OCR1BL, &OCR4BL }

void setMotor(volatile motor *m, uint8_t dir, uint8_t pwm){
     93c:	fc 01       	movw	r30, r24
    m->current_pwm = pwm;
     93e:	43 a7       	std	Z+43, r20	; 0x2b
    if (pwm > 0){
     940:	44 23       	and	r20, r20
     942:	a1 f1       	breq	.+104    	; 0x9ac <setMotor+0x70>
        if (dir == FORWARD){ //Forward
     944:	61 30       	cpi	r22, 0x01	; 1
     946:	09 f4       	brne	.+2      	; 0x94a <setMotor+0xe>
     948:	58 c0       	rjmp	.+176    	; 0x9fa <setMotor+0xbe>
            
            *m->rev_TCCRB_addr = 0x00; //Disable clock Rev
            *m->fwd_TCCRB_addr = m->fwd_TCCRB_value;
        }
        else{ //Backward
            *m->fwd_OCR_addr = 0x00;
     94a:	a3 85       	ldd	r26, Z+11	; 0x0b
     94c:	b4 85       	ldd	r27, Z+12	; 0x0c
     94e:	1c 92       	st	X, r1
            *m->rev_OCR_addr = pwm; 
     950:	a0 8d       	ldd	r26, Z+24	; 0x18
     952:	b1 8d       	ldd	r27, Z+25	; 0x19
     954:	4c 93       	st	X, r20
            *m->fwd_port_addr &= ~(1<<m->fwd_pin);
     956:	34 81       	ldd	r19, Z+4	; 0x04
     958:	a0 81       	ld	r26, Z
     95a:	b1 81       	ldd	r27, Z+1	; 0x01
     95c:	2c 91       	ld	r18, X
     95e:	81 e0       	ldi	r24, 0x01	; 1
     960:	90 e0       	ldi	r25, 0x00	; 0
     962:	02 c0       	rjmp	.+4      	; 0x968 <setMotor+0x2c>
     964:	88 0f       	add	r24, r24
     966:	99 1f       	adc	r25, r25
     968:	3a 95       	dec	r19
     96a:	e2 f7       	brpl	.-8      	; 0x964 <setMotor+0x28>
     96c:	80 95       	com	r24
     96e:	90 95       	com	r25
     970:	82 23       	and	r24, r18
     972:	8c 93       	st	X, r24
            *m->fwd_TCCRA_addr = 0x00; //Disable FWD
     974:	a5 81       	ldd	r26, Z+5	; 0x05
     976:	b6 81       	ldd	r27, Z+6	; 0x06
     978:	1c 92       	st	X, r1
            *m->rev_TCCRA_addr = m->rev_TCCRA_value;
     97a:	a2 89       	ldd	r26, Z+18	; 0x12
     97c:	b3 89       	ldd	r27, Z+19	; 0x13
     97e:	84 89       	ldd	r24, Z+20	; 0x14
     980:	8c 93       	st	X, r24

            *m->fwd_TCCRB_addr = 0x00;
     982:	a0 85       	ldd	r26, Z+8	; 0x08
     984:	b1 85       	ldd	r27, Z+9	; 0x09
     986:	1c 92       	st	X, r1
            *m->rev_TCCRB_addr = m->rev_TCCRB_value;
     988:	a5 89       	ldd	r26, Z+21	; 0x15
     98a:	b6 89       	ldd	r27, Z+22	; 0x16
     98c:	87 89       	ldd	r24, Z+23	; 0x17
     98e:	8c 93       	st	X, r24
        }        
        *m->enable_port_addr |= 1<<m->enable_pin; 
     990:	36 8d       	ldd	r19, Z+30	; 0x1e
     992:	02 8c       	ldd	r0, Z+26	; 0x1a
     994:	f3 8d       	ldd	r31, Z+27	; 0x1b
     996:	e0 2d       	mov	r30, r0
     998:	20 81       	ld	r18, Z
     99a:	81 e0       	ldi	r24, 0x01	; 1
     99c:	90 e0       	ldi	r25, 0x00	; 0
     99e:	01 c0       	rjmp	.+2      	; 0x9a2 <setMotor+0x66>
     9a0:	88 0f       	add	r24, r24
     9a2:	3a 95       	dec	r19
     9a4:	ea f7       	brpl	.-6      	; 0x9a0 <setMotor+0x64>
     9a6:	82 2b       	or	r24, r18
     9a8:	80 83       	st	Z, r24
     9aa:	08 95       	ret
    
   // GTCCR = 0x00;       //Start Counter
}
void disableMotorPWM(volatile motor *m){

    *m->enable_port_addr &= ~(1<<m->enable_pin); //Disable motor => clear enable port
     9ac:	36 8d       	ldd	r19, Z+30	; 0x1e
     9ae:	a2 8d       	ldd	r26, Z+26	; 0x1a
     9b0:	b3 8d       	ldd	r27, Z+27	; 0x1b
     9b2:	2c 91       	ld	r18, X
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	02 c0       	rjmp	.+4      	; 0x9be <setMotor+0x82>
     9ba:	88 0f       	add	r24, r24
     9bc:	99 1f       	adc	r25, r25
     9be:	3a 95       	dec	r19
     9c0:	e2 f7       	brpl	.-8      	; 0x9ba <setMotor+0x7e>
     9c2:	80 95       	com	r24
     9c4:	90 95       	com	r25
     9c6:	82 23       	and	r24, r18
     9c8:	8c 93       	st	X, r24
    *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
     9ca:	a5 81       	ldd	r26, Z+5	; 0x05
     9cc:	b6 81       	ldd	r27, Z+6	; 0x06
     9ce:	1c 92       	st	X, r1
    *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
     9d0:	a0 85       	ldd	r26, Z+8	; 0x08
     9d2:	b1 85       	ldd	r27, Z+9	; 0x09
     9d4:	1c 92       	st	X, r1
    *m->fwd_OCR_addr = 0x00; //Init PWM to zero
     9d6:	a3 85       	ldd	r26, Z+11	; 0x0b
     9d8:	b4 85       	ldd	r27, Z+12	; 0x0c
     9da:	1c 92       	st	X, r1
    
    //Init reverse PWM settings
    *m->rev_TCCRA_addr = 0x00;//m.rev_TCCRA_value;
     9dc:	a2 89       	ldd	r26, Z+18	; 0x12
     9de:	b3 89       	ldd	r27, Z+19	; 0x13
     9e0:	1c 92       	st	X, r1
    *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
     9e2:	a5 89       	ldd	r26, Z+21	; 0x15
     9e4:	b6 89       	ldd	r27, Z+22	; 0x16
     9e6:	1c 92       	st	X, r1
    *m->rev_OCR_addr = 0x00; //Init PWM to zero
     9e8:	a0 8d       	ldd	r26, Z+24	; 0x18
     9ea:	b1 8d       	ldd	r27, Z+25	; 0x19
     9ec:	1c 92       	st	X, r1
    m->current_pwm = 0; //set PWM to zero
     9ee:	13 a6       	std	Z+43, r1	; 0x2b
    m->timeout_value = 0; //Reset timeout values
     9f0:	e6 5a       	subi	r30, 0xA6	; 166
     9f2:	ff 4f       	sbci	r31, 0xFF	; 255
     9f4:	11 82       	std	Z+1, r1	; 0x01
     9f6:	10 82       	st	Z, r1
     9f8:	08 95       	ret

void setMotor(volatile motor *m, uint8_t dir, uint8_t pwm){
    m->current_pwm = pwm;
    if (pwm > 0){
        if (dir == FORWARD){ //Forward
            *m->rev_OCR_addr = 0x00; //PWM pulse width
     9fa:	a0 8d       	ldd	r26, Z+24	; 0x18
     9fc:	b1 8d       	ldd	r27, Z+25	; 0x19
     9fe:	1c 92       	st	X, r1
            *m->fwd_OCR_addr = pwm; 
     a00:	a3 85       	ldd	r26, Z+11	; 0x0b
     a02:	b4 85       	ldd	r27, Z+12	; 0x0c
     a04:	4c 93       	st	X, r20
            *m->rev_port_addr &= ~(1<<m->rev_pin);
     a06:	31 89       	ldd	r19, Z+17	; 0x11
     a08:	a5 85       	ldd	r26, Z+13	; 0x0d
     a0a:	b6 85       	ldd	r27, Z+14	; 0x0e
     a0c:	2c 91       	ld	r18, X
     a0e:	81 e0       	ldi	r24, 0x01	; 1
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	02 c0       	rjmp	.+4      	; 0xa18 <setMotor+0xdc>
     a14:	88 0f       	add	r24, r24
     a16:	99 1f       	adc	r25, r25
     a18:	3a 95       	dec	r19
     a1a:	e2 f7       	brpl	.-8      	; 0xa14 <setMotor+0xd8>
     a1c:	80 95       	com	r24
     a1e:	90 95       	com	r25
     a20:	82 23       	and	r24, r18
     a22:	8c 93       	st	X, r24
            *m->rev_TCCRA_addr = 0x00; //Disable reverse
     a24:	a2 89       	ldd	r26, Z+18	; 0x12
     a26:	b3 89       	ldd	r27, Z+19	; 0x13
     a28:	1c 92       	st	X, r1
            *m->fwd_TCCRA_addr = m->fwd_TCCRA_value; //Activate PWM forward
     a2a:	a5 81       	ldd	r26, Z+5	; 0x05
     a2c:	b6 81       	ldd	r27, Z+6	; 0x06
     a2e:	87 81       	ldd	r24, Z+7	; 0x07
     a30:	8c 93       	st	X, r24
            
            *m->rev_TCCRB_addr = 0x00; //Disable clock Rev
     a32:	a5 89       	ldd	r26, Z+21	; 0x15
     a34:	b6 89       	ldd	r27, Z+22	; 0x16
     a36:	1c 92       	st	X, r1
            *m->fwd_TCCRB_addr = m->fwd_TCCRB_value;
     a38:	a0 85       	ldd	r26, Z+8	; 0x08
     a3a:	b1 85       	ldd	r27, Z+9	; 0x09
     a3c:	82 85       	ldd	r24, Z+10	; 0x0a
     a3e:	8c 93       	st	X, r24
     a40:	a7 cf       	rjmp	.-178    	; 0x990 <setMotor+0x54>

00000a42 <motorControl>:
    for (uint16_t i = 0; i < delay/50; i++){
        _delay_us(47);
    }
}

void motorControl(volatile motor *m, uint8_t dir, uint8_t pwm){
     a42:	0f 93       	push	r16
     a44:	1f 93       	push	r17
     a46:	cf 93       	push	r28
     a48:	df 93       	push	r29
     a4a:	ec 01       	movw	r28, r24
     a4c:	06 2f       	mov	r16, r22
     a4e:	14 2f       	mov	r17, r20
    //verify min/max
    if (pwm > m->max_pwm){
     a50:	8f ad       	ldd	r24, Y+63	; 0x3f
     a52:	84 17       	cp	r24, r20
     a54:	08 f4       	brcc	.+2      	; 0xa58 <motorControl+0x16>
        pwm = m->max_pwm;
     a56:	1f ad       	ldd	r17, Y+63	; 0x3f
    }
    
    //Set motor control
    if (m->current_pwm < pwm){ //Need to accelerate
     a58:	8b a5       	ldd	r24, Y+43	; 0x2b
     a5a:	81 17       	cp	r24, r17
     a5c:	08 f0       	brcs	.+2      	; 0xa60 <motorControl+0x1e>
     a5e:	69 c0       	rjmp	.+210    	; 0xb32 <motorControl+0xf0>
        for(; m->current_pwm < pwm; m->current_pwm++){
     a60:	8b a5       	ldd	r24, Y+43	; 0x2b
     a62:	81 17       	cp	r24, r17
     a64:	08 f0       	brcs	.+2      	; 0xa68 <motorControl+0x26>
     a66:	5b c0       	rjmp	.+182    	; 0xb1e <motorControl+0xdc>
            *m->rev_TCCRA_addr = m->rev_TCCRA_value;

            *m->fwd_TCCRB_addr = 0x00;
            *m->rev_TCCRB_addr = m->rev_TCCRB_value;
        }        
        *m->enable_port_addr |= 1<<m->enable_pin; 
     a68:	41 e0       	ldi	r20, 0x01	; 1
     a6a:	50 e0       	ldi	r21, 0x00	; 0
    //Init reverse PWM settings
    *m->rev_TCCRA_addr = 0x00;//m.rev_TCCRA_value;
    *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
    *m->rev_OCR_addr = 0x00; //Init PWM to zero
    m->current_pwm = 0; //set PWM to zero
    m->timeout_value = 0; //Reset timeout values
     a6c:	fe 01       	movw	r30, r28
     a6e:	e6 5a       	subi	r30, 0xA6	; 166
     a70:	ff 4f       	sbci	r31, 0xFF	; 255
    }
    
    //Set motor control
    if (m->current_pwm < pwm){ //Need to accelerate
        for(; m->current_pwm < pwm; m->current_pwm++){
            setMotor(m, dir, m->current_pwm);
     a72:	8b a5       	ldd	r24, Y+43	; 0x2b
} 
//volatile uint8_t *OCRC_ADDR[] = {&OCR1CL, &OCR4AL }
//volatile uint8_t *OCRB_ADDR[] = {&OCR1BL, &OCR4BL }

void setMotor(volatile motor *m, uint8_t dir, uint8_t pwm){
    m->current_pwm = pwm;
     a74:	8b a7       	std	Y+43, r24	; 0x2b
    if (pwm > 0){
     a76:	88 23       	and	r24, r24
     a78:	09 f4       	brne	.+2      	; 0xa7c <motorControl+0x3a>
     a7a:	80 c0       	rjmp	.+256    	; 0xb7c <motorControl+0x13a>
        if (dir == FORWARD){ //Forward
     a7c:	01 30       	cpi	r16, 0x01	; 1
     a7e:	09 f4       	brne	.+2      	; 0xa82 <motorControl+0x40>
     a80:	a2 c0       	rjmp	.+324    	; 0xbc6 <motorControl+0x184>
            
            *m->rev_TCCRB_addr = 0x00; //Disable clock Rev
            *m->fwd_TCCRB_addr = m->fwd_TCCRB_value;
        }
        else{ //Backward
            *m->fwd_OCR_addr = 0x00;
     a82:	ab 85       	ldd	r26, Y+11	; 0x0b
     a84:	bc 85       	ldd	r27, Y+12	; 0x0c
     a86:	1c 92       	st	X, r1
            *m->rev_OCR_addr = pwm; 
     a88:	a8 8d       	ldd	r26, Y+24	; 0x18
     a8a:	b9 8d       	ldd	r27, Y+25	; 0x19
     a8c:	8c 93       	st	X, r24
            *m->fwd_port_addr &= ~(1<<m->fwd_pin);
     a8e:	8c 81       	ldd	r24, Y+4	; 0x04
     a90:	a8 81       	ld	r26, Y
     a92:	b9 81       	ldd	r27, Y+1	; 0x01
     a94:	2c 91       	ld	r18, X
     a96:	ba 01       	movw	r22, r20
     a98:	02 c0       	rjmp	.+4      	; 0xa9e <motorControl+0x5c>
     a9a:	66 0f       	add	r22, r22
     a9c:	77 1f       	adc	r23, r23
     a9e:	8a 95       	dec	r24
     aa0:	e2 f7       	brpl	.-8      	; 0xa9a <motorControl+0x58>
     aa2:	cb 01       	movw	r24, r22
     aa4:	80 95       	com	r24
     aa6:	90 95       	com	r25
     aa8:	82 23       	and	r24, r18
     aaa:	8c 93       	st	X, r24
            *m->fwd_TCCRA_addr = 0x00; //Disable FWD
     aac:	ad 81       	ldd	r26, Y+5	; 0x05
     aae:	be 81       	ldd	r27, Y+6	; 0x06
     ab0:	1c 92       	st	X, r1
            *m->rev_TCCRA_addr = m->rev_TCCRA_value;
     ab2:	aa 89       	ldd	r26, Y+18	; 0x12
     ab4:	bb 89       	ldd	r27, Y+19	; 0x13
     ab6:	8c 89       	ldd	r24, Y+20	; 0x14
     ab8:	8c 93       	st	X, r24

            *m->fwd_TCCRB_addr = 0x00;
     aba:	a8 85       	ldd	r26, Y+8	; 0x08
     abc:	b9 85       	ldd	r27, Y+9	; 0x09
     abe:	1c 92       	st	X, r1
            *m->rev_TCCRB_addr = m->rev_TCCRB_value;
     ac0:	ad 89       	ldd	r26, Y+21	; 0x15
     ac2:	be 89       	ldd	r27, Y+22	; 0x16
     ac4:	8f 89       	ldd	r24, Y+23	; 0x17
     ac6:	8c 93       	st	X, r24
        }        
        *m->enable_port_addr |= 1<<m->enable_pin; 
     ac8:	8e 8d       	ldd	r24, Y+30	; 0x1e
     aca:	aa 8d       	ldd	r26, Y+26	; 0x1a
     acc:	bb 8d       	ldd	r27, Y+27	; 0x1b
     ace:	2c 91       	ld	r18, X
     ad0:	ba 01       	movw	r22, r20
     ad2:	02 c0       	rjmp	.+4      	; 0xad8 <motorControl+0x96>
     ad4:	66 0f       	add	r22, r22
     ad6:	77 1f       	adc	r23, r23
     ad8:	8a 95       	dec	r24
     ada:	e2 f7       	brpl	.-8      	; 0xad4 <motorControl+0x92>
     adc:	cb 01       	movw	r24, r22
     ade:	82 2b       	or	r24, r18
     ae0:	8c 93       	st	X, r24
    //Set motor control
    if (m->current_pwm < pwm){ //Need to accelerate
        for(; m->current_pwm < pwm; m->current_pwm++){
            setMotor(m, dir, m->current_pwm);
            //getActuatorLength(m);
            delayLoop_us(m->acceleration_time);
     ae2:	2f a9       	ldd	r18, Y+55	; 0x37
     ae4:	38 ad       	ldd	r19, Y+56	; 0x38
        _delay_ms(50);
    }
}

void delayLoop_us(uint16_t delay){
    for (uint16_t i = 0; i < delay/50; i++){
     ae6:	36 95       	lsr	r19
     ae8:	27 95       	ror	r18
     aea:	ab e7       	ldi	r26, 0x7B	; 123
     aec:	b4 e1       	ldi	r27, 0x14	; 20
     aee:	0e 94 96 1c 	call	0x392c	; 0x392c <__umulhisi3>
     af2:	96 95       	lsr	r25
     af4:	87 95       	ror	r24
     af6:	00 97       	sbiw	r24, 0x00	; 0
     af8:	59 f0       	breq	.+22     	; 0xb10 <motorControl+0xce>
     afa:	20 e0       	ldi	r18, 0x00	; 0
     afc:	30 e0       	ldi	r19, 0x00	; 0
     afe:	7a ef       	ldi	r23, 0xFA	; 250
     b00:	7a 95       	dec	r23
     b02:	f1 f7       	brne	.-4      	; 0xb00 <motorControl+0xbe>
     b04:	00 c0       	rjmp	.+0      	; 0xb06 <motorControl+0xc4>
     b06:	2f 5f       	subi	r18, 0xFF	; 255
     b08:	3f 4f       	sbci	r19, 0xFF	; 255
     b0a:	28 17       	cp	r18, r24
     b0c:	39 07       	cpc	r19, r25
     b0e:	b9 f7       	brne	.-18     	; 0xafe <motorControl+0xbc>
        pwm = m->max_pwm;
    }
    
    //Set motor control
    if (m->current_pwm < pwm){ //Need to accelerate
        for(; m->current_pwm < pwm; m->current_pwm++){
     b10:	8b a5       	ldd	r24, Y+43	; 0x2b
     b12:	8f 5f       	subi	r24, 0xFF	; 255
     b14:	8b a7       	std	Y+43, r24	; 0x2b
     b16:	8b a5       	ldd	r24, Y+43	; 0x2b
     b18:	81 17       	cp	r24, r17
     b1a:	08 f4       	brcc	.+2      	; 0xb1e <motorControl+0xdc>
     b1c:	aa cf       	rjmp	.-172    	; 0xa72 <motorControl+0x30>
        for(; m->current_pwm > pwm; m->current_pwm--){
            setMotor(m, dir, m->current_pwm);
            //getActuatorLength(m);
            delayLoop_us(m->deacceleration_time);
        } 
        setMotor(m, dir, m->current_pwm);
     b1e:	4b a5       	ldd	r20, Y+43	; 0x2b
     b20:	60 2f       	mov	r22, r16
     b22:	ce 01       	movw	r24, r28
     b24:	0b df       	rcall	.-490    	; 0x93c <setMotor>
    }
    m->current_dir = dir;
     b26:	0c a7       	std	Y+44, r16	; 0x2c
}
     b28:	df 91       	pop	r29
     b2a:	cf 91       	pop	r28
     b2c:	1f 91       	pop	r17
     b2e:	0f 91       	pop	r16
     b30:	08 95       	ret
            //getActuatorLength(m);
            delayLoop_us(m->acceleration_time);
        }
        setMotor(m, dir, m->current_pwm);
    }
    else if (m->current_pwm > pwm){
     b32:	8b a5       	ldd	r24, Y+43	; 0x2b
     b34:	18 17       	cp	r17, r24
     b36:	b8 f7       	brcc	.-18     	; 0xb26 <motorControl+0xe4>
        for(; m->current_pwm > pwm; m->current_pwm--){
     b38:	8b a5       	ldd	r24, Y+43	; 0x2b
     b3a:	18 17       	cp	r17, r24
     b3c:	80 f7       	brcc	.-32     	; 0xb1e <motorControl+0xdc>
            setMotor(m, dir, m->current_pwm);
     b3e:	4b a5       	ldd	r20, Y+43	; 0x2b
     b40:	60 2f       	mov	r22, r16
     b42:	ce 01       	movw	r24, r28
     b44:	fb de       	rcall	.-522    	; 0x93c <setMotor>
            //getActuatorLength(m);
            delayLoop_us(m->deacceleration_time);
     b46:	29 ad       	ldd	r18, Y+57	; 0x39
     b48:	3a ad       	ldd	r19, Y+58	; 0x3a
        _delay_ms(50);
    }
}

void delayLoop_us(uint16_t delay){
    for (uint16_t i = 0; i < delay/50; i++){
     b4a:	36 95       	lsr	r19
     b4c:	27 95       	ror	r18
     b4e:	ab e7       	ldi	r26, 0x7B	; 123
     b50:	b4 e1       	ldi	r27, 0x14	; 20
     b52:	0e 94 96 1c 	call	0x392c	; 0x392c <__umulhisi3>
     b56:	96 95       	lsr	r25
     b58:	87 95       	ror	r24
     b5a:	00 97       	sbiw	r24, 0x00	; 0
     b5c:	59 f0       	breq	.+22     	; 0xb74 <motorControl+0x132>
     b5e:	20 e0       	ldi	r18, 0x00	; 0
     b60:	30 e0       	ldi	r19, 0x00	; 0
     b62:	4a ef       	ldi	r20, 0xFA	; 250
     b64:	4a 95       	dec	r20
     b66:	f1 f7       	brne	.-4      	; 0xb64 <motorControl+0x122>
     b68:	00 c0       	rjmp	.+0      	; 0xb6a <motorControl+0x128>
     b6a:	2f 5f       	subi	r18, 0xFF	; 255
     b6c:	3f 4f       	sbci	r19, 0xFF	; 255
     b6e:	28 17       	cp	r18, r24
     b70:	39 07       	cpc	r19, r25
     b72:	b9 f7       	brne	.-18     	; 0xb62 <motorControl+0x120>
            delayLoop_us(m->acceleration_time);
        }
        setMotor(m, dir, m->current_pwm);
    }
    else if (m->current_pwm > pwm){
        for(; m->current_pwm > pwm; m->current_pwm--){
     b74:	8b a5       	ldd	r24, Y+43	; 0x2b
     b76:	81 50       	subi	r24, 0x01	; 1
     b78:	8b a7       	std	Y+43, r24	; 0x2b
     b7a:	de cf       	rjmp	.-68     	; 0xb38 <motorControl+0xf6>
    
   // GTCCR = 0x00;       //Start Counter
}
void disableMotorPWM(volatile motor *m){

    *m->enable_port_addr &= ~(1<<m->enable_pin); //Disable motor => clear enable port
     b7c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b7e:	aa 8d       	ldd	r26, Y+26	; 0x1a
     b80:	bb 8d       	ldd	r27, Y+27	; 0x1b
     b82:	2c 91       	ld	r18, X
     b84:	ba 01       	movw	r22, r20
     b86:	02 c0       	rjmp	.+4      	; 0xb8c <motorControl+0x14a>
     b88:	66 0f       	add	r22, r22
     b8a:	77 1f       	adc	r23, r23
     b8c:	8a 95       	dec	r24
     b8e:	e2 f7       	brpl	.-8      	; 0xb88 <motorControl+0x146>
     b90:	cb 01       	movw	r24, r22
     b92:	80 95       	com	r24
     b94:	90 95       	com	r25
     b96:	82 23       	and	r24, r18
     b98:	8c 93       	st	X, r24
    *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
     b9a:	ad 81       	ldd	r26, Y+5	; 0x05
     b9c:	be 81       	ldd	r27, Y+6	; 0x06
     b9e:	1c 92       	st	X, r1
    *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
     ba0:	a8 85       	ldd	r26, Y+8	; 0x08
     ba2:	b9 85       	ldd	r27, Y+9	; 0x09
     ba4:	1c 92       	st	X, r1
    *m->fwd_OCR_addr = 0x00; //Init PWM to zero
     ba6:	ab 85       	ldd	r26, Y+11	; 0x0b
     ba8:	bc 85       	ldd	r27, Y+12	; 0x0c
     baa:	1c 92       	st	X, r1
    
    //Init reverse PWM settings
    *m->rev_TCCRA_addr = 0x00;//m.rev_TCCRA_value;
     bac:	aa 89       	ldd	r26, Y+18	; 0x12
     bae:	bb 89       	ldd	r27, Y+19	; 0x13
     bb0:	1c 92       	st	X, r1
    *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
     bb2:	ad 89       	ldd	r26, Y+21	; 0x15
     bb4:	be 89       	ldd	r27, Y+22	; 0x16
     bb6:	1c 92       	st	X, r1
    *m->rev_OCR_addr = 0x00; //Init PWM to zero
     bb8:	a8 8d       	ldd	r26, Y+24	; 0x18
     bba:	b9 8d       	ldd	r27, Y+25	; 0x19
     bbc:	1c 92       	st	X, r1
    m->current_pwm = 0; //set PWM to zero
     bbe:	1b a6       	std	Y+43, r1	; 0x2b
    m->timeout_value = 0; //Reset timeout values
     bc0:	11 82       	std	Z+1, r1	; 0x01
     bc2:	10 82       	st	Z, r1
     bc4:	8e cf       	rjmp	.-228    	; 0xae2 <motorControl+0xa0>

void setMotor(volatile motor *m, uint8_t dir, uint8_t pwm){
    m->current_pwm = pwm;
    if (pwm > 0){
        if (dir == FORWARD){ //Forward
            *m->rev_OCR_addr = 0x00; //PWM pulse width
     bc6:	a8 8d       	ldd	r26, Y+24	; 0x18
     bc8:	b9 8d       	ldd	r27, Y+25	; 0x19
     bca:	1c 92       	st	X, r1
            *m->fwd_OCR_addr = pwm; 
     bcc:	ab 85       	ldd	r26, Y+11	; 0x0b
     bce:	bc 85       	ldd	r27, Y+12	; 0x0c
     bd0:	8c 93       	st	X, r24
            *m->rev_port_addr &= ~(1<<m->rev_pin);
     bd2:	89 89       	ldd	r24, Y+17	; 0x11
     bd4:	ad 85       	ldd	r26, Y+13	; 0x0d
     bd6:	be 85       	ldd	r27, Y+14	; 0x0e
     bd8:	2c 91       	ld	r18, X
     bda:	ba 01       	movw	r22, r20
     bdc:	02 c0       	rjmp	.+4      	; 0xbe2 <motorControl+0x1a0>
     bde:	66 0f       	add	r22, r22
     be0:	77 1f       	adc	r23, r23
     be2:	8a 95       	dec	r24
     be4:	e2 f7       	brpl	.-8      	; 0xbde <motorControl+0x19c>
     be6:	cb 01       	movw	r24, r22
     be8:	80 95       	com	r24
     bea:	90 95       	com	r25
     bec:	82 23       	and	r24, r18
     bee:	8c 93       	st	X, r24
            *m->rev_TCCRA_addr = 0x00; //Disable reverse
     bf0:	aa 89       	ldd	r26, Y+18	; 0x12
     bf2:	bb 89       	ldd	r27, Y+19	; 0x13
     bf4:	1c 92       	st	X, r1
            *m->fwd_TCCRA_addr = m->fwd_TCCRA_value; //Activate PWM forward
     bf6:	ad 81       	ldd	r26, Y+5	; 0x05
     bf8:	be 81       	ldd	r27, Y+6	; 0x06
     bfa:	8f 81       	ldd	r24, Y+7	; 0x07
     bfc:	8c 93       	st	X, r24
            
            *m->rev_TCCRB_addr = 0x00; //Disable clock Rev
     bfe:	ad 89       	ldd	r26, Y+21	; 0x15
     c00:	be 89       	ldd	r27, Y+22	; 0x16
     c02:	1c 92       	st	X, r1
            *m->fwd_TCCRB_addr = m->fwd_TCCRB_value;
     c04:	a8 85       	ldd	r26, Y+8	; 0x08
     c06:	b9 85       	ldd	r27, Y+9	; 0x09
     c08:	8a 85       	ldd	r24, Y+10	; 0x0a
     c0a:	8c 93       	st	X, r24
     c0c:	5d cf       	rjmp	.-326    	; 0xac8 <motorControl+0x86>

00000c0e <getActuatorLength>:
        ie. 180 +offset  => 180 + +90 = 270 degrees
    */
}

//returns motor actuator length in millimeters
uint16_t getActuatorLength(volatile motor *m){
     c0e:	a0 e0       	ldi	r26, 0x00	; 0
     c10:	b0 e0       	ldi	r27, 0x00	; 0
     c12:	ed e0       	ldi	r30, 0x0D	; 13
     c14:	f6 e0       	ldi	r31, 0x06	; 6
     c16:	0c 94 a5 1c 	jmp	0x394a	; 0x394a <__prologue_saves__>
     c1a:	ec 01       	movw	r28, r24
    uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
     c1c:	8f 8d       	ldd	r24, Y+31	; 0x1f
     c1e:	44 e0       	ldi	r20, 0x04	; 4
     c20:	60 e4       	ldi	r22, 0x40	; 64
     c22:	c7 db       	rcall	.-2162   	; 0x3b2 <AVGVoltage>
     c24:	6c 01       	movw	r12, r24
     c26:	e1 2c       	mov	r14, r1
     c28:	f1 2c       	mov	r15, r1
    //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
    voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
     c2a:	fe 01       	movw	r30, r28
     c2c:	e1 5a       	subi	r30, 0xA1	; 161
     c2e:	ff 4f       	sbci	r31, 0xFF	; 255
     c30:	20 80       	ld	r2, Z
     c32:	31 80       	ldd	r3, Z+1	; 0x01
//  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
     c34:	73 97       	sbiw	r30, 0x13	; 19
     c36:	60 81       	ld	r22, Z
     c38:	71 81       	ldd	r23, Z+1	; 0x01
     c3a:	34 96       	adiw	r30, 0x04	; 4
     c3c:	40 80       	ld	r4, Z
     c3e:	51 80       	ldd	r5, Z+1	; 0x01
     c40:	62 80       	ldd	r6, Z+2	; 0x02
     c42:	73 80       	ldd	r7, Z+3	; 0x03
     c44:	73 96       	adiw	r30, 0x13	; 19
     c46:	00 81       	ld	r16, Z
     c48:	11 81       	ldd	r17, Z+1	; 0x01
     c4a:	80 e0       	ldi	r24, 0x00	; 0
     c4c:	90 e0       	ldi	r25, 0x00	; 0
     c4e:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
     c52:	4b 01       	movw	r8, r22
     c54:	5c 01       	movw	r10, r24
     c56:	b8 01       	movw	r22, r16
     c58:	80 e0       	ldi	r24, 0x00	; 0
     c5a:	90 e0       	ldi	r25, 0x00	; 0
     c5c:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
     c60:	9b 01       	movw	r18, r22
     c62:	ac 01       	movw	r20, r24
     c64:	c3 01       	movw	r24, r6
     c66:	b2 01       	movw	r22, r4
     c68:	0e 94 41 1a 	call	0x3482	; 0x3482 <__divsf3>
     c6c:	2b 01       	movw	r4, r22
     c6e:	3c 01       	movw	r6, r24

//returns motor actuator length in millimeters
uint16_t getActuatorLength(volatile motor *m){
    uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
    //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
    voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
     c70:	c7 01       	movw	r24, r14
     c72:	b6 01       	movw	r22, r12
     c74:	62 19       	sub	r22, r2
     c76:	73 09       	sbc	r23, r3
     c78:	81 09       	sbc	r24, r1
     c7a:	91 09       	sbc	r25, r1
//  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
     c7c:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
     c80:	9b 01       	movw	r18, r22
     c82:	ac 01       	movw	r20, r24
     c84:	c3 01       	movw	r24, r6
     c86:	b2 01       	movw	r22, r4
     c88:	0e 94 b7 1b 	call	0x376e	; 0x376e <__mulsf3>
     c8c:	9b 01       	movw	r18, r22
     c8e:	ac 01       	movw	r20, r24
     c90:	c5 01       	movw	r24, r10
     c92:	b4 01       	movw	r22, r8
     c94:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     c98:	0e 94 a9 1a 	call	0x3552	; 0x3552 <__fixunssfsi>
     c9c:	6b 01       	movw	r12, r22
     c9e:	7c 01       	movw	r14, r24
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
     ca0:	fe 01       	movw	r30, r28
     ca2:	ea 5a       	subi	r30, 0xAA	; 170
     ca4:	ff 4f       	sbci	r31, 0xFF	; 255
     ca6:	20 81       	ld	r18, Z
     ca8:	31 81       	ldd	r19, Z+1	; 0x01
     caa:	62 17       	cp	r22, r18
     cac:	73 07       	cpc	r23, r19
     cae:	e8 f4       	brcc	.+58     	; 0xcea <getActuatorLength+0xdc>
        m->status = MAX_LIMIT;
        motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
    }
    else if(length <= m->actuator_min_limit){
     cb0:	fe 01       	movw	r30, r28
     cb2:	ec 5a       	subi	r30, 0xAC	; 172
     cb4:	ff 4f       	sbci	r31, 0xFF	; 255
     cb6:	20 81       	ld	r18, Z
     cb8:	31 81       	ldd	r19, Z+1	; 0x01
     cba:	26 17       	cp	r18, r22
     cbc:	37 07       	cpc	r19, r23
     cbe:	38 f4       	brcc	.+14     	; 0xcce <getActuatorLength+0xc0>
        m->status = MIN_LIMIT;
        motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
    }
    return length;
}
     cc0:	c6 01       	movw	r24, r12
     cc2:	cd b7       	in	r28, 0x3d	; 61
     cc4:	de b7       	in	r29, 0x3e	; 62
     cc6:	e2 e1       	ldi	r30, 0x12	; 18
     cc8:	0c 94 c1 1c 	jmp	0x3982	; 0x3982 <__epilogue_restores__>
     ccc:	11 c0       	rjmp	.+34     	; 0xcf0 <motorControlLoop>
    if (length >= m->actuator_max_limit){
        m->status = MAX_LIMIT;
        motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
    }
    else if(length <= m->actuator_min_limit){
        m->status = MIN_LIMIT;
     cce:	38 96       	adiw	r30, 0x08	; 8
     cd0:	84 e0       	ldi	r24, 0x04	; 4
     cd2:	80 83       	st	Z, r24
        motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
     cd4:	6c a5       	ldd	r22, Y+44	; 0x2c
     cd6:	40 e0       	ldi	r20, 0x00	; 0
     cd8:	ce 01       	movw	r24, r28
     cda:	b3 de       	rcall	.-666    	; 0xa42 <motorControl>
    }
    return length;
}
     cdc:	c6 01       	movw	r24, r12
     cde:	cd b7       	in	r28, 0x3d	; 61
     ce0:	de b7       	in	r29, 0x3e	; 62
     ce2:	e2 e1       	ldi	r30, 0x12	; 18
     ce4:	0c 94 c1 1c 	jmp	0x3982	; 0x3982 <__epilogue_restores__>
     ce8:	03 c0       	rjmp	.+6      	; 0xcf0 <motorControlLoop>
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
        m->status = MAX_LIMIT;
     cea:	36 96       	adiw	r30, 0x06	; 6
     cec:	85 e0       	ldi	r24, 0x05	; 5
     cee:	f1 cf       	rjmp	.-30     	; 0xcd2 <getActuatorLength+0xc4>

00000cf0 <motorControlLoop>:
    }
    return status;
}

//This is motorcontrol loop which is called n. times per second.
void motorControlLoop(volatile motor *m){    
     cf0:	a0 e0       	ldi	r26, 0x00	; 0
     cf2:	b0 e0       	ldi	r27, 0x00	; 0
     cf4:	ee e7       	ldi	r30, 0x7E	; 126
     cf6:	f6 e0       	ldi	r31, 0x06	; 6
     cf8:	0c 94 af 1c 	jmp	0x395e	; 0x395e <__prologue_saves__+0x14>
     cfc:	ec 01       	movw	r28, r24
    //Check if we have been running too long
    if (m->timeout_value >= m->timeout_setting){
     cfe:	8c 01       	movw	r16, r24
     d00:	06 5a       	subi	r16, 0xA6	; 166
     d02:	1f 4f       	sbci	r17, 0xFF	; 255
     d04:	f8 01       	movw	r30, r16
     d06:	20 81       	ld	r18, Z
     d08:	31 81       	ldd	r19, Z+1	; 0x01
     d0a:	32 97       	sbiw	r30, 0x02	; 2
     d0c:	80 81       	ld	r24, Z
     d0e:	91 81       	ldd	r25, Z+1	; 0x01
     d10:	28 17       	cp	r18, r24
     d12:	39 07       	cpc	r19, r25
     d14:	08 f0       	brcs	.+2      	; 0xd18 <motorControlLoop+0x28>
     d16:	0e c1       	rjmp	.+540    	; 0xf34 <motorControlLoop+0x244>
        _delay_ms(100);
        return;
    }

    //Set position is higher than current
    if (m->current_position <= (m->set_position - m->angle_hysteresis)){// && m->status != MAX_LIMIT){ //Check that we are not overriding motor
     d18:	cd a4       	ldd	r12, Y+45	; 0x2d
     d1a:	de a4       	ldd	r13, Y+46	; 0x2e
     d1c:	ef a4       	ldd	r14, Y+47	; 0x2f
     d1e:	f8 a8       	ldd	r15, Y+48	; 0x30
     d20:	69 a9       	ldd	r22, Y+49	; 0x31
     d22:	7a a9       	ldd	r23, Y+50	; 0x32
     d24:	8b a9       	ldd	r24, Y+51	; 0x33
     d26:	9c a9       	ldd	r25, Y+52	; 0x34
     d28:	2b ad       	ldd	r18, Y+59	; 0x3b
     d2a:	3c ad       	ldd	r19, Y+60	; 0x3c
     d2c:	4d ad       	ldd	r20, Y+61	; 0x3d
     d2e:	5e ad       	ldd	r21, Y+62	; 0x3e
     d30:	0e 94 b0 19 	call	0x3360	; 0x3360 <__subsf3>
     d34:	9b 01       	movw	r18, r22
     d36:	ac 01       	movw	r20, r24
     d38:	c7 01       	movw	r24, r14
     d3a:	b6 01       	movw	r22, r12
     d3c:	0e 94 3d 1a 	call	0x347a	; 0x347a <__cmpsf2>
     d40:	18 16       	cp	r1, r24
     d42:	0c f0       	brlt	.+2      	; 0xd46 <motorControlLoop+0x56>
     d44:	19 c1       	rjmp	.+562    	; 0xf78 <motorControlLoop+0x288>
        motorControl(m, FORWARD, m->max_pwm);
        m->timeout_value ++; //update timeout variables
        m->status = RUNNING_FORWARD;
      //  fprintf(port, "fw\n");
    }
    else if (m->current_position >= (m->set_position + m->angle_hysteresis)){// && m->status != MIN_LIMIT){
     d46:	cd a4       	ldd	r12, Y+45	; 0x2d
     d48:	de a4       	ldd	r13, Y+46	; 0x2e
     d4a:	ef a4       	ldd	r14, Y+47	; 0x2f
     d4c:	f8 a8       	ldd	r15, Y+48	; 0x30
     d4e:	69 a9       	ldd	r22, Y+49	; 0x31
     d50:	7a a9       	ldd	r23, Y+50	; 0x32
     d52:	8b a9       	ldd	r24, Y+51	; 0x33
     d54:	9c a9       	ldd	r25, Y+52	; 0x34
     d56:	2b ad       	ldd	r18, Y+59	; 0x3b
     d58:	3c ad       	ldd	r19, Y+60	; 0x3c
     d5a:	4d ad       	ldd	r20, Y+61	; 0x3d
     d5c:	5e ad       	ldd	r21, Y+62	; 0x3e
     d5e:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
     d62:	9b 01       	movw	r18, r22
     d64:	ac 01       	movw	r20, r24
     d66:	c7 01       	movw	r24, r14
     d68:	b6 01       	movw	r22, r12
     d6a:	0e 94 ac 1b 	call	0x3758	; 0x3758 <__gesf2>
     d6e:	87 ff       	sbrs	r24, 7
     d70:	17 c1       	rjmp	.+558    	; 0xfa0 <motorControlLoop+0x2b0>
        m->timeout_value ++;
        m->status = RUNNING_BACKWARD;
       // fprintf(port, "rev\n");
    }
    else{ //Motor is close enough wanted position, Shutdown motor
        for(; m->current_pwm > 0; m->current_pwm--){
     d72:	8b a5       	ldd	r24, Y+43	; 0x2b
     d74:	88 23       	and	r24, r24
     d76:	09 f4       	brne	.+2      	; 0xd7a <motorControlLoop+0x8a>
     d78:	58 c0       	rjmp	.+176    	; 0xe2a <motorControlLoop+0x13a>
            *m->rev_TCCRA_addr = m->rev_TCCRA_value;

            *m->fwd_TCCRB_addr = 0x00;
            *m->rev_TCCRB_addr = m->rev_TCCRB_value;
        }        
        *m->enable_port_addr |= 1<<m->enable_pin; 
     d7a:	41 e0       	ldi	r20, 0x01	; 1
     d7c:	50 e0       	ldi	r21, 0x00	; 0
        m->status = RUNNING_BACKWARD;
       // fprintf(port, "rev\n");
    }
    else{ //Motor is close enough wanted position, Shutdown motor
        for(; m->current_pwm > 0; m->current_pwm--){
            setMotor(m, m->current_dir, m->current_pwm);
     d7e:	8b a5       	ldd	r24, Y+43	; 0x2b
     d80:	9c a5       	ldd	r25, Y+44	; 0x2c
} 
//volatile uint8_t *OCRC_ADDR[] = {&OCR1CL, &OCR4AL }
//volatile uint8_t *OCRB_ADDR[] = {&OCR1BL, &OCR4BL }

void setMotor(volatile motor *m, uint8_t dir, uint8_t pwm){
    m->current_pwm = pwm;
     d82:	8b a7       	std	Y+43, r24	; 0x2b
    if (pwm > 0){
     d84:	88 23       	and	r24, r24
     d86:	09 f4       	brne	.+2      	; 0xd8a <motorControlLoop+0x9a>
     d88:	8b c0       	rjmp	.+278    	; 0xea0 <motorControlLoop+0x1b0>
        if (dir == FORWARD){ //Forward
     d8a:	91 30       	cpi	r25, 0x01	; 1
     d8c:	09 f4       	brne	.+2      	; 0xd90 <motorControlLoop+0xa0>
     d8e:	ae c0       	rjmp	.+348    	; 0xeec <motorControlLoop+0x1fc>
            
            *m->rev_TCCRB_addr = 0x00; //Disable clock Rev
            *m->fwd_TCCRB_addr = m->fwd_TCCRB_value;
        }
        else{ //Backward
            *m->fwd_OCR_addr = 0x00;
     d90:	eb 85       	ldd	r30, Y+11	; 0x0b
     d92:	fc 85       	ldd	r31, Y+12	; 0x0c
     d94:	10 82       	st	Z, r1
            *m->rev_OCR_addr = pwm; 
     d96:	e8 8d       	ldd	r30, Y+24	; 0x18
     d98:	f9 8d       	ldd	r31, Y+25	; 0x19
     d9a:	80 83       	st	Z, r24
            *m->fwd_port_addr &= ~(1<<m->fwd_pin);
     d9c:	8c 81       	ldd	r24, Y+4	; 0x04
     d9e:	e8 81       	ld	r30, Y
     da0:	f9 81       	ldd	r31, Y+1	; 0x01
     da2:	20 81       	ld	r18, Z
     da4:	ba 01       	movw	r22, r20
     da6:	02 c0       	rjmp	.+4      	; 0xdac <motorControlLoop+0xbc>
     da8:	66 0f       	add	r22, r22
     daa:	77 1f       	adc	r23, r23
     dac:	8a 95       	dec	r24
     dae:	e2 f7       	brpl	.-8      	; 0xda8 <motorControlLoop+0xb8>
     db0:	cb 01       	movw	r24, r22
     db2:	80 95       	com	r24
     db4:	90 95       	com	r25
     db6:	82 23       	and	r24, r18
     db8:	80 83       	st	Z, r24
            *m->fwd_TCCRA_addr = 0x00; //Disable FWD
     dba:	ed 81       	ldd	r30, Y+5	; 0x05
     dbc:	fe 81       	ldd	r31, Y+6	; 0x06
     dbe:	10 82       	st	Z, r1
            *m->rev_TCCRA_addr = m->rev_TCCRA_value;
     dc0:	ea 89       	ldd	r30, Y+18	; 0x12
     dc2:	fb 89       	ldd	r31, Y+19	; 0x13
     dc4:	8c 89       	ldd	r24, Y+20	; 0x14
     dc6:	80 83       	st	Z, r24

            *m->fwd_TCCRB_addr = 0x00;
     dc8:	e8 85       	ldd	r30, Y+8	; 0x08
     dca:	f9 85       	ldd	r31, Y+9	; 0x09
     dcc:	10 82       	st	Z, r1
            *m->rev_TCCRB_addr = m->rev_TCCRB_value;
     dce:	ed 89       	ldd	r30, Y+21	; 0x15
     dd0:	fe 89       	ldd	r31, Y+22	; 0x16
     dd2:	8f 89       	ldd	r24, Y+23	; 0x17
     dd4:	80 83       	st	Z, r24
        }        
        *m->enable_port_addr |= 1<<m->enable_pin; 
     dd6:	8e 8d       	ldd	r24, Y+30	; 0x1e
     dd8:	ea 8d       	ldd	r30, Y+26	; 0x1a
     dda:	fb 8d       	ldd	r31, Y+27	; 0x1b
     ddc:	20 81       	ld	r18, Z
     dde:	ba 01       	movw	r22, r20
     de0:	02 c0       	rjmp	.+4      	; 0xde6 <motorControlLoop+0xf6>
     de2:	66 0f       	add	r22, r22
     de4:	77 1f       	adc	r23, r23
     de6:	8a 95       	dec	r24
     de8:	e2 f7       	brpl	.-8      	; 0xde2 <motorControlLoop+0xf2>
     dea:	cb 01       	movw	r24, r22
     dec:	82 2b       	or	r24, r18
     dee:	80 83       	st	Z, r24
       // fprintf(port, "rev\n");
    }
    else{ //Motor is close enough wanted position, Shutdown motor
        for(; m->current_pwm > 0; m->current_pwm--){
            setMotor(m, m->current_dir, m->current_pwm);
            delayLoop_us(m->deacceleration_time);
     df0:	29 ad       	ldd	r18, Y+57	; 0x39
     df2:	3a ad       	ldd	r19, Y+58	; 0x3a
        _delay_ms(50);
    }
}

void delayLoop_us(uint16_t delay){
    for (uint16_t i = 0; i < delay/50; i++){
     df4:	36 95       	lsr	r19
     df6:	27 95       	ror	r18
     df8:	ab e7       	ldi	r26, 0x7B	; 123
     dfa:	b4 e1       	ldi	r27, 0x14	; 20
     dfc:	0e 94 96 1c 	call	0x392c	; 0x392c <__umulhisi3>
     e00:	96 95       	lsr	r25
     e02:	87 95       	ror	r24
     e04:	00 97       	sbiw	r24, 0x00	; 0
     e06:	59 f0       	breq	.+22     	; 0xe1e <motorControlLoop+0x12e>
     e08:	20 e0       	ldi	r18, 0x00	; 0
     e0a:	30 e0       	ldi	r19, 0x00	; 0
     e0c:	fa ef       	ldi	r31, 0xFA	; 250
     e0e:	fa 95       	dec	r31
     e10:	f1 f7       	brne	.-4      	; 0xe0e <motorControlLoop+0x11e>
     e12:	00 c0       	rjmp	.+0      	; 0xe14 <motorControlLoop+0x124>
     e14:	2f 5f       	subi	r18, 0xFF	; 255
     e16:	3f 4f       	sbci	r19, 0xFF	; 255
     e18:	28 17       	cp	r18, r24
     e1a:	39 07       	cpc	r19, r25
     e1c:	b9 f7       	brne	.-18     	; 0xe0c <motorControlLoop+0x11c>
        m->timeout_value ++;
        m->status = RUNNING_BACKWARD;
       // fprintf(port, "rev\n");
    }
    else{ //Motor is close enough wanted position, Shutdown motor
        for(; m->current_pwm > 0; m->current_pwm--){
     e1e:	8b a5       	ldd	r24, Y+43	; 0x2b
     e20:	81 50       	subi	r24, 0x01	; 1
     e22:	8b a7       	std	Y+43, r24	; 0x2b
     e24:	8b a5       	ldd	r24, Y+43	; 0x2b
     e26:	81 11       	cpse	r24, r1
     e28:	aa cf       	rjmp	.-172    	; 0xd7e <motorControlLoop+0x8e>
            setMotor(m, m->current_dir, m->current_pwm);
            delayLoop_us(m->deacceleration_time);
        }
        //setMotor(m, m->current_dir, 0);
        m->timeout_value = 0; //Clear timeout
     e2a:	f8 01       	movw	r30, r16
     e2c:	11 82       	std	Z+1, r1	; 0x01
     e2e:	10 82       	st	Z, r1
        m->status = STATUS_OK;
     e30:	fe 01       	movw	r30, r28
     e32:	e4 5a       	subi	r30, 0xA4	; 164
     e34:	ff 4f       	sbci	r31, 0xFF	; 255
     e36:	10 82       	st	Z, r1
    
   // GTCCR = 0x00;       //Start Counter
}
void disableMotorPWM(volatile motor *m){

    *m->enable_port_addr &= ~(1<<m->enable_pin); //Disable motor => clear enable port
     e38:	3e 8d       	ldd	r19, Y+30	; 0x1e
     e3a:	ea 8d       	ldd	r30, Y+26	; 0x1a
     e3c:	fb 8d       	ldd	r31, Y+27	; 0x1b
     e3e:	20 81       	ld	r18, Z
     e40:	81 e0       	ldi	r24, 0x01	; 1
     e42:	90 e0       	ldi	r25, 0x00	; 0
     e44:	02 c0       	rjmp	.+4      	; 0xe4a <motorControlLoop+0x15a>
     e46:	88 0f       	add	r24, r24
     e48:	99 1f       	adc	r25, r25
     e4a:	3a 95       	dec	r19
     e4c:	e2 f7       	brpl	.-8      	; 0xe46 <motorControlLoop+0x156>
     e4e:	80 95       	com	r24
     e50:	90 95       	com	r25
     e52:	82 23       	and	r24, r18
     e54:	80 83       	st	Z, r24
    *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
     e56:	ed 81       	ldd	r30, Y+5	; 0x05
     e58:	fe 81       	ldd	r31, Y+6	; 0x06
     e5a:	10 82       	st	Z, r1
    *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
     e5c:	e8 85       	ldd	r30, Y+8	; 0x08
     e5e:	f9 85       	ldd	r31, Y+9	; 0x09
     e60:	10 82       	st	Z, r1
    *m->fwd_OCR_addr = 0x00; //Init PWM to zero
     e62:	eb 85       	ldd	r30, Y+11	; 0x0b
     e64:	fc 85       	ldd	r31, Y+12	; 0x0c
     e66:	10 82       	st	Z, r1
    
    //Init reverse PWM settings
    *m->rev_TCCRA_addr = 0x00;//m.rev_TCCRA_value;
     e68:	ea 89       	ldd	r30, Y+18	; 0x12
     e6a:	fb 89       	ldd	r31, Y+19	; 0x13
     e6c:	10 82       	st	Z, r1
    *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
     e6e:	ed 89       	ldd	r30, Y+21	; 0x15
     e70:	fe 89       	ldd	r31, Y+22	; 0x16
     e72:	10 82       	st	Z, r1
    *m->rev_OCR_addr = 0x00; //Init PWM to zero
     e74:	e8 8d       	ldd	r30, Y+24	; 0x18
     e76:	f9 8d       	ldd	r31, Y+25	; 0x19
     e78:	10 82       	st	Z, r1
    m->current_pwm = 0; //set PWM to zero
     e7a:	1b a6       	std	Y+43, r1	; 0x2b
    m->timeout_value = 0; //Reset timeout values
     e7c:	f8 01       	movw	r30, r16
     e7e:	11 82       	std	Z+1, r1	; 0x01
     e80:	10 82       	st	Z, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     e82:	ff ef       	ldi	r31, 0xFF	; 255
     e84:	20 e7       	ldi	r18, 0x70	; 112
     e86:	62 e0       	ldi	r22, 0x02	; 2
     e88:	f1 50       	subi	r31, 0x01	; 1
     e8a:	20 40       	sbci	r18, 0x00	; 0
     e8c:	60 40       	sbci	r22, 0x00	; 0
     e8e:	e1 f7       	brne	.-8      	; 0xe88 <motorControlLoop+0x198>
     e90:	00 c0       	rjmp	.+0      	; 0xe92 <motorControlLoop+0x1a2>
     e92:	00 00       	nop
        m->timeout_value = 0; //Clear timeout
        m->status = STATUS_OK;
        disableMotorPWM(m);       
        _delay_ms(50);
    }
}
     e94:	cd b7       	in	r28, 0x3d	; 61
     e96:	de b7       	in	r29, 0x3e	; 62
     e98:	e8 e0       	ldi	r30, 0x08	; 8
     e9a:	0c 94 cb 1c 	jmp	0x3996	; 0x3996 <__epilogue_restores__+0x14>
     e9e:	93 c0       	rjmp	.+294    	; 0xfc6 <getTiltActuatorCurrentLength>
    
   // GTCCR = 0x00;       //Start Counter
}
void disableMotorPWM(volatile motor *m){

    *m->enable_port_addr &= ~(1<<m->enable_pin); //Disable motor => clear enable port
     ea0:	8e 8d       	ldd	r24, Y+30	; 0x1e
     ea2:	ea 8d       	ldd	r30, Y+26	; 0x1a
     ea4:	fb 8d       	ldd	r31, Y+27	; 0x1b
     ea6:	20 81       	ld	r18, Z
     ea8:	ba 01       	movw	r22, r20
     eaa:	02 c0       	rjmp	.+4      	; 0xeb0 <motorControlLoop+0x1c0>
     eac:	66 0f       	add	r22, r22
     eae:	77 1f       	adc	r23, r23
     eb0:	8a 95       	dec	r24
     eb2:	e2 f7       	brpl	.-8      	; 0xeac <motorControlLoop+0x1bc>
     eb4:	cb 01       	movw	r24, r22
     eb6:	80 95       	com	r24
     eb8:	90 95       	com	r25
     eba:	82 23       	and	r24, r18
     ebc:	80 83       	st	Z, r24
    *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
     ebe:	ed 81       	ldd	r30, Y+5	; 0x05
     ec0:	fe 81       	ldd	r31, Y+6	; 0x06
     ec2:	10 82       	st	Z, r1
    *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
     ec4:	e8 85       	ldd	r30, Y+8	; 0x08
     ec6:	f9 85       	ldd	r31, Y+9	; 0x09
     ec8:	10 82       	st	Z, r1
    *m->fwd_OCR_addr = 0x00; //Init PWM to zero
     eca:	eb 85       	ldd	r30, Y+11	; 0x0b
     ecc:	fc 85       	ldd	r31, Y+12	; 0x0c
     ece:	10 82       	st	Z, r1
    
    //Init reverse PWM settings
    *m->rev_TCCRA_addr = 0x00;//m.rev_TCCRA_value;
     ed0:	ea 89       	ldd	r30, Y+18	; 0x12
     ed2:	fb 89       	ldd	r31, Y+19	; 0x13
     ed4:	10 82       	st	Z, r1
    *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
     ed6:	ed 89       	ldd	r30, Y+21	; 0x15
     ed8:	fe 89       	ldd	r31, Y+22	; 0x16
     eda:	10 82       	st	Z, r1
    *m->rev_OCR_addr = 0x00; //Init PWM to zero
     edc:	e8 8d       	ldd	r30, Y+24	; 0x18
     ede:	f9 8d       	ldd	r31, Y+25	; 0x19
     ee0:	10 82       	st	Z, r1
    m->current_pwm = 0; //set PWM to zero
     ee2:	1b a6       	std	Y+43, r1	; 0x2b
    m->timeout_value = 0; //Reset timeout values
     ee4:	f8 01       	movw	r30, r16
     ee6:	11 82       	std	Z+1, r1	; 0x01
     ee8:	10 82       	st	Z, r1
     eea:	82 cf       	rjmp	.-252    	; 0xdf0 <motorControlLoop+0x100>

void setMotor(volatile motor *m, uint8_t dir, uint8_t pwm){
    m->current_pwm = pwm;
    if (pwm > 0){
        if (dir == FORWARD){ //Forward
            *m->rev_OCR_addr = 0x00; //PWM pulse width
     eec:	e8 8d       	ldd	r30, Y+24	; 0x18
     eee:	f9 8d       	ldd	r31, Y+25	; 0x19
     ef0:	10 82       	st	Z, r1
            *m->fwd_OCR_addr = pwm; 
     ef2:	eb 85       	ldd	r30, Y+11	; 0x0b
     ef4:	fc 85       	ldd	r31, Y+12	; 0x0c
     ef6:	80 83       	st	Z, r24
            *m->rev_port_addr &= ~(1<<m->rev_pin);
     ef8:	89 89       	ldd	r24, Y+17	; 0x11
     efa:	ed 85       	ldd	r30, Y+13	; 0x0d
     efc:	fe 85       	ldd	r31, Y+14	; 0x0e
     efe:	20 81       	ld	r18, Z
     f00:	ba 01       	movw	r22, r20
     f02:	02 c0       	rjmp	.+4      	; 0xf08 <motorControlLoop+0x218>
     f04:	66 0f       	add	r22, r22
     f06:	77 1f       	adc	r23, r23
     f08:	8a 95       	dec	r24
     f0a:	e2 f7       	brpl	.-8      	; 0xf04 <motorControlLoop+0x214>
     f0c:	cb 01       	movw	r24, r22
     f0e:	80 95       	com	r24
     f10:	90 95       	com	r25
     f12:	82 23       	and	r24, r18
     f14:	80 83       	st	Z, r24
            *m->rev_TCCRA_addr = 0x00; //Disable reverse
     f16:	ea 89       	ldd	r30, Y+18	; 0x12
     f18:	fb 89       	ldd	r31, Y+19	; 0x13
     f1a:	10 82       	st	Z, r1
            *m->fwd_TCCRA_addr = m->fwd_TCCRA_value; //Activate PWM forward
     f1c:	ed 81       	ldd	r30, Y+5	; 0x05
     f1e:	fe 81       	ldd	r31, Y+6	; 0x06
     f20:	8f 81       	ldd	r24, Y+7	; 0x07
     f22:	80 83       	st	Z, r24
            
            *m->rev_TCCRB_addr = 0x00; //Disable clock Rev
     f24:	ed 89       	ldd	r30, Y+21	; 0x15
     f26:	fe 89       	ldd	r31, Y+22	; 0x16
     f28:	10 82       	st	Z, r1
            *m->fwd_TCCRB_addr = m->fwd_TCCRB_value;
     f2a:	e8 85       	ldd	r30, Y+8	; 0x08
     f2c:	f9 85       	ldd	r31, Y+9	; 0x09
     f2e:	8a 85       	ldd	r24, Y+10	; 0x0a
     f30:	80 83       	st	Z, r24
     f32:	51 cf       	rjmp	.-350    	; 0xdd6 <motorControlLoop+0xe6>

//This is motorcontrol loop which is called n. times per second.
void motorControlLoop(volatile motor *m){    
    //Check if we have been running too long
    if (m->timeout_value >= m->timeout_setting){
        m->status = TIMEOUT_ERROR;
     f34:	34 96       	adiw	r30, 0x04	; 4
     f36:	83 e0       	ldi	r24, 0x03	; 3
     f38:	80 83       	st	Z, r24
        fprintf(port, "timeout\n");
     f3a:	20 91 dc 02 	lds	r18, 0x02DC	; 0x8002dc <port>
     f3e:	30 91 dd 02 	lds	r19, 0x02DD	; 0x8002dd <port+0x1>
     f42:	48 e0       	ldi	r20, 0x08	; 8
     f44:	50 e0       	ldi	r21, 0x00	; 0
     f46:	61 e0       	ldi	r22, 0x01	; 1
     f48:	70 e0       	ldi	r23, 0x00	; 0
     f4a:	87 e6       	ldi	r24, 0x67	; 103
     f4c:	92 e0       	ldi	r25, 0x02	; 2
     f4e:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <fwrite>
        motorControl(m, m->current_dir, 0); //Shutdown motor if it has been running too long.
     f52:	6c a5       	ldd	r22, Y+44	; 0x2c
     f54:	40 e0       	ldi	r20, 0x00	; 0
     f56:	ce 01       	movw	r24, r28
     f58:	74 dd       	rcall	.-1304   	; 0xa42 <motorControl>
     f5a:	ff ef       	ldi	r31, 0xFF	; 255
     f5c:	21 ee       	ldi	r18, 0xE1	; 225
     f5e:	64 e0       	ldi	r22, 0x04	; 4
     f60:	f1 50       	subi	r31, 0x01	; 1
     f62:	20 40       	sbci	r18, 0x00	; 0
     f64:	60 40       	sbci	r22, 0x00	; 0
     f66:	e1 f7       	brne	.-8      	; 0xf60 <motorControlLoop+0x270>
     f68:	00 c0       	rjmp	.+0      	; 0xf6a <motorControlLoop+0x27a>
     f6a:	00 00       	nop
        m->timeout_value = 0; //Clear timeout
        m->status = STATUS_OK;
        disableMotorPWM(m);       
        _delay_ms(50);
    }
}
     f6c:	cd b7       	in	r28, 0x3d	; 61
     f6e:	de b7       	in	r29, 0x3e	; 62
     f70:	e8 e0       	ldi	r30, 0x08	; 8
     f72:	0c 94 cb 1c 	jmp	0x3996	; 0x3996 <__epilogue_restores__+0x14>
     f76:	27 c0       	rjmp	.+78     	; 0xfc6 <getTiltActuatorCurrentLength>
        return;
    }

    //Set position is higher than current
    if (m->current_position <= (m->set_position - m->angle_hysteresis)){// && m->status != MAX_LIMIT){ //Check that we are not overriding motor
        motorControl(m, FORWARD, m->max_pwm);
     f78:	4f ad       	ldd	r20, Y+63	; 0x3f
     f7a:	61 e0       	ldi	r22, 0x01	; 1
     f7c:	ce 01       	movw	r24, r28
     f7e:	61 dd       	rcall	.-1342   	; 0xa42 <motorControl>
        m->timeout_value ++; //update timeout variables
     f80:	f8 01       	movw	r30, r16
     f82:	80 81       	ld	r24, Z
     f84:	91 81       	ldd	r25, Z+1	; 0x01
     f86:	01 96       	adiw	r24, 0x01	; 1
     f88:	91 83       	std	Z+1, r25	; 0x01
     f8a:	80 83       	st	Z, r24
        m->status = RUNNING_FORWARD;
     f8c:	c4 5a       	subi	r28, 0xA4	; 164
     f8e:	df 4f       	sbci	r29, 0xFF	; 255
     f90:	81 e0       	ldi	r24, 0x01	; 1
     f92:	88 83       	st	Y, r24
        m->timeout_value = 0; //Clear timeout
        m->status = STATUS_OK;
        disableMotorPWM(m);       
        _delay_ms(50);
    }
}
     f94:	cd b7       	in	r28, 0x3d	; 61
     f96:	de b7       	in	r29, 0x3e	; 62
     f98:	e8 e0       	ldi	r30, 0x08	; 8
     f9a:	0c 94 cb 1c 	jmp	0x3996	; 0x3996 <__epilogue_restores__+0x14>
     f9e:	13 c0       	rjmp	.+38     	; 0xfc6 <getTiltActuatorCurrentLength>
        m->timeout_value ++; //update timeout variables
        m->status = RUNNING_FORWARD;
      //  fprintf(port, "fw\n");
    }
    else if (m->current_position >= (m->set_position + m->angle_hysteresis)){// && m->status != MIN_LIMIT){
        motorControl(m, BACKWARD, m->max_pwm);
     fa0:	4f ad       	ldd	r20, Y+63	; 0x3f
     fa2:	60 e0       	ldi	r22, 0x00	; 0
     fa4:	ce 01       	movw	r24, r28
     fa6:	4d dd       	rcall	.-1382   	; 0xa42 <motorControl>
        m->timeout_value ++;
     fa8:	f8 01       	movw	r30, r16
     faa:	80 81       	ld	r24, Z
     fac:	91 81       	ldd	r25, Z+1	; 0x01
     fae:	01 96       	adiw	r24, 0x01	; 1
     fb0:	91 83       	std	Z+1, r25	; 0x01
     fb2:	80 83       	st	Z, r24
        m->status = RUNNING_BACKWARD;
     fb4:	c4 5a       	subi	r28, 0xA4	; 164
     fb6:	df 4f       	sbci	r29, 0xFF	; 255
     fb8:	82 e0       	ldi	r24, 0x02	; 2
     fba:	88 83       	st	Y, r24
        m->timeout_value = 0; //Clear timeout
        m->status = STATUS_OK;
        disableMotorPWM(m);       
        _delay_ms(50);
    }
}
     fbc:	cd b7       	in	r28, 0x3d	; 61
     fbe:	de b7       	in	r29, 0x3e	; 62
     fc0:	e8 e0       	ldi	r30, 0x08	; 8
     fc2:	0c 94 cb 1c 	jmp	0x3996	; 0x3996 <__epilogue_restores__+0x14>

00000fc6 <getTiltActuatorCurrentLength>:
        motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
    }
    return length;
}

uint16_t getTiltActuatorCurrentLength(void){
     fc6:	a0 e0       	ldi	r26, 0x00	; 0
     fc8:	b0 e0       	ldi	r27, 0x00	; 0
     fca:	e9 ee       	ldi	r30, 0xE9	; 233
     fcc:	f7 e0       	ldi	r31, 0x07	; 7
     fce:	0c 94 a7 1c 	jmp	0x394e	; 0x394e <__prologue_saves__+0x4>
    */
}

//returns motor actuator length in millimeters
uint16_t getActuatorLength(volatile motor *m){
    uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
     fd2:	80 91 92 01 	lds	r24, 0x0192	; 0x800192 <motors+0x84>
     fd6:	44 e0       	ldi	r20, 0x04	; 4
     fd8:	60 e4       	ldi	r22, 0x40	; 64
     fda:	eb d9       	rcall	.-3114   	; 0x3b2 <AVGVoltage>
     fdc:	6c 01       	movw	r12, r24
     fde:	e1 2c       	mov	r14, r1
     fe0:	f1 2c       	mov	r15, r1
    //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
    voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
     fe2:	c0 91 d2 01 	lds	r28, 0x01D2	; 0x8001d2 <motors+0xc4>
     fe6:	d0 91 d3 01 	lds	r29, 0x01D3	; 0x8001d3 <motors+0xc5>
//  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
     fea:	60 91 bf 01 	lds	r22, 0x01BF	; 0x8001bf <motors+0xb1>
     fee:	70 91 c0 01 	lds	r23, 0x01C0	; 0x8001c0 <motors+0xb2>
     ff2:	40 90 c3 01 	lds	r4, 0x01C3	; 0x8001c3 <motors+0xb5>
     ff6:	50 90 c4 01 	lds	r5, 0x01C4	; 0x8001c4 <motors+0xb6>
     ffa:	60 90 c5 01 	lds	r6, 0x01C5	; 0x8001c5 <motors+0xb7>
     ffe:	70 90 c6 01 	lds	r7, 0x01C6	; 0x8001c6 <motors+0xb8>
    1002:	00 91 d6 01 	lds	r16, 0x01D6	; 0x8001d6 <motors+0xc8>
    1006:	10 91 d7 01 	lds	r17, 0x01D7	; 0x8001d7 <motors+0xc9>
    100a:	80 e0       	ldi	r24, 0x00	; 0
    100c:	90 e0       	ldi	r25, 0x00	; 0
    100e:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    1012:	4b 01       	movw	r8, r22
    1014:	5c 01       	movw	r10, r24
    1016:	b8 01       	movw	r22, r16
    1018:	80 e0       	ldi	r24, 0x00	; 0
    101a:	90 e0       	ldi	r25, 0x00	; 0
    101c:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    1020:	9b 01       	movw	r18, r22
    1022:	ac 01       	movw	r20, r24
    1024:	c3 01       	movw	r24, r6
    1026:	b2 01       	movw	r22, r4
    1028:	0e 94 41 1a 	call	0x3482	; 0x3482 <__divsf3>
    102c:	2b 01       	movw	r4, r22
    102e:	3c 01       	movw	r6, r24

//returns motor actuator length in millimeters
uint16_t getActuatorLength(volatile motor *m){
    uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
    //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
    voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
    1030:	c7 01       	movw	r24, r14
    1032:	b6 01       	movw	r22, r12
    1034:	6c 1b       	sub	r22, r28
    1036:	7d 0b       	sbc	r23, r29
    1038:	81 09       	sbc	r24, r1
    103a:	91 09       	sbc	r25, r1
//  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
    103c:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    1040:	9b 01       	movw	r18, r22
    1042:	ac 01       	movw	r20, r24
    1044:	c3 01       	movw	r24, r6
    1046:	b2 01       	movw	r22, r4
    1048:	0e 94 b7 1b 	call	0x376e	; 0x376e <__mulsf3>
    104c:	9b 01       	movw	r18, r22
    104e:	ac 01       	movw	r20, r24
    1050:	c5 01       	movw	r24, r10
    1052:	b4 01       	movw	r22, r8
    1054:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
    1058:	0e 94 a9 1a 	call	0x3552	; 0x3552 <__fixunssfsi>
    105c:	6b 01       	movw	r12, r22
    105e:	7c 01       	movw	r14, r24
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
    1060:	20 91 c9 01 	lds	r18, 0x01C9	; 0x8001c9 <motors+0xbb>
    1064:	30 91 ca 01 	lds	r19, 0x01CA	; 0x8001ca <motors+0xbc>
    1068:	62 17       	cp	r22, r18
    106a:	73 07       	cpc	r23, r19
    106c:	f0 f4       	brcc	.+60     	; 0x10aa <getTiltActuatorCurrentLength+0xe4>
        m->status = MAX_LIMIT;
        motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
    }
    else if(length <= m->actuator_min_limit){
    106e:	20 91 c7 01 	lds	r18, 0x01C7	; 0x8001c7 <motors+0xb9>
    1072:	30 91 c8 01 	lds	r19, 0x01C8	; 0x8001c8 <motors+0xba>
    1076:	26 17       	cp	r18, r22
    1078:	37 07       	cpc	r19, r23
    107a:	38 f4       	brcc	.+14     	; 0x108a <getTiltActuatorCurrentLength+0xc4>
    return length;
}

uint16_t getTiltActuatorCurrentLength(void){
    return getActuatorLength(&motors[TILT_MOTOR]);
}
    107c:	c6 01       	movw	r24, r12
    107e:	cd b7       	in	r28, 0x3d	; 61
    1080:	de b7       	in	r29, 0x3e	; 62
    1082:	e0 e1       	ldi	r30, 0x10	; 16
    1084:	0c 94 c3 1c 	jmp	0x3986	; 0x3986 <__epilogue_restores__+0x4>
    1088:	12 c0       	rjmp	.+36     	; 0x10ae <getAngleActuatorCurrentLength>
    if (length >= m->actuator_max_limit){
        m->status = MAX_LIMIT;
        motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
    }
    else if(length <= m->actuator_min_limit){
        m->status = MIN_LIMIT;
    108a:	84 e0       	ldi	r24, 0x04	; 4
    108c:	80 93 cf 01 	sts	0x01CF, r24	; 0x8001cf <motors+0xc1>
        motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
    1090:	60 91 9f 01 	lds	r22, 0x019F	; 0x80019f <motors+0x91>
    1094:	40 e0       	ldi	r20, 0x00	; 0
    1096:	83 e7       	ldi	r24, 0x73	; 115
    1098:	91 e0       	ldi	r25, 0x01	; 1
    109a:	d3 dc       	rcall	.-1626   	; 0xa42 <motorControl>
    return length;
}

uint16_t getTiltActuatorCurrentLength(void){
    return getActuatorLength(&motors[TILT_MOTOR]);
}
    109c:	c6 01       	movw	r24, r12
    109e:	cd b7       	in	r28, 0x3d	; 61
    10a0:	de b7       	in	r29, 0x3e	; 62
    10a2:	e0 e1       	ldi	r30, 0x10	; 16
    10a4:	0c 94 c3 1c 	jmp	0x3986	; 0x3986 <__epilogue_restores__+0x4>
    10a8:	02 c0       	rjmp	.+4      	; 0x10ae <getAngleActuatorCurrentLength>
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
        m->status = MAX_LIMIT;
    10aa:	85 e0       	ldi	r24, 0x05	; 5
    10ac:	ef cf       	rjmp	.-34     	; 0x108c <getTiltActuatorCurrentLength+0xc6>

000010ae <getAngleActuatorCurrentLength>:

uint16_t getTiltActuatorCurrentLength(void){
    return getActuatorLength(&motors[TILT_MOTOR]);
}

uint16_t getAngleActuatorCurrentLength(void){
    10ae:	a0 e0       	ldi	r26, 0x00	; 0
    10b0:	b0 e0       	ldi	r27, 0x00	; 0
    10b2:	ed e5       	ldi	r30, 0x5D	; 93
    10b4:	f8 e0       	ldi	r31, 0x08	; 8
    10b6:	0c 94 a7 1c 	jmp	0x394e	; 0x394e <__prologue_saves__+0x4>
    */
}

//returns motor actuator length in millimeters
uint16_t getActuatorLength(volatile motor *m){
    uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
    10ba:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <motors+0x1f>
    10be:	44 e0       	ldi	r20, 0x04	; 4
    10c0:	60 e4       	ldi	r22, 0x40	; 64
    10c2:	77 d9       	rcall	.-3346   	; 0x3b2 <AVGVoltage>
    10c4:	6c 01       	movw	r12, r24
    10c6:	e1 2c       	mov	r14, r1
    10c8:	f1 2c       	mov	r15, r1
    //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
    voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
    10ca:	c0 91 6d 01 	lds	r28, 0x016D	; 0x80016d <motors+0x5f>
    10ce:	d0 91 6e 01 	lds	r29, 0x016E	; 0x80016e <motors+0x60>
//  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
    10d2:	60 91 5a 01 	lds	r22, 0x015A	; 0x80015a <motors+0x4c>
    10d6:	70 91 5b 01 	lds	r23, 0x015B	; 0x80015b <motors+0x4d>
    10da:	40 90 5e 01 	lds	r4, 0x015E	; 0x80015e <motors+0x50>
    10de:	50 90 5f 01 	lds	r5, 0x015F	; 0x80015f <motors+0x51>
    10e2:	60 90 60 01 	lds	r6, 0x0160	; 0x800160 <motors+0x52>
    10e6:	70 90 61 01 	lds	r7, 0x0161	; 0x800161 <motors+0x53>
    10ea:	00 91 71 01 	lds	r16, 0x0171	; 0x800171 <motors+0x63>
    10ee:	10 91 72 01 	lds	r17, 0x0172	; 0x800172 <motors+0x64>
    10f2:	80 e0       	ldi	r24, 0x00	; 0
    10f4:	90 e0       	ldi	r25, 0x00	; 0
    10f6:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    10fa:	4b 01       	movw	r8, r22
    10fc:	5c 01       	movw	r10, r24
    10fe:	b8 01       	movw	r22, r16
    1100:	80 e0       	ldi	r24, 0x00	; 0
    1102:	90 e0       	ldi	r25, 0x00	; 0
    1104:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    1108:	9b 01       	movw	r18, r22
    110a:	ac 01       	movw	r20, r24
    110c:	c3 01       	movw	r24, r6
    110e:	b2 01       	movw	r22, r4
    1110:	0e 94 41 1a 	call	0x3482	; 0x3482 <__divsf3>
    1114:	2b 01       	movw	r4, r22
    1116:	3c 01       	movw	r6, r24

//returns motor actuator length in millimeters
uint16_t getActuatorLength(volatile motor *m){
    uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
    //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
    voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
    1118:	c7 01       	movw	r24, r14
    111a:	b6 01       	movw	r22, r12
    111c:	6c 1b       	sub	r22, r28
    111e:	7d 0b       	sbc	r23, r29
    1120:	81 09       	sbc	r24, r1
    1122:	91 09       	sbc	r25, r1
//  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
    1124:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    1128:	9b 01       	movw	r18, r22
    112a:	ac 01       	movw	r20, r24
    112c:	c3 01       	movw	r24, r6
    112e:	b2 01       	movw	r22, r4
    1130:	0e 94 b7 1b 	call	0x376e	; 0x376e <__mulsf3>
    1134:	9b 01       	movw	r18, r22
    1136:	ac 01       	movw	r20, r24
    1138:	c5 01       	movw	r24, r10
    113a:	b4 01       	movw	r22, r8
    113c:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
    1140:	0e 94 a9 1a 	call	0x3552	; 0x3552 <__fixunssfsi>
    1144:	6b 01       	movw	r12, r22
    1146:	7c 01       	movw	r14, r24
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
    1148:	20 91 64 01 	lds	r18, 0x0164	; 0x800164 <motors+0x56>
    114c:	30 91 65 01 	lds	r19, 0x0165	; 0x800165 <motors+0x57>
    1150:	62 17       	cp	r22, r18
    1152:	73 07       	cpc	r23, r19
    1154:	f0 f4       	brcc	.+60     	; 0x1192 <getAngleActuatorCurrentLength+0xe4>
        m->status = MAX_LIMIT;
        motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
    }
    else if(length <= m->actuator_min_limit){
    1156:	20 91 62 01 	lds	r18, 0x0162	; 0x800162 <motors+0x54>
    115a:	30 91 63 01 	lds	r19, 0x0163	; 0x800163 <motors+0x55>
    115e:	26 17       	cp	r18, r22
    1160:	37 07       	cpc	r19, r23
    1162:	38 f4       	brcc	.+14     	; 0x1172 <getAngleActuatorCurrentLength+0xc4>
    return getActuatorLength(&motors[TILT_MOTOR]);
}

uint16_t getAngleActuatorCurrentLength(void){
    return getActuatorLength(&motors[ANGLE_MOTOR]);
}
    1164:	c6 01       	movw	r24, r12
    1166:	cd b7       	in	r28, 0x3d	; 61
    1168:	de b7       	in	r29, 0x3e	; 62
    116a:	e0 e1       	ldi	r30, 0x10	; 16
    116c:	0c 94 c3 1c 	jmp	0x3986	; 0x3986 <__epilogue_restores__+0x4>
    1170:	12 c0       	rjmp	.+36     	; 0x1196 <getMotorPosition>
    if (length >= m->actuator_max_limit){
        m->status = MAX_LIMIT;
        motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
    }
    else if(length <= m->actuator_min_limit){
        m->status = MIN_LIMIT;
    1172:	84 e0       	ldi	r24, 0x04	; 4
    1174:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <motors+0x5c>
        motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
    1178:	60 91 3a 01 	lds	r22, 0x013A	; 0x80013a <motors+0x2c>
    117c:	40 e0       	ldi	r20, 0x00	; 0
    117e:	8e e0       	ldi	r24, 0x0E	; 14
    1180:	91 e0       	ldi	r25, 0x01	; 1
    1182:	5f dc       	rcall	.-1858   	; 0xa42 <motorControl>
    return getActuatorLength(&motors[TILT_MOTOR]);
}

uint16_t getAngleActuatorCurrentLength(void){
    return getActuatorLength(&motors[ANGLE_MOTOR]);
}
    1184:	c6 01       	movw	r24, r12
    1186:	cd b7       	in	r28, 0x3d	; 61
    1188:	de b7       	in	r29, 0x3e	; 62
    118a:	e0 e1       	ldi	r30, 0x10	; 16
    118c:	0c 94 c3 1c 	jmp	0x3986	; 0x3986 <__epilogue_restores__+0x4>
    1190:	02 c0       	rjmp	.+4      	; 0x1196 <getMotorPosition>
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
        m->status = MAX_LIMIT;
    1192:	85 e0       	ldi	r24, 0x05	; 5
    1194:	ef cf       	rjmp	.-34     	; 0x1174 <getAngleActuatorCurrentLength+0xc6>

00001196 <getMotorPosition>:
//Initialize MOTOR A, Angle motor
//volatile motor motors[NUM_OF_MOTORS];
//extern motor motors[NUM_OF_MOTORS];

//returns motor final calculated position in degrees
float getMotorPosition(volatile motor *m){
    1196:	a0 e0       	ldi	r26, 0x00	; 0
    1198:	b0 e0       	ldi	r27, 0x00	; 0
    119a:	e1 ed       	ldi	r30, 0xD1	; 209
    119c:	f8 e0       	ldi	r31, 0x08	; 8
    119e:	0c 94 a5 1c 	jmp	0x394a	; 0x394a <__prologue_saves__>
    11a2:	ec 01       	movw	r28, r24
    */
}

//returns motor actuator length in millimeters
uint16_t getActuatorLength(volatile motor *m){
    uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
    11a4:	8f 8d       	ldd	r24, Y+31	; 0x1f
    11a6:	44 e0       	ldi	r20, 0x04	; 4
    11a8:	60 e4       	ldi	r22, 0x40	; 64
    11aa:	03 d9       	rcall	.-3578   	; 0x3b2 <AVGVoltage>
    11ac:	6c 01       	movw	r12, r24
    11ae:	e1 2c       	mov	r14, r1
    11b0:	f1 2c       	mov	r15, r1
    //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
    voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
    11b2:	fe 01       	movw	r30, r28
    11b4:	e1 5a       	subi	r30, 0xA1	; 161
    11b6:	ff 4f       	sbci	r31, 0xFF	; 255
    11b8:	20 80       	ld	r2, Z
    11ba:	31 80       	ldd	r3, Z+1	; 0x01
//  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
    11bc:	73 97       	sbiw	r30, 0x13	; 19
    11be:	60 81       	ld	r22, Z
    11c0:	71 81       	ldd	r23, Z+1	; 0x01
    11c2:	34 96       	adiw	r30, 0x04	; 4
    11c4:	40 80       	ld	r4, Z
    11c6:	51 80       	ldd	r5, Z+1	; 0x01
    11c8:	62 80       	ldd	r6, Z+2	; 0x02
    11ca:	73 80       	ldd	r7, Z+3	; 0x03
    11cc:	73 96       	adiw	r30, 0x13	; 19
    11ce:	00 81       	ld	r16, Z
    11d0:	11 81       	ldd	r17, Z+1	; 0x01
    11d2:	80 e0       	ldi	r24, 0x00	; 0
    11d4:	90 e0       	ldi	r25, 0x00	; 0
    11d6:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    11da:	4b 01       	movw	r8, r22
    11dc:	5c 01       	movw	r10, r24
    11de:	b8 01       	movw	r22, r16
    11e0:	80 e0       	ldi	r24, 0x00	; 0
    11e2:	90 e0       	ldi	r25, 0x00	; 0
    11e4:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    11e8:	9b 01       	movw	r18, r22
    11ea:	ac 01       	movw	r20, r24
    11ec:	c3 01       	movw	r24, r6
    11ee:	b2 01       	movw	r22, r4
    11f0:	0e 94 41 1a 	call	0x3482	; 0x3482 <__divsf3>
    11f4:	2b 01       	movw	r4, r22
    11f6:	3c 01       	movw	r6, r24

//returns motor actuator length in millimeters
uint16_t getActuatorLength(volatile motor *m){
    uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
    //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
    voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
    11f8:	c7 01       	movw	r24, r14
    11fa:	b6 01       	movw	r22, r12
    11fc:	62 19       	sub	r22, r2
    11fe:	73 09       	sbc	r23, r3
    1200:	81 09       	sbc	r24, r1
    1202:	91 09       	sbc	r25, r1
//  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
    1204:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    1208:	9b 01       	movw	r18, r22
    120a:	ac 01       	movw	r20, r24
    120c:	c3 01       	movw	r24, r6
    120e:	b2 01       	movw	r22, r4
    1210:	0e 94 b7 1b 	call	0x376e	; 0x376e <__mulsf3>
    1214:	9b 01       	movw	r18, r22
    1216:	ac 01       	movw	r20, r24
    1218:	c5 01       	movw	r24, r10
    121a:	b4 01       	movw	r22, r8
    121c:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
    1220:	0e 94 a9 1a 	call	0x3552	; 0x3552 <__fixunssfsi>
    1224:	6b 01       	movw	r12, r22
    1226:	7c 01       	movw	r14, r24
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
    1228:	fe 01       	movw	r30, r28
    122a:	ea 5a       	subi	r30, 0xAA	; 170
    122c:	ff 4f       	sbci	r31, 0xFF	; 255
    122e:	20 81       	ld	r18, Z
    1230:	31 81       	ldd	r19, Z+1	; 0x01
    1232:	62 17       	cp	r22, r18
    1234:	73 07       	cpc	r23, r19
    1236:	38 f5       	brcc	.+78     	; 0x1286 <getMotorPosition+0xf0>
        m->status = MAX_LIMIT;
        motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
    }
    else if(length <= m->actuator_min_limit){
    1238:	fe 01       	movw	r30, r28
    123a:	ec 5a       	subi	r30, 0xAC	; 172
    123c:	ff 4f       	sbci	r31, 0xFF	; 255
    123e:	20 81       	ld	r18, Z
    1240:	31 81       	ldd	r19, Z+1	; 0x01
    1242:	26 17       	cp	r18, r22
    1244:	37 07       	cpc	r19, r23
    1246:	b8 f4       	brcc	.+46     	; 0x1276 <getMotorPosition+0xe0>
//extern motor motors[NUM_OF_MOTORS];

//returns motor final calculated position in degrees
float getMotorPosition(volatile motor *m){
    uint16_t alen = getActuatorLength(m);
    float aoffset = m->angle_correction(alen);
    1248:	fe 01       	movw	r30, r28
    124a:	e3 5a       	subi	r30, 0xA3	; 163
    124c:	ff 4f       	sbci	r31, 0xFF	; 255
    124e:	01 90       	ld	r0, Z+
    1250:	f0 81       	ld	r31, Z
    1252:	e0 2d       	mov	r30, r0
    1254:	c6 01       	movw	r24, r12
    1256:	09 95       	icall
    1258:	9b 01       	movw	r18, r22
    125a:	ac 01       	movw	r20, r24
    return m->angle_reference + aoffset;
    125c:	c8 5b       	subi	r28, 0xB8	; 184
    125e:	df 4f       	sbci	r29, 0xFF	; 255
    1260:	68 81       	ld	r22, Y
    1262:	79 81       	ldd	r23, Y+1	; 0x01
    1264:	8a 81       	ldd	r24, Y+2	; 0x02
    1266:	9b 81       	ldd	r25, Y+3	; 0x03
    1268:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
        90 when actuator is at max position

        ie. 180 + offset => 180 + -90 = 90  degrees
        ie. 180 +offset  => 180 + +90 = 270 degrees
    */
}
    126c:	cd b7       	in	r28, 0x3d	; 61
    126e:	de b7       	in	r29, 0x3e	; 62
    1270:	e2 e1       	ldi	r30, 0x12	; 18
    1272:	0c 94 c1 1c 	jmp	0x3982	; 0x3982 <__epilogue_restores__>
    if (length >= m->actuator_max_limit){
        m->status = MAX_LIMIT;
        motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
    }
    else if(length <= m->actuator_min_limit){
        m->status = MIN_LIMIT;
    1276:	84 e0       	ldi	r24, 0x04	; 4
    1278:	38 96       	adiw	r30, 0x08	; 8
    127a:	80 83       	st	Z, r24
        motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
    127c:	6c a5       	ldd	r22, Y+44	; 0x2c
    127e:	40 e0       	ldi	r20, 0x00	; 0
    1280:	ce 01       	movw	r24, r28
    1282:	df db       	rcall	.-2114   	; 0xa42 <motorControl>
    1284:	e1 cf       	rjmp	.-62     	; 0x1248 <getMotorPosition+0xb2>
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
        m->status = MAX_LIMIT;
    1286:	85 e0       	ldi	r24, 0x05	; 5
    1288:	36 96       	adiw	r30, 0x06	; 6
    128a:	f7 cf       	rjmp	.-18     	; 0x127a <getMotorPosition+0xe4>

0000128c <motorController>:
    This function controls angle and tilt motors
    It reads actual Angle and Tilt values using ADC
    Then it Adjust motor PWM to correct direction and leaves it there.
    This function must be called n. times per second
*/
motor_status motorController(void){
    128c:	a7 e0       	ldi	r26, 0x07	; 7
    128e:	b0 e0       	ldi	r27, 0x00	; 0
    1290:	ec e4       	ldi	r30, 0x4C	; 76
    1292:	f9 e0       	ldi	r31, 0x09	; 9
    1294:	0c 94 a5 1c 	jmp	0x394a	; 0x394a <__prologue_saves__>
    1298:	0e e0       	ldi	r16, 0x0E	; 14
    129a:	11 e0       	ldi	r17, 0x01	; 1
    129c:	21 2c       	mov	r2, r1
    129e:	31 2c       	mov	r3, r1
    //Update current motor positions
    uint8_t status = 0;
    12a0:	19 82       	std	Y+1, r1	; 0x01
    */
}

//returns motor actuator length in millimeters
uint16_t getActuatorLength(volatile motor *m){
    uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
    12a2:	85 e6       	ldi	r24, 0x65	; 101
    12a4:	82 9d       	mul	r24, r2
    12a6:	90 01       	movw	r18, r0
    12a8:	83 9d       	mul	r24, r3
    12aa:	30 0d       	add	r19, r0
    12ac:	11 24       	eor	r1, r1
    12ae:	f9 01       	movw	r30, r18
    12b0:	e2 5f       	subi	r30, 0xF2	; 242
    12b2:	fe 4f       	sbci	r31, 0xFE	; 254
    12b4:	ff 83       	std	Y+7, r31	; 0x07
    12b6:	ee 83       	std	Y+6, r30	; 0x06
    12b8:	87 8d       	ldd	r24, Z+31	; 0x1f
    12ba:	44 e0       	ldi	r20, 0x04	; 4
    12bc:	60 e4       	ldi	r22, 0x40	; 64
    12be:	79 d8       	rcall	.-3854   	; 0x3b2 <AVGVoltage>
    12c0:	2c 01       	movw	r4, r24
    12c2:	61 2c       	mov	r6, r1
    12c4:	71 2c       	mov	r7, r1
    //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
    voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
    12c6:	ee 81       	ldd	r30, Y+6	; 0x06
    12c8:	ff 81       	ldd	r31, Y+7	; 0x07
    12ca:	e1 5a       	subi	r30, 0xA1	; 161
    12cc:	ff 4f       	sbci	r31, 0xFF	; 255
    12ce:	20 81       	ld	r18, Z
    12d0:	31 81       	ldd	r19, Z+1	; 0x01
    12d2:	3b 83       	std	Y+3, r19	; 0x03
    12d4:	2a 83       	std	Y+2, r18	; 0x02
//  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
    12d6:	ee 81       	ldd	r30, Y+6	; 0x06
    12d8:	ff 81       	ldd	r31, Y+7	; 0x07
    12da:	e4 5b       	subi	r30, 0xB4	; 180
    12dc:	ff 4f       	sbci	r31, 0xFF	; 255
    12de:	60 81       	ld	r22, Z
    12e0:	71 81       	ldd	r23, Z+1	; 0x01
    12e2:	ee 81       	ldd	r30, Y+6	; 0x06
    12e4:	ff 81       	ldd	r31, Y+7	; 0x07
    12e6:	e0 5b       	subi	r30, 0xB0	; 176
    12e8:	ff 4f       	sbci	r31, 0xFF	; 255
    12ea:	80 80       	ld	r8, Z
    12ec:	91 80       	ldd	r9, Z+1	; 0x01
    12ee:	a2 80       	ldd	r10, Z+2	; 0x02
    12f0:	b3 80       	ldd	r11, Z+3	; 0x03
    12f2:	ee 81       	ldd	r30, Y+6	; 0x06
    12f4:	ff 81       	ldd	r31, Y+7	; 0x07
    12f6:	ed 59       	subi	r30, 0x9D	; 157
    12f8:	ff 4f       	sbci	r31, 0xFF	; 255
    12fa:	20 81       	ld	r18, Z
    12fc:	31 81       	ldd	r19, Z+1	; 0x01
    12fe:	80 e0       	ldi	r24, 0x00	; 0
    1300:	90 e0       	ldi	r25, 0x00	; 0
    1302:	2c 83       	std	Y+4, r18	; 0x04
    1304:	3d 83       	std	Y+5, r19	; 0x05
    1306:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    130a:	6b 01       	movw	r12, r22
    130c:	7c 01       	movw	r14, r24
    130e:	2c 81       	ldd	r18, Y+4	; 0x04
    1310:	3d 81       	ldd	r19, Y+5	; 0x05
    1312:	b9 01       	movw	r22, r18
    1314:	80 e0       	ldi	r24, 0x00	; 0
    1316:	90 e0       	ldi	r25, 0x00	; 0
    1318:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    131c:	9b 01       	movw	r18, r22
    131e:	ac 01       	movw	r20, r24
    1320:	c5 01       	movw	r24, r10
    1322:	b4 01       	movw	r22, r8
    1324:	0e 94 41 1a 	call	0x3482	; 0x3482 <__divsf3>
    1328:	4b 01       	movw	r8, r22
    132a:	5c 01       	movw	r10, r24

//returns motor actuator length in millimeters
uint16_t getActuatorLength(volatile motor *m){
    uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
    //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
    voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
    132c:	c3 01       	movw	r24, r6
    132e:	b2 01       	movw	r22, r4
    1330:	ea 81       	ldd	r30, Y+2	; 0x02
    1332:	fb 81       	ldd	r31, Y+3	; 0x03
    1334:	6e 1b       	sub	r22, r30
    1336:	7f 0b       	sbc	r23, r31
    1338:	81 09       	sbc	r24, r1
    133a:	91 09       	sbc	r25, r1
//  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
    133c:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    1340:	9b 01       	movw	r18, r22
    1342:	ac 01       	movw	r20, r24
    1344:	c5 01       	movw	r24, r10
    1346:	b4 01       	movw	r22, r8
    1348:	0e 94 b7 1b 	call	0x376e	; 0x376e <__mulsf3>
    134c:	9b 01       	movw	r18, r22
    134e:	ac 01       	movw	r20, r24
    1350:	c7 01       	movw	r24, r14
    1352:	b6 01       	movw	r22, r12
    1354:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
    1358:	0e 94 a9 1a 	call	0x3552	; 0x3552 <__fixunssfsi>
    135c:	6b 01       	movw	r12, r22
    135e:	7c 01       	movw	r14, r24
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
    1360:	ee 81       	ldd	r30, Y+6	; 0x06
    1362:	ff 81       	ldd	r31, Y+7	; 0x07
    1364:	ea 5a       	subi	r30, 0xAA	; 170
    1366:	ff 4f       	sbci	r31, 0xFF	; 255
    1368:	20 81       	ld	r18, Z
    136a:	31 81       	ldd	r19, Z+1	; 0x01
        m->status = MAX_LIMIT;
    136c:	ee 81       	ldd	r30, Y+6	; 0x06
    136e:	ff 81       	ldd	r31, Y+7	; 0x07
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
    1370:	62 17       	cp	r22, r18
    1372:	73 07       	cpc	r23, r19
    1374:	08 f0       	brcs	.+2      	; 0x1378 <motorController+0xec>
    1376:	4c c0       	rjmp	.+152    	; 0x1410 <motorController+0x184>
        m->status = MAX_LIMIT;
        motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
    }
    else if(length <= m->actuator_min_limit){
    1378:	ec 5a       	subi	r30, 0xAC	; 172
    137a:	ff 4f       	sbci	r31, 0xFF	; 255
    137c:	20 81       	ld	r18, Z
    137e:	31 81       	ldd	r19, Z+1	; 0x01
    1380:	26 17       	cp	r18, r22
    1382:	37 07       	cpc	r19, r23
    1384:	c0 f5       	brcc	.+112    	; 0x13f6 <motorController+0x16a>
//extern motor motors[NUM_OF_MOTORS];

//returns motor final calculated position in degrees
float getMotorPosition(volatile motor *m){
    uint16_t alen = getActuatorLength(m);
    float aoffset = m->angle_correction(alen);
    1386:	f5 e6       	ldi	r31, 0x65	; 101
    1388:	f2 9d       	mul	r31, r2
    138a:	90 01       	movw	r18, r0
    138c:	f3 9d       	mul	r31, r3
    138e:	30 0d       	add	r19, r0
    1390:	11 24       	eor	r1, r1
    1392:	c9 01       	movw	r24, r18
    1394:	82 5f       	subi	r24, 0xF2	; 242
    1396:	9e 4f       	sbci	r25, 0xFE	; 254
    1398:	5c 01       	movw	r10, r24
    139a:	fc 01       	movw	r30, r24
    139c:	e3 5a       	subi	r30, 0xA3	; 163
    139e:	ff 4f       	sbci	r31, 0xFF	; 255
    13a0:	01 90       	ld	r0, Z+
    13a2:	f0 81       	ld	r31, Z
    13a4:	e0 2d       	mov	r30, r0
    13a6:	c6 01       	movw	r24, r12
    13a8:	09 95       	icall
    return m->angle_reference + aoffset;
    13aa:	f5 01       	movw	r30, r10
    13ac:	e8 5b       	subi	r30, 0xB8	; 184
    13ae:	ff 4f       	sbci	r31, 0xFF	; 255
    13b0:	20 81       	ld	r18, Z
    13b2:	31 81       	ldd	r19, Z+1	; 0x01
    13b4:	42 81       	ldd	r20, Z+2	; 0x02
    13b6:	53 81       	ldd	r21, Z+3	; 0x03
    13b8:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
motor_status motorController(void){
    //Update current motor positions
    uint8_t status = 0;
    for (uint8_t i = 0; i < NUM_OF_MOTORS; i++){
        volatile motor *m = &motors[i];
        m->current_position = getMotorPosition(m); 
    13bc:	f5 01       	movw	r30, r10
    13be:	65 a7       	std	Z+45, r22	; 0x2d
    13c0:	76 a7       	std	Z+46, r23	; 0x2e
    13c2:	87 a7       	std	Z+47, r24	; 0x2f
    13c4:	90 ab       	std	Z+48, r25	; 0x30
        motorControlLoop(m);
    13c6:	c8 01       	movw	r24, r16
    13c8:	93 dc       	rcall	.-1754   	; 0xcf0 <motorControlLoop>
        status += m->status; //Collect status from all motors
    13ca:	f5 01       	movw	r30, r10
    13cc:	e4 5a       	subi	r30, 0xA4	; 164
    13ce:	ff 4f       	sbci	r31, 0xFF	; 255
    13d0:	80 81       	ld	r24, Z
    13d2:	f9 81       	ldd	r31, Y+1	; 0x01
    13d4:	f8 0f       	add	r31, r24
    13d6:	f9 83       	std	Y+1, r31	; 0x01
    13d8:	0b 59       	subi	r16, 0x9B	; 155
    13da:	1f 4f       	sbci	r17, 0xFF	; 255
    This function must be called n. times per second
*/
motor_status motorController(void){
    //Update current motor positions
    uint8_t status = 0;
    for (uint8_t i = 0; i < NUM_OF_MOTORS; i++){
    13dc:	21 e0       	ldi	r18, 0x01	; 1
    13de:	22 16       	cp	r2, r18
    13e0:	31 04       	cpc	r3, r1
    13e2:	29 f4       	brne	.+10     	; 0x13ee <motorController+0x162>
        m->current_position = getMotorPosition(m); 
        motorControlLoop(m);
        status += m->status; //Collect status from all motors
    }
    return status;
}
    13e4:	8f 2f       	mov	r24, r31
    13e6:	27 96       	adiw	r28, 0x07	; 7
    13e8:	e2 e1       	ldi	r30, 0x12	; 18
    13ea:	0c 94 c1 1c 	jmp	0x3982	; 0x3982 <__epilogue_restores__>
    13ee:	22 24       	eor	r2, r2
    13f0:	23 94       	inc	r2
    13f2:	31 2c       	mov	r3, r1
    13f4:	56 cf       	rjmp	.-340    	; 0x12a2 <motorController+0x16>
    if (length >= m->actuator_max_limit){
        m->status = MAX_LIMIT;
        motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
    }
    else if(length <= m->actuator_min_limit){
        m->status = MIN_LIMIT;
    13f6:	ee 81       	ldd	r30, Y+6	; 0x06
    13f8:	ff 81       	ldd	r31, Y+7	; 0x07
    13fa:	e4 5a       	subi	r30, 0xA4	; 164
    13fc:	ff 4f       	sbci	r31, 0xFF	; 255
    13fe:	84 e0       	ldi	r24, 0x04	; 4
    1400:	80 83       	st	Z, r24
        motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
    1402:	ee 81       	ldd	r30, Y+6	; 0x06
    1404:	ff 81       	ldd	r31, Y+7	; 0x07
    1406:	64 a5       	ldd	r22, Z+44	; 0x2c
    1408:	40 e0       	ldi	r20, 0x00	; 0
    140a:	c8 01       	movw	r24, r16
    140c:	1a db       	rcall	.-2508   	; 0xa42 <motorControl>
    140e:	bb cf       	rjmp	.-138    	; 0x1386 <motorController+0xfa>
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
        m->status = MAX_LIMIT;
    1410:	e4 5a       	subi	r30, 0xA4	; 164
    1412:	ff 4f       	sbci	r31, 0xFF	; 255
    1414:	25 e0       	ldi	r18, 0x05	; 5
    1416:	20 83       	st	Z, r18
    1418:	f4 cf       	rjmp	.-24     	; 0x1402 <motorController+0x176>

0000141a <shutdownMotors>:
}

/*
    Shutdown all motors, this is used to activate manual mode
*/
void shutdownMotors(void){
    141a:	a6 e0       	ldi	r26, 0x06	; 6
    141c:	b0 e0       	ldi	r27, 0x00	; 0
    141e:	e3 e1       	ldi	r30, 0x13	; 19
    1420:	fa e0       	ldi	r31, 0x0A	; 10
    1422:	0c 94 a5 1c 	jmp	0x394a	; 0x394a <__prologue_saves__>
    1426:	8e e0       	ldi	r24, 0x0E	; 14
    1428:	28 2e       	mov	r2, r24
    142a:	81 e0       	ldi	r24, 0x01	; 1
    142c:	38 2e       	mov	r3, r24
    142e:	00 e0       	ldi	r16, 0x00	; 0
    1430:	10 e0       	ldi	r17, 0x00	; 0
    
   // GTCCR = 0x00;       //Start Counter
}
void disableMotorPWM(volatile motor *m){

    *m->enable_port_addr &= ~(1<<m->enable_pin); //Disable motor => clear enable port
    1432:	45 e6       	ldi	r20, 0x65	; 101
    1434:	40 9f       	mul	r20, r16
    1436:	90 01       	movw	r18, r0
    1438:	41 9f       	mul	r20, r17
    143a:	30 0d       	add	r19, r0
    143c:	11 24       	eor	r1, r1
    143e:	c9 01       	movw	r24, r18
    1440:	82 5f       	subi	r24, 0xF2	; 242
    1442:	9e 4f       	sbci	r25, 0xFE	; 254
    1444:	9e 83       	std	Y+6, r25	; 0x06
    1446:	8d 83       	std	Y+5, r24	; 0x05
    1448:	dc 01       	movw	r26, r24
    144a:	5e 96       	adiw	r26, 0x1e	; 30
    144c:	8c 91       	ld	r24, X
    144e:	5e 97       	sbiw	r26, 0x1e	; 30
    1450:	5a 96       	adiw	r26, 0x1a	; 26
    1452:	ed 91       	ld	r30, X+
    1454:	fc 91       	ld	r31, X
    1456:	5b 97       	sbiw	r26, 0x1b	; 27
    1458:	20 81       	ld	r18, Z
    145a:	41 e0       	ldi	r20, 0x01	; 1
    145c:	50 e0       	ldi	r21, 0x00	; 0
    145e:	02 c0       	rjmp	.+4      	; 0x1464 <shutdownMotors+0x4a>
    1460:	44 0f       	add	r20, r20
    1462:	55 1f       	adc	r21, r21
    1464:	8a 95       	dec	r24
    1466:	e2 f7       	brpl	.-8      	; 0x1460 <shutdownMotors+0x46>
    1468:	ca 01       	movw	r24, r20
    146a:	80 95       	com	r24
    146c:	90 95       	com	r25
    146e:	82 23       	and	r24, r18
    1470:	80 83       	st	Z, r24
    *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
    1472:	15 96       	adiw	r26, 0x05	; 5
    1474:	ed 91       	ld	r30, X+
    1476:	fc 91       	ld	r31, X
    1478:	16 97       	sbiw	r26, 0x06	; 6
    147a:	10 82       	st	Z, r1
    *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
    147c:	18 96       	adiw	r26, 0x08	; 8
    147e:	ed 91       	ld	r30, X+
    1480:	fc 91       	ld	r31, X
    1482:	19 97       	sbiw	r26, 0x09	; 9
    1484:	10 82       	st	Z, r1
    *m->fwd_OCR_addr = 0x00; //Init PWM to zero
    1486:	1b 96       	adiw	r26, 0x0b	; 11
    1488:	ed 91       	ld	r30, X+
    148a:	fc 91       	ld	r31, X
    148c:	1c 97       	sbiw	r26, 0x0c	; 12
    148e:	10 82       	st	Z, r1
    
    //Init reverse PWM settings
    *m->rev_TCCRA_addr = 0x00;//m.rev_TCCRA_value;
    1490:	52 96       	adiw	r26, 0x12	; 18
    1492:	ed 91       	ld	r30, X+
    1494:	fc 91       	ld	r31, X
    1496:	53 97       	sbiw	r26, 0x13	; 19
    1498:	10 82       	st	Z, r1
    *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
    149a:	55 96       	adiw	r26, 0x15	; 21
    149c:	ed 91       	ld	r30, X+
    149e:	fc 91       	ld	r31, X
    14a0:	56 97       	sbiw	r26, 0x16	; 22
    14a2:	10 82       	st	Z, r1
    *m->rev_OCR_addr = 0x00; //Init PWM to zero
    14a4:	58 96       	adiw	r26, 0x18	; 24
    14a6:	ed 91       	ld	r30, X+
    14a8:	fc 91       	ld	r31, X
    14aa:	59 97       	sbiw	r26, 0x19	; 25
    14ac:	10 82       	st	Z, r1
    m->current_pwm = 0; //set PWM to zero
    14ae:	9b 96       	adiw	r26, 0x2b	; 43
    14b0:	1c 92       	st	X, r1
    14b2:	9b 97       	sbiw	r26, 0x2b	; 43
    m->timeout_value = 0; //Reset timeout values
    14b4:	fd 01       	movw	r30, r26
    14b6:	e6 5a       	subi	r30, 0xA6	; 166
    14b8:	ff 4f       	sbci	r31, 0xFF	; 255
    14ba:	11 82       	std	Z+1, r1	; 0x01
    14bc:	10 82       	st	Z, r1
    */
}

//returns motor actuator length in millimeters
uint16_t getActuatorLength(volatile motor *m){
    uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
    14be:	5f 96       	adiw	r26, 0x1f	; 31
    14c0:	8c 91       	ld	r24, X
    14c2:	44 e0       	ldi	r20, 0x04	; 4
    14c4:	60 e4       	ldi	r22, 0x40	; 64
    14c6:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <AVGVoltage>
    14ca:	6c 01       	movw	r12, r24
    14cc:	e1 2c       	mov	r14, r1
    14ce:	f1 2c       	mov	r15, r1
    //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
    voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
    14d0:	ed 81       	ldd	r30, Y+5	; 0x05
    14d2:	fe 81       	ldd	r31, Y+6	; 0x06
    14d4:	e1 5a       	subi	r30, 0xA1	; 161
    14d6:	ff 4f       	sbci	r31, 0xFF	; 255
    14d8:	80 81       	ld	r24, Z
    14da:	91 81       	ldd	r25, Z+1	; 0x01
    14dc:	9a 83       	std	Y+2, r25	; 0x02
    14de:	89 83       	std	Y+1, r24	; 0x01
//  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
    14e0:	ed 81       	ldd	r30, Y+5	; 0x05
    14e2:	fe 81       	ldd	r31, Y+6	; 0x06
    14e4:	e4 5b       	subi	r30, 0xB4	; 180
    14e6:	ff 4f       	sbci	r31, 0xFF	; 255
    14e8:	60 81       	ld	r22, Z
    14ea:	71 81       	ldd	r23, Z+1	; 0x01
    14ec:	ed 81       	ldd	r30, Y+5	; 0x05
    14ee:	fe 81       	ldd	r31, Y+6	; 0x06
    14f0:	e0 5b       	subi	r30, 0xB0	; 176
    14f2:	ff 4f       	sbci	r31, 0xFF	; 255
    14f4:	40 80       	ld	r4, Z
    14f6:	51 80       	ldd	r5, Z+1	; 0x01
    14f8:	62 80       	ldd	r6, Z+2	; 0x02
    14fa:	73 80       	ldd	r7, Z+3	; 0x03
    14fc:	ed 81       	ldd	r30, Y+5	; 0x05
    14fe:	fe 81       	ldd	r31, Y+6	; 0x06
    1500:	ed 59       	subi	r30, 0x9D	; 157
    1502:	ff 4f       	sbci	r31, 0xFF	; 255
    1504:	20 81       	ld	r18, Z
    1506:	31 81       	ldd	r19, Z+1	; 0x01
    1508:	80 e0       	ldi	r24, 0x00	; 0
    150a:	90 e0       	ldi	r25, 0x00	; 0
    150c:	2b 83       	std	Y+3, r18	; 0x03
    150e:	3c 83       	std	Y+4, r19	; 0x04
    1510:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    1514:	4b 01       	movw	r8, r22
    1516:	5c 01       	movw	r10, r24
    1518:	2b 81       	ldd	r18, Y+3	; 0x03
    151a:	3c 81       	ldd	r19, Y+4	; 0x04
    151c:	b9 01       	movw	r22, r18
    151e:	80 e0       	ldi	r24, 0x00	; 0
    1520:	90 e0       	ldi	r25, 0x00	; 0
    1522:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    1526:	9b 01       	movw	r18, r22
    1528:	ac 01       	movw	r20, r24
    152a:	c3 01       	movw	r24, r6
    152c:	b2 01       	movw	r22, r4
    152e:	0e 94 41 1a 	call	0x3482	; 0x3482 <__divsf3>
    1532:	2b 01       	movw	r4, r22
    1534:	3c 01       	movw	r6, r24

//returns motor actuator length in millimeters
uint16_t getActuatorLength(volatile motor *m){
    uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
    //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
    voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
    1536:	c7 01       	movw	r24, r14
    1538:	b6 01       	movw	r22, r12
    153a:	a9 81       	ldd	r26, Y+1	; 0x01
    153c:	ba 81       	ldd	r27, Y+2	; 0x02
    153e:	6a 1b       	sub	r22, r26
    1540:	7b 0b       	sbc	r23, r27
    1542:	81 09       	sbc	r24, r1
    1544:	91 09       	sbc	r25, r1
//  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
    1546:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    154a:	9b 01       	movw	r18, r22
    154c:	ac 01       	movw	r20, r24
    154e:	c3 01       	movw	r24, r6
    1550:	b2 01       	movw	r22, r4
    1552:	0e 94 b7 1b 	call	0x376e	; 0x376e <__mulsf3>
    1556:	9b 01       	movw	r18, r22
    1558:	ac 01       	movw	r20, r24
    155a:	c5 01       	movw	r24, r10
    155c:	b4 01       	movw	r22, r8
    155e:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
    1562:	0e 94 a9 1a 	call	0x3552	; 0x3552 <__fixunssfsi>
    1566:	6b 01       	movw	r12, r22
    1568:	7c 01       	movw	r14, r24
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
    156a:	ed 81       	ldd	r30, Y+5	; 0x05
    156c:	fe 81       	ldd	r31, Y+6	; 0x06
    156e:	ea 5a       	subi	r30, 0xAA	; 170
    1570:	ff 4f       	sbci	r31, 0xFF	; 255
    1572:	20 81       	ld	r18, Z
    1574:	31 81       	ldd	r19, Z+1	; 0x01
        m->status = MAX_LIMIT;
    1576:	ed 81       	ldd	r30, Y+5	; 0x05
    1578:	fe 81       	ldd	r31, Y+6	; 0x06
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
    157a:	62 17       	cp	r22, r18
    157c:	73 07       	cpc	r23, r19
    157e:	08 f0       	brcs	.+2      	; 0x1582 <shutdownMotors+0x168>
    1580:	4d c0       	rjmp	.+154    	; 0x161c <shutdownMotors+0x202>
        m->status = MAX_LIMIT;
        motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
    }
    else if(length <= m->actuator_min_limit){
    1582:	ec 5a       	subi	r30, 0xAC	; 172
    1584:	ff 4f       	sbci	r31, 0xFF	; 255
    1586:	20 81       	ld	r18, Z
    1588:	31 81       	ldd	r19, Z+1	; 0x01
    158a:	26 17       	cp	r18, r22
    158c:	37 07       	cpc	r19, r23
    158e:	68 f0       	brcs	.+26     	; 0x15aa <shutdownMotors+0x190>
        m->status = MIN_LIMIT;
    1590:	ed 81       	ldd	r30, Y+5	; 0x05
    1592:	fe 81       	ldd	r31, Y+6	; 0x06
    1594:	e4 5a       	subi	r30, 0xA4	; 164
    1596:	ff 4f       	sbci	r31, 0xFF	; 255
    1598:	84 e0       	ldi	r24, 0x04	; 4
    159a:	80 83       	st	Z, r24
        motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
    159c:	ad 81       	ldd	r26, Y+5	; 0x05
    159e:	be 81       	ldd	r27, Y+6	; 0x06
    15a0:	9c 96       	adiw	r26, 0x2c	; 44
    15a2:	6c 91       	ld	r22, X
    15a4:	40 e0       	ldi	r20, 0x00	; 0
    15a6:	c1 01       	movw	r24, r2
    15a8:	4c da       	rcall	.-2920   	; 0xa42 <motorControl>
//extern motor motors[NUM_OF_MOTORS];

//returns motor final calculated position in degrees
float getMotorPosition(volatile motor *m){
    uint16_t alen = getActuatorLength(m);
    float aoffset = m->angle_correction(alen);
    15aa:	b5 e6       	ldi	r27, 0x65	; 101
    15ac:	b0 9f       	mul	r27, r16
    15ae:	90 01       	movw	r18, r0
    15b0:	b1 9f       	mul	r27, r17
    15b2:	30 0d       	add	r19, r0
    15b4:	11 24       	eor	r1, r1
    15b6:	f9 01       	movw	r30, r18
    15b8:	e2 5f       	subi	r30, 0xF2	; 242
    15ba:	fe 4f       	sbci	r31, 0xFE	; 254
    15bc:	5f 01       	movw	r10, r30
    15be:	e3 5a       	subi	r30, 0xA3	; 163
    15c0:	ff 4f       	sbci	r31, 0xFF	; 255
    15c2:	01 90       	ld	r0, Z+
    15c4:	f0 81       	ld	r31, Z
    15c6:	e0 2d       	mov	r30, r0
    15c8:	c6 01       	movw	r24, r12
    15ca:	09 95       	icall
    return m->angle_reference + aoffset;
    15cc:	f5 01       	movw	r30, r10
    15ce:	e8 5b       	subi	r30, 0xB8	; 184
    15d0:	ff 4f       	sbci	r31, 0xFF	; 255
    15d2:	20 81       	ld	r18, Z
    15d4:	31 81       	ldd	r19, Z+1	; 0x01
    15d6:	42 81       	ldd	r20, Z+2	; 0x02
    15d8:	53 81       	ldd	r21, Z+3	; 0x03
    15da:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
    Shutdown all motors, this is used to activate manual mode
*/
void shutdownMotors(void){
    for (uint8_t i = 0; i<NUM_OF_MOTORS; i++){
        disableMotorPWM(&motors[i]);
        motors[i].current_position = getMotorPosition(&motors[i]);
    15de:	d5 01       	movw	r26, r10
    15e0:	9d 96       	adiw	r26, 0x2d	; 45
    15e2:	6d 93       	st	X+, r22
    15e4:	7d 93       	st	X+, r23
    15e6:	8d 93       	st	X+, r24
    15e8:	9c 93       	st	X, r25
    15ea:	d0 97       	sbiw	r26, 0x30	; 48
        motors[i].set_position = motors[i].current_position; //reset settings
    15ec:	9d 96       	adiw	r26, 0x2d	; 45
    15ee:	8d 91       	ld	r24, X+
    15f0:	9d 91       	ld	r25, X+
    15f2:	0d 90       	ld	r0, X+
    15f4:	bc 91       	ld	r27, X
    15f6:	a0 2d       	mov	r26, r0
    15f8:	f5 01       	movw	r30, r10
    15fa:	81 ab       	std	Z+49, r24	; 0x31
    15fc:	92 ab       	std	Z+50, r25	; 0x32
    15fe:	a3 ab       	std	Z+51, r26	; 0x33
    1600:	b4 ab       	std	Z+52, r27	; 0x34
    1602:	f5 e6       	ldi	r31, 0x65	; 101
    1604:	2f 0e       	add	r2, r31
    1606:	31 1c       	adc	r3, r1

/*
    Shutdown all motors, this is used to activate manual mode
*/
void shutdownMotors(void){
    for (uint8_t i = 0; i<NUM_OF_MOTORS; i++){
    1608:	01 30       	cpi	r16, 0x01	; 1
    160a:	11 05       	cpc	r17, r1
    160c:	21 f4       	brne	.+8      	; 0x1616 <shutdownMotors+0x1fc>
        disableMotorPWM(&motors[i]);
        motors[i].current_position = getMotorPosition(&motors[i]);
        motors[i].set_position = motors[i].current_position; //reset settings
    }
}
    160e:	26 96       	adiw	r28, 0x06	; 6
    1610:	e2 e1       	ldi	r30, 0x12	; 18
    1612:	0c 94 c1 1c 	jmp	0x3982	; 0x3982 <__epilogue_restores__>
    1616:	01 e0       	ldi	r16, 0x01	; 1
    1618:	10 e0       	ldi	r17, 0x00	; 0
    161a:	0b cf       	rjmp	.-490    	; 0x1432 <shutdownMotors+0x18>
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
        m->status = MAX_LIMIT;
    161c:	e4 5a       	subi	r30, 0xA4	; 164
    161e:	ff 4f       	sbci	r31, 0xFF	; 255
    1620:	b5 e0       	ldi	r27, 0x05	; 5
    1622:	b0 83       	st	Z, r27
        motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
    1624:	ed 81       	ldd	r30, Y+5	; 0x05
    1626:	fe 81       	ldd	r31, Y+6	; 0x06
    1628:	64 a5       	ldd	r22, Z+44	; 0x2c
    162a:	40 e0       	ldi	r20, 0x00	; 0
    162c:	c1 01       	movw	r24, r2
    162e:	09 da       	rcall	.-3054   	; 0xa42 <motorControl>
    1630:	bc cf       	rjmp	.-136    	; 0x15aa <shutdownMotors+0x190>

00001632 <initMotor>:
    }
    m->current_dir = dir;
}


void initMotor(FILE *debugport){
    1632:	a8 e0       	ldi	r26, 0x08	; 8
    1634:	b0 e0       	ldi	r27, 0x00	; 0
    1636:	ef e1       	ldi	r30, 0x1F	; 31
    1638:	fb e0       	ldi	r31, 0x0B	; 11
    163a:	0c 94 a5 1c 	jmp	0x394a	; 0x394a <__prologue_saves__>
    port = debugport;
    163e:	90 93 dd 02 	sts	0x02DD, r25	; 0x8002dd <port+0x1>
    1642:	80 93 dc 02 	sts	0x02DC, r24	; 0x8002dc <port>
    1646:	2e e0       	ldi	r18, 0x0E	; 14
    1648:	31 e0       	ldi	r19, 0x01	; 1
    164a:	3a 83       	std	Y+2, r19	; 0x02
    164c:	29 83       	std	Y+1, r18	; 0x01
    164e:	21 2c       	mov	r2, r1
    1650:	31 2c       	mov	r3, r1


    for(uint8_t i = 0; i<NUM_OF_MOTORS; i++){
        volatile motor *m = &motors[i];
        //Set direction and enable to output pins
        *m->fwd_dir_addr |= 1<<m->fwd_pin;
    1652:	01 e0       	ldi	r16, 0x01	; 1
    1654:	10 e0       	ldi	r17, 0x00	; 0
    1656:	45 e6       	ldi	r20, 0x65	; 101
    1658:	42 9d       	mul	r20, r2
    165a:	90 01       	movw	r18, r0
    165c:	43 9d       	mul	r20, r3
    165e:	30 0d       	add	r19, r0
    1660:	11 24       	eor	r1, r1
    1662:	c9 01       	movw	r24, r18
    1664:	82 5f       	subi	r24, 0xF2	; 242
    1666:	9e 4f       	sbci	r25, 0xFE	; 254
    1668:	98 87       	std	Y+8, r25	; 0x08
    166a:	8f 83       	std	Y+7, r24	; 0x07
    166c:	dc 01       	movw	r26, r24
    166e:	14 96       	adiw	r26, 0x04	; 4
    1670:	8c 91       	ld	r24, X
    1672:	14 97       	sbiw	r26, 0x04	; 4
    1674:	12 96       	adiw	r26, 0x02	; 2
    1676:	ed 91       	ld	r30, X+
    1678:	fc 91       	ld	r31, X
    167a:	13 97       	sbiw	r26, 0x03	; 3
    167c:	20 81       	ld	r18, Z
    167e:	a8 01       	movw	r20, r16
    1680:	02 c0       	rjmp	.+4      	; 0x1686 <initMotor+0x54>
    1682:	44 0f       	add	r20, r20
    1684:	55 1f       	adc	r21, r21
    1686:	8a 95       	dec	r24
    1688:	e2 f7       	brpl	.-8      	; 0x1682 <initMotor+0x50>
    168a:	ca 01       	movw	r24, r20
    168c:	82 2b       	or	r24, r18
    168e:	80 83       	st	Z, r24
        *m->rev_dir_addr |= 1<<m->rev_pin;
    1690:	51 96       	adiw	r26, 0x11	; 17
    1692:	8c 91       	ld	r24, X
    1694:	51 97       	sbiw	r26, 0x11	; 17
    1696:	1f 96       	adiw	r26, 0x0f	; 15
    1698:	ed 91       	ld	r30, X+
    169a:	fc 91       	ld	r31, X
    169c:	50 97       	sbiw	r26, 0x10	; 16
    169e:	20 81       	ld	r18, Z
    16a0:	d8 01       	movw	r26, r16
    16a2:	02 c0       	rjmp	.+4      	; 0x16a8 <initMotor+0x76>
    16a4:	aa 0f       	add	r26, r26
    16a6:	bb 1f       	adc	r27, r27
    16a8:	8a 95       	dec	r24
    16aa:	e2 f7       	brpl	.-8      	; 0x16a4 <initMotor+0x72>
    16ac:	cd 01       	movw	r24, r26
    16ae:	82 2b       	or	r24, r18
    16b0:	80 83       	st	Z, r24
        *m->enable_dir_addr |= 1<<m->enable_pin;
    16b2:	ef 81       	ldd	r30, Y+7	; 0x07
    16b4:	f8 85       	ldd	r31, Y+8	; 0x08
    16b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    16b8:	04 8c       	ldd	r0, Z+28	; 0x1c
    16ba:	f5 8d       	ldd	r31, Z+29	; 0x1d
    16bc:	e0 2d       	mov	r30, r0
    16be:	20 81       	ld	r18, Z
    16c0:	a8 01       	movw	r20, r16
    16c2:	02 c0       	rjmp	.+4      	; 0x16c8 <initMotor+0x96>
    16c4:	44 0f       	add	r20, r20
    16c6:	55 1f       	adc	r21, r21
    16c8:	8a 95       	dec	r24
    16ca:	e2 f7       	brpl	.-8      	; 0x16c4 <initMotor+0x92>
    16cc:	ca 01       	movw	r24, r20
    16ce:	82 2b       	or	r24, r18
    16d0:	80 83       	st	Z, r24
        
        //Set pullups correctly
        *m->fwd_port_addr &= ~(1<<m->fwd_pin);
    16d2:	af 81       	ldd	r26, Y+7	; 0x07
    16d4:	b8 85       	ldd	r27, Y+8	; 0x08
    16d6:	14 96       	adiw	r26, 0x04	; 4
    16d8:	8c 91       	ld	r24, X
    16da:	14 97       	sbiw	r26, 0x04	; 4
    16dc:	ed 91       	ld	r30, X+
    16de:	fc 91       	ld	r31, X
    16e0:	11 97       	sbiw	r26, 0x01	; 1
    16e2:	20 81       	ld	r18, Z
    16e4:	a8 01       	movw	r20, r16
    16e6:	02 c0       	rjmp	.+4      	; 0x16ec <initMotor+0xba>
    16e8:	44 0f       	add	r20, r20
    16ea:	55 1f       	adc	r21, r21
    16ec:	8a 95       	dec	r24
    16ee:	e2 f7       	brpl	.-8      	; 0x16e8 <initMotor+0xb6>
    16f0:	ca 01       	movw	r24, r20
    16f2:	80 95       	com	r24
    16f4:	90 95       	com	r25
    16f6:	82 23       	and	r24, r18
    16f8:	80 83       	st	Z, r24
        *m->rev_port_addr &= ~(1<<m->rev_pin);
    16fa:	51 96       	adiw	r26, 0x11	; 17
    16fc:	8c 91       	ld	r24, X
    16fe:	51 97       	sbiw	r26, 0x11	; 17
    1700:	1d 96       	adiw	r26, 0x0d	; 13
    1702:	ed 91       	ld	r30, X+
    1704:	fc 91       	ld	r31, X
    1706:	1e 97       	sbiw	r26, 0x0e	; 14
    1708:	20 81       	ld	r18, Z
    170a:	d8 01       	movw	r26, r16
    170c:	02 c0       	rjmp	.+4      	; 0x1712 <initMotor+0xe0>
    170e:	aa 0f       	add	r26, r26
    1710:	bb 1f       	adc	r27, r27
    1712:	8a 95       	dec	r24
    1714:	e2 f7       	brpl	.-8      	; 0x170e <initMotor+0xdc>
    1716:	cd 01       	movw	r24, r26
    1718:	80 95       	com	r24
    171a:	90 95       	com	r25
    171c:	82 23       	and	r24, r18
    171e:	80 83       	st	Z, r24
        *m->enable_port_addr &= ~(1<<m->enable_pin);
    1720:	ef 81       	ldd	r30, Y+7	; 0x07
    1722:	f8 85       	ldd	r31, Y+8	; 0x08
    1724:	86 8d       	ldd	r24, Z+30	; 0x1e
    1726:	02 8c       	ldd	r0, Z+26	; 0x1a
    1728:	f3 8d       	ldd	r31, Z+27	; 0x1b
    172a:	e0 2d       	mov	r30, r0
    172c:	20 81       	ld	r18, Z
    172e:	a8 01       	movw	r20, r16
    1730:	02 c0       	rjmp	.+4      	; 0x1736 <initMotor+0x104>
    1732:	44 0f       	add	r20, r20
    1734:	55 1f       	adc	r21, r21
    1736:	8a 95       	dec	r24
    1738:	e2 f7       	brpl	.-8      	; 0x1732 <initMotor+0x100>
    173a:	ca 01       	movw	r24, r20
    173c:	80 95       	com	r24
    173e:	90 95       	com	r25
    1740:	82 23       	and	r24, r18
    1742:	80 83       	st	Z, r24
        
        //Init forward PWM settings
        *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
    1744:	af 81       	ldd	r26, Y+7	; 0x07
    1746:	b8 85       	ldd	r27, Y+8	; 0x08
    1748:	15 96       	adiw	r26, 0x05	; 5
    174a:	ed 91       	ld	r30, X+
    174c:	fc 91       	ld	r31, X
    174e:	16 97       	sbiw	r26, 0x06	; 6
    1750:	10 82       	st	Z, r1
        *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
    1752:	18 96       	adiw	r26, 0x08	; 8
    1754:	ed 91       	ld	r30, X+
    1756:	fc 91       	ld	r31, X
    1758:	19 97       	sbiw	r26, 0x09	; 9
    175a:	10 82       	st	Z, r1
        *m->fwd_OCR_addr = 0x00; //Init PWM to zero
    175c:	1b 96       	adiw	r26, 0x0b	; 11
    175e:	ed 91       	ld	r30, X+
    1760:	fc 91       	ld	r31, X
    1762:	1c 97       	sbiw	r26, 0x0c	; 12
    1764:	10 82       	st	Z, r1
        
        //Init reverse PWM settings
        *m->rev_TCCRA_addr = 0x00;//m.rev_TCCRA_value;
    1766:	52 96       	adiw	r26, 0x12	; 18
    1768:	ed 91       	ld	r30, X+
    176a:	fc 91       	ld	r31, X
    176c:	53 97       	sbiw	r26, 0x13	; 19
    176e:	10 82       	st	Z, r1
        *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
    1770:	55 96       	adiw	r26, 0x15	; 21
    1772:	ed 91       	ld	r30, X+
    1774:	fc 91       	ld	r31, X
    1776:	56 97       	sbiw	r26, 0x16	; 22
    1778:	10 82       	st	Z, r1
        *m->rev_OCR_addr = 0x00; //Init PWM to zero
    177a:	58 96       	adiw	r26, 0x18	; 24
    177c:	ed 91       	ld	r30, X+
    177e:	fc 91       	ld	r31, X
    1780:	59 97       	sbiw	r26, 0x19	; 25
    1782:	10 82       	st	Z, r1
    1784:	ef e3       	ldi	r30, 0x3F	; 63
    1786:	fc e9       	ldi	r31, 0x9C	; 156
    1788:	31 97       	sbiw	r30, 0x01	; 1
    178a:	f1 f7       	brne	.-4      	; 0x1788 <initMotor+0x156>
    178c:	00 c0       	rjmp	.+0      	; 0x178e <initMotor+0x15c>
    178e:	00 00       	nop
    */
}

//returns motor actuator length in millimeters
uint16_t getActuatorLength(volatile motor *m){
    uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
    1790:	5f 96       	adiw	r26, 0x1f	; 31
    1792:	8c 91       	ld	r24, X
    1794:	44 e0       	ldi	r20, 0x04	; 4
    1796:	60 e4       	ldi	r22, 0x40	; 64
    1798:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <AVGVoltage>
    179c:	2c 01       	movw	r4, r24
    179e:	61 2c       	mov	r6, r1
    17a0:	71 2c       	mov	r7, r1
    //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
    voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
    17a2:	ef 81       	ldd	r30, Y+7	; 0x07
    17a4:	f8 85       	ldd	r31, Y+8	; 0x08
    17a6:	e1 5a       	subi	r30, 0xA1	; 161
    17a8:	ff 4f       	sbci	r31, 0xFF	; 255
    17aa:	20 81       	ld	r18, Z
    17ac:	31 81       	ldd	r19, Z+1	; 0x01
    17ae:	3c 83       	std	Y+4, r19	; 0x04
    17b0:	2b 83       	std	Y+3, r18	; 0x03
//  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
    17b2:	ef 81       	ldd	r30, Y+7	; 0x07
    17b4:	f8 85       	ldd	r31, Y+8	; 0x08
    17b6:	e4 5b       	subi	r30, 0xB4	; 180
    17b8:	ff 4f       	sbci	r31, 0xFF	; 255
    17ba:	60 81       	ld	r22, Z
    17bc:	71 81       	ldd	r23, Z+1	; 0x01
    17be:	ef 81       	ldd	r30, Y+7	; 0x07
    17c0:	f8 85       	ldd	r31, Y+8	; 0x08
    17c2:	e0 5b       	subi	r30, 0xB0	; 176
    17c4:	ff 4f       	sbci	r31, 0xFF	; 255
    17c6:	80 80       	ld	r8, Z
    17c8:	91 80       	ldd	r9, Z+1	; 0x01
    17ca:	a2 80       	ldd	r10, Z+2	; 0x02
    17cc:	b3 80       	ldd	r11, Z+3	; 0x03
    17ce:	ef 81       	ldd	r30, Y+7	; 0x07
    17d0:	f8 85       	ldd	r31, Y+8	; 0x08
    17d2:	ed 59       	subi	r30, 0x9D	; 157
    17d4:	ff 4f       	sbci	r31, 0xFF	; 255
    17d6:	20 81       	ld	r18, Z
    17d8:	31 81       	ldd	r19, Z+1	; 0x01
    17da:	80 e0       	ldi	r24, 0x00	; 0
    17dc:	90 e0       	ldi	r25, 0x00	; 0
    17de:	2d 83       	std	Y+5, r18	; 0x05
    17e0:	3e 83       	std	Y+6, r19	; 0x06
    17e2:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    17e6:	6b 01       	movw	r12, r22
    17e8:	7c 01       	movw	r14, r24
    17ea:	2d 81       	ldd	r18, Y+5	; 0x05
    17ec:	3e 81       	ldd	r19, Y+6	; 0x06
    17ee:	b9 01       	movw	r22, r18
    17f0:	80 e0       	ldi	r24, 0x00	; 0
    17f2:	90 e0       	ldi	r25, 0x00	; 0
    17f4:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    17f8:	9b 01       	movw	r18, r22
    17fa:	ac 01       	movw	r20, r24
    17fc:	c5 01       	movw	r24, r10
    17fe:	b4 01       	movw	r22, r8
    1800:	0e 94 41 1a 	call	0x3482	; 0x3482 <__divsf3>
    1804:	4b 01       	movw	r8, r22
    1806:	5c 01       	movw	r10, r24

//returns motor actuator length in millimeters
uint16_t getActuatorLength(volatile motor *m){
    uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
    //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
    voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
    1808:	c3 01       	movw	r24, r6
    180a:	b2 01       	movw	r22, r4
    180c:	4b 81       	ldd	r20, Y+3	; 0x03
    180e:	5c 81       	ldd	r21, Y+4	; 0x04
    1810:	64 1b       	sub	r22, r20
    1812:	75 0b       	sbc	r23, r21
    1814:	81 09       	sbc	r24, r1
    1816:	91 09       	sbc	r25, r1
//  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
    1818:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__floatunsisf>
    181c:	9b 01       	movw	r18, r22
    181e:	ac 01       	movw	r20, r24
    1820:	c5 01       	movw	r24, r10
    1822:	b4 01       	movw	r22, r8
    1824:	0e 94 b7 1b 	call	0x376e	; 0x376e <__mulsf3>
    1828:	9b 01       	movw	r18, r22
    182a:	ac 01       	movw	r20, r24
    182c:	c7 01       	movw	r24, r14
    182e:	b6 01       	movw	r22, r12
    1830:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
    1834:	0e 94 a9 1a 	call	0x3552	; 0x3552 <__fixunssfsi>
    1838:	6b 01       	movw	r12, r22
    183a:	7c 01       	movw	r14, r24
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
    183c:	ef 81       	ldd	r30, Y+7	; 0x07
    183e:	f8 85       	ldd	r31, Y+8	; 0x08
    1840:	ea 5a       	subi	r30, 0xAA	; 170
    1842:	ff 4f       	sbci	r31, 0xFF	; 255
    1844:	20 81       	ld	r18, Z
    1846:	31 81       	ldd	r19, Z+1	; 0x01
        m->status = MAX_LIMIT;
    1848:	ef 81       	ldd	r30, Y+7	; 0x07
    184a:	f8 85       	ldd	r31, Y+8	; 0x08
    uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); //volts per degree
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
    184c:	62 17       	cp	r22, r18
    184e:	73 07       	cpc	r23, r19
    1850:	08 f0       	brcs	.+2      	; 0x1854 <initMotor+0x222>
    1852:	53 c0       	rjmp	.+166    	; 0x18fa <initMotor+0x2c8>
        m->status = MAX_LIMIT;
        motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
    }
    else if(length <= m->actuator_min_limit){
    1854:	ec 5a       	subi	r30, 0xAC	; 172
    1856:	ff 4f       	sbci	r31, 0xFF	; 255
    1858:	20 81       	ld	r18, Z
    185a:	31 81       	ldd	r19, Z+1	; 0x01
    185c:	26 17       	cp	r18, r22
    185e:	37 07       	cpc	r19, r23
    1860:	68 f0       	brcs	.+26     	; 0x187c <initMotor+0x24a>
        m->status = MIN_LIMIT;
    1862:	ef 81       	ldd	r30, Y+7	; 0x07
    1864:	f8 85       	ldd	r31, Y+8	; 0x08
    1866:	e4 5a       	subi	r30, 0xA4	; 164
    1868:	ff 4f       	sbci	r31, 0xFF	; 255
    186a:	84 e0       	ldi	r24, 0x04	; 4
    186c:	80 83       	st	Z, r24
        motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
    186e:	ef 81       	ldd	r30, Y+7	; 0x07
    1870:	f8 85       	ldd	r31, Y+8	; 0x08
    1872:	64 a5       	ldd	r22, Z+44	; 0x2c
    1874:	40 e0       	ldi	r20, 0x00	; 0
    1876:	89 81       	ldd	r24, Y+1	; 0x01
    1878:	9a 81       	ldd	r25, Y+2	; 0x02
    187a:	e3 d8       	rcall	.-3642   	; 0xa42 <motorControl>
//extern motor motors[NUM_OF_MOTORS];

//returns motor final calculated position in degrees
float getMotorPosition(volatile motor *m){
    uint16_t alen = getActuatorLength(m);
    float aoffset = m->angle_correction(alen);
    187c:	f5 e6       	ldi	r31, 0x65	; 101
    187e:	f2 9d       	mul	r31, r2
    1880:	90 01       	movw	r18, r0
    1882:	f3 9d       	mul	r31, r3
    1884:	30 0d       	add	r19, r0
    1886:	11 24       	eor	r1, r1
    1888:	a9 01       	movw	r20, r18
    188a:	42 5f       	subi	r20, 0xF2	; 242
    188c:	5e 4f       	sbci	r21, 0xFE	; 254
    188e:	5a 01       	movw	r10, r20
    1890:	fa 01       	movw	r30, r20
    1892:	e3 5a       	subi	r30, 0xA3	; 163
    1894:	ff 4f       	sbci	r31, 0xFF	; 255
    1896:	01 90       	ld	r0, Z+
    1898:	f0 81       	ld	r31, Z
    189a:	e0 2d       	mov	r30, r0
    189c:	c6 01       	movw	r24, r12
    189e:	09 95       	icall
    return m->angle_reference + aoffset;
    18a0:	f5 01       	movw	r30, r10
    18a2:	e8 5b       	subi	r30, 0xB8	; 184
    18a4:	ff 4f       	sbci	r31, 0xFF	; 255
    18a6:	20 81       	ld	r18, Z
    18a8:	31 81       	ldd	r19, Z+1	; 0x01
    18aa:	42 81       	ldd	r20, Z+2	; 0x02
    18ac:	53 81       	ldd	r21, Z+3	; 0x03
    18ae:	0e 94 b1 19 	call	0x3362	; 0x3362 <__addsf3>
        //*m.actuator_1_dir_addr |= 1<<m.actuator_1_pin;
        //*m.actuator_2_port_addr &= ~(1<<m.actuator_2_pin);
        //*m.actuator_2_dir_addr |= 1<<m.actuator_2_pin;
        _delay_ms(10); //wait 10ms so ADC pins settle.

        m->current_position = getMotorPosition(m);
    18b2:	d5 01       	movw	r26, r10
    18b4:	9d 96       	adiw	r26, 0x2d	; 45
    18b6:	6d 93       	st	X+, r22
    18b8:	7d 93       	st	X+, r23
    18ba:	8d 93       	st	X+, r24
    18bc:	9c 93       	st	X, r25
    18be:	d0 97       	sbiw	r26, 0x30	; 48
        m->set_position = m->current_position; //reset settings
    18c0:	9d 96       	adiw	r26, 0x2d	; 45
    18c2:	8d 91       	ld	r24, X+
    18c4:	9d 91       	ld	r25, X+
    18c6:	0d 90       	ld	r0, X+
    18c8:	bc 91       	ld	r27, X
    18ca:	a0 2d       	mov	r26, r0
    18cc:	f5 01       	movw	r30, r10
    18ce:	81 ab       	std	Z+49, r24	; 0x31
    18d0:	92 ab       	std	Z+50, r25	; 0x32
    18d2:	a3 ab       	std	Z+51, r26	; 0x33
    18d4:	b4 ab       	std	Z+52, r27	; 0x34
    18d6:	29 81       	ldd	r18, Y+1	; 0x01
    18d8:	3a 81       	ldd	r19, Y+2	; 0x02
    18da:	2b 59       	subi	r18, 0x9B	; 155
    18dc:	3f 4f       	sbci	r19, 0xFF	; 255
    18de:	3a 83       	std	Y+2, r19	; 0x02
    18e0:	29 83       	std	Y+1, r18	; 0x01
    port = debugport;
    //motors[ANGLE_MOTOR] = m1;
    //motors[TILT_MOTOR] = m1;


    for(uint8_t i = 0; i<NUM_OF_MOTORS; i++){
    18e2:	31 e0       	ldi	r19, 0x01	; 1
    18e4:	23 16       	cp	r2, r19
    18e6:	31 04       	cpc	r3, r1
    18e8:	21 f4       	brne	.+8      	; 0x18f2 <initMotor+0x2c0>
        //Update motor positions
    //motors[ANGLE_MOTOR].current_position = getAngle();
    //motors[TILT_MOTOR].current_position  = getTilt();    
    
   // GTCCR = 0x00;       //Start Counter
}
    18ea:	28 96       	adiw	r28, 0x08	; 8
    18ec:	e2 e1       	ldi	r30, 0x12	; 18
    18ee:	0c 94 c1 1c 	jmp	0x3982	; 0x3982 <__epilogue_restores__>
    18f2:	22 24       	eor	r2, r2
    18f4:	23 94       	inc	r2
    18f6:	31 2c       	mov	r3, r1
    18f8:	ae ce       	rjmp	.-676    	; 0x1656 <initMotor+0x24>
    //                        B 340               200                 669                  -    348                 * 500
    // 594                                         200/320 = 0.625*(500-348) => 95:

    //Shutdown if we cross virtual limit
    if (length >= m->actuator_max_limit){
        m->status = MAX_LIMIT;
    18fa:	e4 5a       	subi	r30, 0xA4	; 164
    18fc:	ff 4f       	sbci	r31, 0xFF	; 255
    18fe:	55 e0       	ldi	r21, 0x05	; 5
    1900:	50 83       	st	Z, r21
        motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
    1902:	af 81       	ldd	r26, Y+7	; 0x07
    1904:	b8 85       	ldd	r27, Y+8	; 0x08
    1906:	9c 96       	adiw	r26, 0x2c	; 44
    1908:	6c 91       	ld	r22, X
    190a:	40 e0       	ldi	r20, 0x00	; 0
    190c:	89 81       	ldd	r24, Y+1	; 0x01
    190e:	9a 81       	ldd	r25, Y+2	; 0x02
    1910:	98 d8       	rcall	.-3792   	; 0xa42 <motorControl>
    1912:	b4 cf       	rjmp	.-152    	; 0x187c <initMotor+0x24a>

00001914 <read_until_line_end>:

/*
    Reads ring buffer until it finds linefeed, carrier return or ring buffer is empty.
*/
void read_until_line_end(void){
    while(buffer[ring_read] != '\n' &&  buffer[ring_read] != '\r'  && ring_read != ring_write){
    1914:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1918:	f0 e0       	ldi	r31, 0x00	; 0
    191a:	e6 51       	subi	r30, 0x16	; 22
    191c:	fd 4f       	sbci	r31, 0xFD	; 253
    191e:	80 81       	ld	r24, Z
    1920:	8a 30       	cpi	r24, 0x0A	; 10
    1922:	a1 f0       	breq	.+40     	; 0x194c <read_until_line_end+0x38>
    1924:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1928:	f0 e0       	ldi	r31, 0x00	; 0
    192a:	e6 51       	subi	r30, 0x16	; 22
    192c:	fd 4f       	sbci	r31, 0xFD	; 253
    192e:	80 81       	ld	r24, Z
    1930:	8d 30       	cpi	r24, 0x0D	; 13
    1932:	61 f0       	breq	.+24     	; 0x194c <read_until_line_end+0x38>
    1934:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <__data_end>
    1938:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <ring_write>
    193c:	98 17       	cp	r25, r24
    193e:	31 f0       	breq	.+12     	; 0x194c <read_until_line_end+0x38>
        ring_read++;
    1940:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    1944:	8f 5f       	subi	r24, 0xFF	; 255
    1946:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__data_end>
    194a:	e4 cf       	rjmp	.-56     	; 0x1914 <read_until_line_end>
    194c:	08 95       	ret

0000194e <initSerialParser>:
/*
    Initializes serialport and clears ring buffer
    This function also takes angle and tilt global variable pointer where set angle values are stored 
*/
void initSerialParser(FILE *serialport){
    port = serialport;
    194e:	90 93 dd 02 	sts	0x02DD, r25	; 0x8002dd <port+0x1>
    1952:	80 93 dc 02 	sts	0x02DC, r24	; 0x8002dc <port>
    1956:	ea ee       	ldi	r30, 0xEA	; 234
    1958:	f2 e0       	ldi	r31, 0x02	; 2
volatile char buffer[BUFSIZE+1];

FILE *port; //Serialport to host machine

__attribute__((always_inline)) inline static void clearBuffer(volatile char *buffer,uint8_t len){
	for(uint8_t i=0;i<len;i++){	*buffer++ = '\0';}
    195a:	10 82       	st	Z, r1
    195c:	31 96       	adiw	r30, 0x01	; 1
    195e:	83 e0       	ldi	r24, 0x03	; 3
    1960:	e9 3e       	cpi	r30, 0xE9	; 233
    1962:	f8 07       	cpc	r31, r24
    1964:	d1 f7       	brne	.-12     	; 0x195a <initSerialParser+0xc>
    This function also takes angle and tilt global variable pointer where set angle values are stored 
*/
void initSerialParser(FILE *serialport){
    port = serialport;
    clearBuffer(buffer, BUFSIZE);
}
    1966:	08 95       	ret

00001968 <readInt16>:

/*
    Reads 16 bit int from ringbuffer. 
    Function must be used because serial data is stored in to ring buffer
*/
uint16_t readInt16(uint8_t start, uint8_t stop){
    1968:	a5 e0       	ldi	r26, 0x05	; 5
    196a:	b0 e0       	ldi	r27, 0x00	; 0
    196c:	ea eb       	ldi	r30, 0xBA	; 186
    196e:	fc e0       	ldi	r31, 0x0C	; 12
    1970:	0c 94 b5 1c 	jmp	0x396a	; 0x396a <__prologue_saves__+0x20>
    1974:	e8 2f       	mov	r30, r24
    char buf[5] = {'\0','\0','\0','\0','\0'};
    1976:	ce 01       	movw	r24, r28
    1978:	01 96       	adiw	r24, 0x01	; 1
    197a:	25 e0       	ldi	r18, 0x05	; 5
    197c:	dc 01       	movw	r26, r24
    197e:	1d 92       	st	X+, r1
    1980:	2a 95       	dec	r18
    1982:	e9 f7       	brne	.-6      	; 0x197e <readInt16+0x16>
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<5; i++){
        buf[i] = buffer[start++];
    1984:	41 e0       	ldi	r20, 0x01	; 1
    1986:	4e 0f       	add	r20, r30
    1988:	2e 2f       	mov	r18, r30
    198a:	30 e0       	ldi	r19, 0x00	; 0
    198c:	26 51       	subi	r18, 0x16	; 22
    198e:	3d 4f       	sbci	r19, 0xFD	; 253
    1990:	d9 01       	movw	r26, r18
    1992:	2c 91       	ld	r18, X
    1994:	29 83       	std	Y+1, r18	; 0x01
        if (start == stop){
    1996:	46 17       	cp	r20, r22
    1998:	11 f1       	breq	.+68     	; 0x19de <readInt16+0x76>
uint16_t readInt16(uint8_t start, uint8_t stop){
    char buf[5] = {'\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<5; i++){
        buf[i] = buffer[start++];
    199a:	22 e0       	ldi	r18, 0x02	; 2
    199c:	2e 0f       	add	r18, r30
    199e:	a4 2f       	mov	r26, r20
    19a0:	b0 e0       	ldi	r27, 0x00	; 0
    19a2:	a6 51       	subi	r26, 0x16	; 22
    19a4:	bd 4f       	sbci	r27, 0xFD	; 253
    19a6:	3c 91       	ld	r19, X
    19a8:	3a 83       	std	Y+2, r19	; 0x02
        if (start == stop){
    19aa:	26 17       	cp	r18, r22
    19ac:	c1 f0       	breq	.+48     	; 0x19de <readInt16+0x76>
uint16_t readInt16(uint8_t start, uint8_t stop){
    char buf[5] = {'\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<5; i++){
        buf[i] = buffer[start++];
    19ae:	33 e0       	ldi	r19, 0x03	; 3
    19b0:	3e 0f       	add	r19, r30
    19b2:	a2 2f       	mov	r26, r18
    19b4:	b0 e0       	ldi	r27, 0x00	; 0
    19b6:	a6 51       	subi	r26, 0x16	; 22
    19b8:	bd 4f       	sbci	r27, 0xFD	; 253
    19ba:	2c 91       	ld	r18, X
    19bc:	2b 83       	std	Y+3, r18	; 0x03
        if (start == stop){
    19be:	36 17       	cp	r19, r22
    19c0:	71 f0       	breq	.+28     	; 0x19de <readInt16+0x76>
uint16_t readInt16(uint8_t start, uint8_t stop){
    char buf[5] = {'\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<5; i++){
        buf[i] = buffer[start++];
    19c2:	ec 5f       	subi	r30, 0xFC	; 252
    19c4:	a3 2f       	mov	r26, r19
    19c6:	b0 e0       	ldi	r27, 0x00	; 0
    19c8:	a6 51       	subi	r26, 0x16	; 22
    19ca:	bd 4f       	sbci	r27, 0xFD	; 253
    19cc:	2c 91       	ld	r18, X
    19ce:	2c 83       	std	Y+4, r18	; 0x04
        if (start == stop){
    19d0:	e6 17       	cp	r30, r22
    19d2:	29 f0       	breq	.+10     	; 0x19de <readInt16+0x76>
uint16_t readInt16(uint8_t start, uint8_t stop){
    char buf[5] = {'\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<5; i++){
        buf[i] = buffer[start++];
    19d4:	f0 e0       	ldi	r31, 0x00	; 0
    19d6:	e6 51       	subi	r30, 0x16	; 22
    19d8:	fd 4f       	sbci	r31, 0xFD	; 253
    19da:	20 81       	ld	r18, Z
    19dc:	2d 83       	std	Y+5, r18	; 0x05
        if (start == stop){
           i = 5;
        }
    }
    return atoi(buf);
    19de:	0e 94 df 1c 	call	0x39be	; 0x39be <atoi>
}
    19e2:	25 96       	adiw	r28, 0x05	; 5
    19e4:	e2 e0       	ldi	r30, 0x02	; 2
    19e6:	0c 94 d1 1c 	jmp	0x39a2	; 0x39a2 <__epilogue_restores__+0x20>

000019ea <readFloat>:

/*
    Reads floating point value from ringbuffer. 
    Function must be used because serial data is stored in to ring buffer
*/
double readFloat(uint8_t start, uint8_t stop){
    19ea:	aa e0       	ldi	r26, 0x0A	; 10
    19ec:	b0 e0       	ldi	r27, 0x00	; 0
    19ee:	eb ef       	ldi	r30, 0xFB	; 251
    19f0:	fc e0       	ldi	r31, 0x0C	; 12
    19f2:	0c 94 b3 1c 	jmp	0x3966	; 0x3966 <__prologue_saves__+0x1c>
    19f6:	e8 2f       	mov	r30, r24
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    19f8:	8e 01       	movw	r16, r28
    19fa:	0f 5f       	subi	r16, 0xFF	; 255
    19fc:	1f 4f       	sbci	r17, 0xFF	; 255
    19fe:	8a e0       	ldi	r24, 0x0A	; 10
    1a00:	d8 01       	movw	r26, r16
    1a02:	1d 92       	st	X+, r1
    1a04:	8a 95       	dec	r24
    1a06:	e9 f7       	brne	.-6      	; 0x1a02 <readFloat+0x18>
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    1a08:	21 e0       	ldi	r18, 0x01	; 1
    1a0a:	2e 0f       	add	r18, r30
    1a0c:	8e 2f       	mov	r24, r30
    1a0e:	90 e0       	ldi	r25, 0x00	; 0
    1a10:	86 51       	subi	r24, 0x16	; 22
    1a12:	9d 4f       	sbci	r25, 0xFD	; 253
    1a14:	dc 01       	movw	r26, r24
    1a16:	8c 91       	ld	r24, X
    1a18:	89 83       	std	Y+1, r24	; 0x01
        if (start == stop){
    1a1a:	26 17       	cp	r18, r22
    1a1c:	09 f4       	brne	.+2      	; 0x1a20 <readFloat+0x36>
    1a1e:	56 c0       	rjmp	.+172    	; 0x1acc <readFloat+0xe2>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    1a20:	82 e0       	ldi	r24, 0x02	; 2
    1a22:	8e 0f       	add	r24, r30
    1a24:	a2 2f       	mov	r26, r18
    1a26:	b0 e0       	ldi	r27, 0x00	; 0
    1a28:	a6 51       	subi	r26, 0x16	; 22
    1a2a:	bd 4f       	sbci	r27, 0xFD	; 253
    1a2c:	9c 91       	ld	r25, X
    1a2e:	9a 83       	std	Y+2, r25	; 0x02
        if (start == stop){
    1a30:	86 17       	cp	r24, r22
    1a32:	09 f4       	brne	.+2      	; 0x1a36 <readFloat+0x4c>
    1a34:	4b c0       	rjmp	.+150    	; 0x1acc <readFloat+0xe2>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    1a36:	93 e0       	ldi	r25, 0x03	; 3
    1a38:	9e 0f       	add	r25, r30
    1a3a:	a8 2f       	mov	r26, r24
    1a3c:	b0 e0       	ldi	r27, 0x00	; 0
    1a3e:	a6 51       	subi	r26, 0x16	; 22
    1a40:	bd 4f       	sbci	r27, 0xFD	; 253
    1a42:	8c 91       	ld	r24, X
    1a44:	8b 83       	std	Y+3, r24	; 0x03
        if (start == stop){
    1a46:	96 17       	cp	r25, r22
    1a48:	09 f4       	brne	.+2      	; 0x1a4c <readFloat+0x62>
    1a4a:	40 c0       	rjmp	.+128    	; 0x1acc <readFloat+0xe2>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    1a4c:	84 e0       	ldi	r24, 0x04	; 4
    1a4e:	8e 0f       	add	r24, r30
    1a50:	a9 2f       	mov	r26, r25
    1a52:	b0 e0       	ldi	r27, 0x00	; 0
    1a54:	a6 51       	subi	r26, 0x16	; 22
    1a56:	bd 4f       	sbci	r27, 0xFD	; 253
    1a58:	9c 91       	ld	r25, X
    1a5a:	9c 83       	std	Y+4, r25	; 0x04
        if (start == stop){
    1a5c:	86 17       	cp	r24, r22
    1a5e:	b1 f1       	breq	.+108    	; 0x1acc <readFloat+0xe2>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    1a60:	95 e0       	ldi	r25, 0x05	; 5
    1a62:	9e 0f       	add	r25, r30
    1a64:	a8 2f       	mov	r26, r24
    1a66:	b0 e0       	ldi	r27, 0x00	; 0
    1a68:	a6 51       	subi	r26, 0x16	; 22
    1a6a:	bd 4f       	sbci	r27, 0xFD	; 253
    1a6c:	8c 91       	ld	r24, X
    1a6e:	8d 83       	std	Y+5, r24	; 0x05
        if (start == stop){
    1a70:	96 17       	cp	r25, r22
    1a72:	61 f1       	breq	.+88     	; 0x1acc <readFloat+0xe2>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    1a74:	86 e0       	ldi	r24, 0x06	; 6
    1a76:	8e 0f       	add	r24, r30
    1a78:	a9 2f       	mov	r26, r25
    1a7a:	b0 e0       	ldi	r27, 0x00	; 0
    1a7c:	a6 51       	subi	r26, 0x16	; 22
    1a7e:	bd 4f       	sbci	r27, 0xFD	; 253
    1a80:	9c 91       	ld	r25, X
    1a82:	9e 83       	std	Y+6, r25	; 0x06
        if (start == stop){
    1a84:	86 17       	cp	r24, r22
    1a86:	11 f1       	breq	.+68     	; 0x1acc <readFloat+0xe2>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    1a88:	97 e0       	ldi	r25, 0x07	; 7
    1a8a:	9e 0f       	add	r25, r30
    1a8c:	a8 2f       	mov	r26, r24
    1a8e:	b0 e0       	ldi	r27, 0x00	; 0
    1a90:	a6 51       	subi	r26, 0x16	; 22
    1a92:	bd 4f       	sbci	r27, 0xFD	; 253
    1a94:	8c 91       	ld	r24, X
    1a96:	8f 83       	std	Y+7, r24	; 0x07
        if (start == stop){
    1a98:	96 17       	cp	r25, r22
    1a9a:	c1 f0       	breq	.+48     	; 0x1acc <readFloat+0xe2>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    1a9c:	88 e0       	ldi	r24, 0x08	; 8
    1a9e:	8e 0f       	add	r24, r30
    1aa0:	a9 2f       	mov	r26, r25
    1aa2:	b0 e0       	ldi	r27, 0x00	; 0
    1aa4:	a6 51       	subi	r26, 0x16	; 22
    1aa6:	bd 4f       	sbci	r27, 0xFD	; 253
    1aa8:	9c 91       	ld	r25, X
    1aaa:	98 87       	std	Y+8, r25	; 0x08
        if (start == stop){
    1aac:	86 17       	cp	r24, r22
    1aae:	71 f0       	breq	.+28     	; 0x1acc <readFloat+0xe2>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    1ab0:	e7 5f       	subi	r30, 0xF7	; 247
    1ab2:	a8 2f       	mov	r26, r24
    1ab4:	b0 e0       	ldi	r27, 0x00	; 0
    1ab6:	a6 51       	subi	r26, 0x16	; 22
    1ab8:	bd 4f       	sbci	r27, 0xFD	; 253
    1aba:	8c 91       	ld	r24, X
    1abc:	89 87       	std	Y+9, r24	; 0x09
        if (start == stop){
    1abe:	e6 17       	cp	r30, r22
    1ac0:	29 f0       	breq	.+10     	; 0x1acc <readFloat+0xe2>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    1ac2:	f0 e0       	ldi	r31, 0x00	; 0
    1ac4:	e6 51       	subi	r30, 0x16	; 22
    1ac6:	fd 4f       	sbci	r31, 0xFD	; 253
    1ac8:	80 81       	ld	r24, Z
    1aca:	8a 87       	std	Y+10, r24	; 0x0a
        if (start == stop){
           i = 10;
        }
    }
    printf(buf);
    1acc:	1f 93       	push	r17
    1ace:	0f 93       	push	r16
    1ad0:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <printf>
    printf("\n");
    1ad4:	8a e0       	ldi	r24, 0x0A	; 10
    1ad6:	90 e0       	ldi	r25, 0x00	; 0
    1ad8:	0e 94 d9 1e 	call	0x3db2	; 0x3db2 <putchar>
    return atof(buf);
    1adc:	c8 01       	movw	r24, r16
    1ade:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <atof>
    1ae2:	0f 90       	pop	r0
    1ae4:	0f 90       	pop	r0
}
    1ae6:	2a 96       	adiw	r28, 0x0a	; 10
    1ae8:	e4 e0       	ldi	r30, 0x04	; 4
    1aea:	0c 94 cf 1c 	jmp	0x399e	; 0x399e <__epilogue_restores__+0x1c>

00001aee <findParameter>:

//Start and Stop values are pointing to Global ring buffer
uint8_t findParameter(char startchar, char stopchar, char secondstopchar, uint8_t maxlength, uint8_t *start, uint8_t *stop){
    1aee:	ef 92       	push	r14
    1af0:	ff 92       	push	r15
    1af2:	0f 93       	push	r16
    1af4:	1f 93       	push	r17
    //Find correct start character
    while(buffer[ring_read] != startchar && ring_read != ring_write){ 
    1af6:	0d c0       	rjmp	.+26     	; 0x1b12 <findParameter+0x24>
    1af8:	30 91 da 02 	lds	r19, 0x02DA	; 0x8002da <__data_end>
    1afc:	90 91 db 02 	lds	r25, 0x02DB	; 0x8002db <ring_write>
    1b00:	39 17       	cp	r19, r25
    1b02:	79 f0       	breq	.+30     	; 0x1b22 <findParameter+0x34>
        ring_read++;
    1b04:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <__data_end>
    1b08:	9f 5f       	subi	r25, 0xFF	; 255
    1b0a:	90 93 da 02 	sts	0x02DA, r25	; 0x8002da <__data_end>
        maxlength --;
    1b0e:	21 50       	subi	r18, 0x01	; 1
        if (maxlength == 0){
    1b10:	e9 f1       	breq	.+122    	; 0x1b8c <findParameter+0x9e>
}

//Start and Stop values are pointing to Global ring buffer
uint8_t findParameter(char startchar, char stopchar, char secondstopchar, uint8_t maxlength, uint8_t *start, uint8_t *stop){
    //Find correct start character
    while(buffer[ring_read] != startchar && ring_read != ring_write){ 
    1b12:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1b16:	f0 e0       	ldi	r31, 0x00	; 0
    1b18:	e6 51       	subi	r30, 0x16	; 22
    1b1a:	fd 4f       	sbci	r31, 0xFD	; 253
    1b1c:	90 81       	ld	r25, Z
    1b1e:	98 13       	cpse	r25, r24
    1b20:	eb cf       	rjmp	.-42     	; 0x1af8 <findParameter+0xa>
        maxlength --;
        if (maxlength == 0){
            return ERROR_MAX_LENGTH;
        }
    }
    if (ring_read == ring_write){
    1b22:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <__data_end>
    1b26:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <ring_write>
    1b2a:	98 17       	cp	r25, r24
    1b2c:	49 f1       	breq	.+82     	; 0x1b80 <findParameter+0x92>
        return ERROR_CANNOT_FIND;
    }

    ring_read++; ///Next character is what we are looking for
    1b2e:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    1b32:	8f 5f       	subi	r24, 0xFF	; 255
    1b34:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__data_end>

    //Find stop character
    *start = ring_read;
    1b38:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    1b3c:	f8 01       	movw	r30, r16
    1b3e:	80 83       	st	Z, r24
    1b40:	0d c0       	rjmp	.+26     	; 0x1b5c <findParameter+0x6e>
    while(buffer[ring_read] != stopchar && buffer[ring_read] != secondstopchar){ //Find next delimiter or end of line
    1b42:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1b46:	f0 e0       	ldi	r31, 0x00	; 0
    1b48:	e6 51       	subi	r30, 0x16	; 22
    1b4a:	fd 4f       	sbci	r31, 0xFD	; 253
    1b4c:	80 81       	ld	r24, Z
    1b4e:	48 17       	cp	r20, r24
    1b50:	69 f0       	breq	.+26     	; 0x1b6c <findParameter+0x7e>
        ring_read++; //Step forward
    1b52:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    1b56:	8f 5f       	subi	r24, 0xFF	; 255
    1b58:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__data_end>

    ring_read++; ///Next character is what we are looking for

    //Find stop character
    *start = ring_read;
    while(buffer[ring_read] != stopchar && buffer[ring_read] != secondstopchar){ //Find next delimiter or end of line
    1b5c:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1b60:	f0 e0       	ldi	r31, 0x00	; 0
    1b62:	e6 51       	subi	r30, 0x16	; 22
    1b64:	fd 4f       	sbci	r31, 0xFD	; 253
    1b66:	80 81       	ld	r24, Z
    1b68:	68 13       	cpse	r22, r24
    1b6a:	eb cf       	rjmp	.-42     	; 0x1b42 <findParameter+0x54>
        ring_read++; //Step forward
    }
    *stop = ring_read;
    1b6c:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    1b70:	f7 01       	movw	r30, r14
    1b72:	80 83       	st	Z, r24
    1b74:	81 e0       	ldi	r24, 0x01	; 1
    
    return FIND_SUCCESS;
}
    1b76:	1f 91       	pop	r17
    1b78:	0f 91       	pop	r16
    1b7a:	ff 90       	pop	r15
    1b7c:	ef 90       	pop	r14
    1b7e:	08 95       	ret
        if (maxlength == 0){
            return ERROR_MAX_LENGTH;
        }
    }
    if (ring_read == ring_write){
        return ERROR_CANNOT_FIND;
    1b80:	82 e0       	ldi	r24, 0x02	; 2
        ring_read++; //Step forward
    }
    *stop = ring_read;
    
    return FIND_SUCCESS;
}
    1b82:	1f 91       	pop	r17
    1b84:	0f 91       	pop	r16
    1b86:	ff 90       	pop	r15
    1b88:	ef 90       	pop	r14
    1b8a:	08 95       	ret
    //Find correct start character
    while(buffer[ring_read] != startchar && ring_read != ring_write){ 
        ring_read++;
        maxlength --;
        if (maxlength == 0){
            return ERROR_MAX_LENGTH;
    1b8c:	83 e0       	ldi	r24, 0x03	; 3
        ring_read++; //Step forward
    }
    *stop = ring_read;
    
    return FIND_SUCCESS;
}
    1b8e:	1f 91       	pop	r17
    1b90:	0f 91       	pop	r16
    1b92:	ff 90       	pop	r15
    1b94:	ef 90       	pop	r14
    1b96:	08 95       	ret

00001b98 <parseCommands>:

void parseCommands(void){
    1b98:	ac e0       	ldi	r26, 0x0C	; 12
    1b9a:	b0 e0       	ldi	r27, 0x00	; 0
    1b9c:	e2 ed       	ldi	r30, 0xD2	; 210
    1b9e:	fd e0       	ldi	r31, 0x0D	; 13
    1ba0:	0c 94 a5 1c 	jmp	0x394a	; 0x394a <__prologue_saves__>
                fprintf(port, "ERR\n");
            }
            read_until_line_end();
        }
        else if (command == 'S'){ //Read both motor status
            fprintf(port,"S:%d:%d\n",getAngleMotorStatus(), getTiltMotorStatus());
    1ba4:	80 ed       	ldi	r24, 0xD0	; 208
    1ba6:	c8 2e       	mov	r12, r24
    1ba8:	82 e0       	ldi	r24, 0x02	; 2
    1baa:	d8 2e       	mov	r13, r24
        else if (command == 'A'){ //ADC read voltage, commands A0\n  A1\n ,A2\n ,A3\n ,A4\n and so on are possible
            //ring_read++;
            char buff[2];
            clearBuffer(buff, 2);
            buff[0] = buffer[ring_read];
            uint8_t channel = atoi(buff);
    1bac:	9e 01       	movw	r18, r28
    1bae:	2f 5f       	subi	r18, 0xFF	; 255
    1bb0:	3f 4f       	sbci	r19, 0xFF	; 255
    1bb2:	79 01       	movw	r14, r18
                fprintf(port, "A%d:%d\n", channel, GetVoltage(channel, 0x40));
            }
            else if (channel == 8){
                fprintf(port,"A");
                for (uint8_t i=0; i<8; i++){
                    fprintf(port, "%d:%d:", i, GetVoltage(i, 0x40));
    1bb4:	09 ec       	ldi	r16, 0xC9	; 201
    1bb6:	12 e0       	ldi	r17, 0x02	; 2
            char buff[2];
            clearBuffer(buff, 2);
            buff[0] = buffer[ring_read];
            uint8_t channel = atoi(buff);
            if (channel < 8){
                fprintf(port, "A%d:%d\n", channel, GetVoltage(channel, 0x40));
    1bb8:	91 ec       	ldi	r25, 0xC1	; 193
    1bba:	a9 2e       	mov	r10, r25
    1bbc:	92 e0       	ldi	r25, 0x02	; 2
    1bbe:	b9 2e       	mov	r11, r25
            }
            else if (value == '4'){ //get motor statuses
                fprintf(port, "G4:%d:%d\n", getAngleMotorStatus(), getTiltMotorStatus());
            }
            else if (value == '5'){
                fprintf(port, "G5:%d:%d\n", getAngleActuatorCurrentLength(), getTiltActuatorCurrentLength());
    1bc0:	27 eb       	ldi	r18, 0xB7	; 183
    1bc2:	82 2e       	mov	r8, r18
    1bc4:	22 e0       	ldi	r18, 0x02	; 2
    1bc6:	92 2e       	mov	r9, r18
            uint8_t value = buffer[ring_read++]; 
            if (value == '1'){ //Rread generic info
                fprintf(port,"G1:%d\n", SW_VERSION);
            }
            else if (value == '2'){ //Read current angle and tilt set_values
                fprintf(port,"G2:%5.2f:%5.2f\n", getSetAngle(), getSetTilt());
    1bc8:	3d e8       	ldi	r19, 0x8D	; 141
    1bca:	43 2e       	mov	r4, r19
    1bcc:	32 e0       	ldi	r19, 0x02	; 2
    1bce:	53 2e       	mov	r5, r19
            read_until_line_end();
        }
        else if (command == 'G'){ //Get values
            uint8_t value = buffer[ring_read++]; 
            if (value == '1'){ //Rread generic info
                fprintf(port,"G1:%d\n", SW_VERSION);
    1bd0:	46 e8       	ldi	r20, 0x86	; 134
    1bd2:	64 2e       	mov	r6, r20
    1bd4:	42 e0       	ldi	r20, 0x02	; 2
    1bd6:	74 2e       	mov	r7, r20
    
    return FIND_SUCCESS;
}

void parseCommands(void){
    while (ring_read != ring_write){
    1bd8:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <__data_end>
    1bdc:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <ring_write>
    1be0:	98 17       	cp	r25, r24
    1be2:	09 f4       	brne	.+2      	; 0x1be6 <parseCommands+0x4e>
    1be4:	5a c0       	rjmp	.+180    	; 0x1c9a <parseCommands+0x102>
        uint8_t command = buffer[ring_read++];
    1be6:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1bea:	81 e0       	ldi	r24, 0x01	; 1
    1bec:	8e 0f       	add	r24, r30
    1bee:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__data_end>
    1bf2:	f0 e0       	ldi	r31, 0x00	; 0
    1bf4:	e6 51       	subi	r30, 0x16	; 22
    1bf6:	fd 4f       	sbci	r31, 0xFD	; 253
    1bf8:	80 81       	ld	r24, Z
        if (command == 'P'){ //PUT new values command: P1:20:40    last  angle:tilt
    1bfa:	80 35       	cpi	r24, 0x50	; 80
    1bfc:	09 f4       	brne	.+2      	; 0x1c00 <parseCommands+0x68>
    1bfe:	51 c0       	rjmp	.+162    	; 0x1ca2 <parseCommands+0x10a>
            else{
                fprintf(port,"ERR\n");
            }
            read_until_line_end();
        }
        else if (command == 'G'){ //Get values
    1c00:	87 34       	cpi	r24, 0x47	; 71
    1c02:	09 f4       	brne	.+2      	; 0x1c06 <parseCommands+0x6e>
    1c04:	82 c0       	rjmp	.+260    	; 0x1d0a <parseCommands+0x172>
            else{
                fprintf(port,"ERR\n");
            }
            read_until_line_end();
        }
        else if (command == 'A'){ //ADC read voltage, commands A0\n  A1\n ,A2\n ,A3\n ,A4\n and so on are possible
    1c06:	81 34       	cpi	r24, 0x41	; 65
    1c08:	09 f4       	brne	.+2      	; 0x1c0c <parseCommands+0x74>
    1c0a:	c3 c0       	rjmp	.+390    	; 0x1d92 <parseCommands+0x1fa>
            else{
                fprintf(port, "ERR\n");
            }
            read_until_line_end();
        }
        else if (command == 'S'){ //Read both motor status
    1c0c:	83 35       	cpi	r24, 0x53	; 83
    1c0e:	21 f7       	brne	.-56     	; 0x1bd8 <parseCommands+0x40>
            fprintf(port,"S:%d:%d\n",getAngleMotorStatus(), getTiltMotorStatus());
    1c10:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <getTiltMotorStatus>
    1c14:	8b 87       	std	Y+11, r24	; 0x0b
    1c16:	0e 94 59 04 	call	0x8b2	; 0x8b2 <getAngleMotorStatus>
    1c1a:	1f 92       	push	r1
    1c1c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c1e:	9f 93       	push	r25
    1c20:	1f 92       	push	r1
    1c22:	8f 93       	push	r24
    1c24:	df 92       	push	r13
    1c26:	cf 92       	push	r12
    1c28:	80 91 dd 02 	lds	r24, 0x02DD	; 0x8002dd <port+0x1>
    1c2c:	8f 93       	push	r24
    1c2e:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <port>
    1c32:	8f 93       	push	r24
    1c34:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <fprintf>

/*
    Reads ring buffer until it finds linefeed, carrier return or ring buffer is empty.
*/
void read_until_line_end(void){
    while(buffer[ring_read] != '\n' &&  buffer[ring_read] != '\r'  && ring_read != ring_write){
    1c38:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1c3c:	f0 e0       	ldi	r31, 0x00	; 0
    1c3e:	e6 51       	subi	r30, 0x16	; 22
    1c40:	fd 4f       	sbci	r31, 0xFD	; 253
    1c42:	80 81       	ld	r24, Z
    1c44:	0f b6       	in	r0, 0x3f	; 63
    1c46:	f8 94       	cli
    1c48:	de bf       	out	0x3e, r29	; 62
    1c4a:	0f be       	out	0x3f, r0	; 63
    1c4c:	cd bf       	out	0x3d, r28	; 61
    1c4e:	8a 30       	cpi	r24, 0x0A	; 10
    1c50:	b1 f4       	brne	.+44     	; 0x1c7e <parseCommands+0xe6>
    1c52:	c2 cf       	rjmp	.-124    	; 0x1bd8 <parseCommands+0x40>
    1c54:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <__data_end>
    1c58:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <ring_write>
    1c5c:	98 17       	cp	r25, r24
    1c5e:	09 f4       	brne	.+2      	; 0x1c62 <parseCommands+0xca>
    1c60:	bb cf       	rjmp	.-138    	; 0x1bd8 <parseCommands+0x40>
        ring_read++;
    1c62:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    1c66:	8f 5f       	subi	r24, 0xFF	; 255
    1c68:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__data_end>

/*
    Reads ring buffer until it finds linefeed, carrier return or ring buffer is empty.
*/
void read_until_line_end(void){
    while(buffer[ring_read] != '\n' &&  buffer[ring_read] != '\r'  && ring_read != ring_write){
    1c6c:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1c70:	f0 e0       	ldi	r31, 0x00	; 0
    1c72:	e6 51       	subi	r30, 0x16	; 22
    1c74:	fd 4f       	sbci	r31, 0xFD	; 253
    1c76:	80 81       	ld	r24, Z
    1c78:	8a 30       	cpi	r24, 0x0A	; 10
    1c7a:	09 f4       	brne	.+2      	; 0x1c7e <parseCommands+0xe6>
    1c7c:	ad cf       	rjmp	.-166    	; 0x1bd8 <parseCommands+0x40>
    1c7e:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1c82:	f0 e0       	ldi	r31, 0x00	; 0
    1c84:	e6 51       	subi	r30, 0x16	; 22
    1c86:	fd 4f       	sbci	r31, 0xFD	; 253
    1c88:	80 81       	ld	r24, Z
    1c8a:	8d 30       	cpi	r24, 0x0D	; 13
    1c8c:	19 f7       	brne	.-58     	; 0x1c54 <parseCommands+0xbc>
    
    return FIND_SUCCESS;
}

void parseCommands(void){
    while (ring_read != ring_write){
    1c8e:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <__data_end>
    1c92:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <ring_write>
    1c96:	98 13       	cpse	r25, r24
    1c98:	a6 cf       	rjmp	.-180    	; 0x1be6 <parseCommands+0x4e>
        else if (command == 'S'){ //Read both motor status
            fprintf(port,"S:%d:%d\n",getAngleMotorStatus(), getTiltMotorStatus());
            read_until_line_end();    
        }
    }
}
    1c9a:	2c 96       	adiw	r28, 0x0c	; 12
    1c9c:	e2 e1       	ldi	r30, 0x12	; 18
    1c9e:	0c 94 c1 1c 	jmp	0x3982	; 0x3982 <__epilogue_restores__>
        uint8_t command = buffer[ring_read++];
        if (command == 'P'){ //PUT new values command: P1:20:40    last  angle:tilt
            uint8_t start = 0;
            uint8_t stop = 0;
                
            if (buffer[ring_read] == '1'){
    1ca2:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1ca6:	f0 e0       	ldi	r31, 0x00	; 0
    1ca8:	e6 51       	subi	r30, 0x16	; 22
    1caa:	fd 4f       	sbci	r31, 0xFD	; 253
    1cac:	80 81       	ld	r24, Z
    1cae:	81 33       	cpi	r24, 0x31	; 49
    1cb0:	09 f4       	brne	.+2      	; 0x1cb4 <parseCommands+0x11c>
    1cb2:	ad c0       	rjmp	.+346    	; 0x1e0e <parseCommands+0x276>
                            else{
                                fprintf(port, "ERR\n");
                            }
                        }
                        else{
                            fprintf(port, "ERR\n");
    1cb4:	20 91 dc 02 	lds	r18, 0x02DC	; 0x8002dc <port>
    1cb8:	30 91 dd 02 	lds	r19, 0x02DD	; 0x8002dd <port+0x1>
    1cbc:	44 e0       	ldi	r20, 0x04	; 4
    1cbe:	50 e0       	ldi	r21, 0x00	; 0
    1cc0:	61 e0       	ldi	r22, 0x01	; 1
    1cc2:	70 e0       	ldi	r23, 0x00	; 0
    1cc4:	84 e7       	ldi	r24, 0x74	; 116
    1cc6:	92 e0       	ldi	r25, 0x02	; 2
    1cc8:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <fwrite>
    1ccc:	15 c0       	rjmp	.+42     	; 0x1cf8 <parseCommands+0x160>

/*
    Reads ring buffer until it finds linefeed, carrier return or ring buffer is empty.
*/
void read_until_line_end(void){
    while(buffer[ring_read] != '\n' &&  buffer[ring_read] != '\r'  && ring_read != ring_write){
    1cce:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1cd2:	f0 e0       	ldi	r31, 0x00	; 0
    1cd4:	e6 51       	subi	r30, 0x16	; 22
    1cd6:	fd 4f       	sbci	r31, 0xFD	; 253
    1cd8:	80 81       	ld	r24, Z
    1cda:	8d 30       	cpi	r24, 0x0D	; 13
    1cdc:	09 f4       	brne	.+2      	; 0x1ce0 <parseCommands+0x148>
    1cde:	7c cf       	rjmp	.-264    	; 0x1bd8 <parseCommands+0x40>
    1ce0:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <__data_end>
    1ce4:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <ring_write>
    1ce8:	98 17       	cp	r25, r24
    1cea:	09 f4       	brne	.+2      	; 0x1cee <parseCommands+0x156>
    1cec:	75 cf       	rjmp	.-278    	; 0x1bd8 <parseCommands+0x40>
        ring_read++;
    1cee:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    1cf2:	8f 5f       	subi	r24, 0xFF	; 255
    1cf4:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__data_end>

/*
    Reads ring buffer until it finds linefeed, carrier return or ring buffer is empty.
*/
void read_until_line_end(void){
    while(buffer[ring_read] != '\n' &&  buffer[ring_read] != '\r'  && ring_read != ring_write){
    1cf8:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1cfc:	f0 e0       	ldi	r31, 0x00	; 0
    1cfe:	e6 51       	subi	r30, 0x16	; 22
    1d00:	fd 4f       	sbci	r31, 0xFD	; 253
    1d02:	80 81       	ld	r24, Z
    1d04:	8a 30       	cpi	r24, 0x0A	; 10
    1d06:	19 f7       	brne	.-58     	; 0x1cce <parseCommands+0x136>
    1d08:	67 cf       	rjmp	.-306    	; 0x1bd8 <parseCommands+0x40>
                fprintf(port,"ERR\n");
            }
            read_until_line_end();
        }
        else if (command == 'G'){ //Get values
            uint8_t value = buffer[ring_read++]; 
    1d0a:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1d0e:	81 e0       	ldi	r24, 0x01	; 1
    1d10:	8e 0f       	add	r24, r30
    1d12:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__data_end>
    1d16:	f0 e0       	ldi	r31, 0x00	; 0
    1d18:	e6 51       	subi	r30, 0x16	; 22
    1d1a:	fd 4f       	sbci	r31, 0xFD	; 253
    1d1c:	80 81       	ld	r24, Z
            if (value == '1'){ //Rread generic info
    1d1e:	81 33       	cpi	r24, 0x31	; 49
    1d20:	09 f4       	brne	.+2      	; 0x1d24 <parseCommands+0x18c>
    1d22:	e8 c0       	rjmp	.+464    	; 0x1ef4 <parseCommands+0x35c>
                fprintf(port,"G1:%d\n", SW_VERSION);
            }
            else if (value == '2'){ //Read current angle and tilt set_values
    1d24:	82 33       	cpi	r24, 0x32	; 50
    1d26:	09 f4       	brne	.+2      	; 0x1d2a <parseCommands+0x192>
    1d28:	f9 c0       	rjmp	.+498    	; 0x1f1c <parseCommands+0x384>
                fprintf(port,"G2:%5.2f:%5.2f\n", getSetAngle(), getSetTilt());
            }
            else if (value == '3'){ //Reads current values from motorctrl -module, actual values
    1d2a:	83 33       	cpi	r24, 0x33	; 51
    1d2c:	09 f4       	brne	.+2      	; 0x1d30 <parseCommands+0x198>
    1d2e:	81 c2       	rjmp	.+1282   	; 0x2232 <parseCommands+0x69a>
                fprintf(port,"G3:%5.2f:%5.2f\n", getAngle(), getTilt());
            }
            else if (value == '4'){ //get motor statuses
    1d30:	84 33       	cpi	r24, 0x34	; 52
    1d32:	09 f4       	brne	.+2      	; 0x1d36 <parseCommands+0x19e>
    1d34:	96 c2       	rjmp	.+1324   	; 0x2262 <parseCommands+0x6ca>
                fprintf(port, "G4:%d:%d\n", getAngleMotorStatus(), getTiltMotorStatus());
            }
            else if (value == '5'){
    1d36:	85 33       	cpi	r24, 0x35	; 53
    1d38:	09 f4       	brne	.+2      	; 0x1d3c <parseCommands+0x1a4>
    1d3a:	93 c0       	rjmp	.+294    	; 0x1e62 <parseCommands+0x2ca>
                fprintf(port, "G5:%d:%d\n", getAngleActuatorCurrentLength(), getTiltActuatorCurrentLength());
            }
            else{
                fprintf(port,"ERR\n");
    1d3c:	20 91 dc 02 	lds	r18, 0x02DC	; 0x8002dc <port>
    1d40:	30 91 dd 02 	lds	r19, 0x02DD	; 0x8002dd <port+0x1>
    1d44:	44 e0       	ldi	r20, 0x04	; 4
    1d46:	50 e0       	ldi	r21, 0x00	; 0
    1d48:	61 e0       	ldi	r22, 0x01	; 1
    1d4a:	70 e0       	ldi	r23, 0x00	; 0
    1d4c:	84 e7       	ldi	r24, 0x74	; 116
    1d4e:	92 e0       	ldi	r25, 0x02	; 2
    1d50:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <fwrite>
    1d54:	15 c0       	rjmp	.+42     	; 0x1d80 <parseCommands+0x1e8>

/*
    Reads ring buffer until it finds linefeed, carrier return or ring buffer is empty.
*/
void read_until_line_end(void){
    while(buffer[ring_read] != '\n' &&  buffer[ring_read] != '\r'  && ring_read != ring_write){
    1d56:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1d5a:	f0 e0       	ldi	r31, 0x00	; 0
    1d5c:	e6 51       	subi	r30, 0x16	; 22
    1d5e:	fd 4f       	sbci	r31, 0xFD	; 253
    1d60:	80 81       	ld	r24, Z
    1d62:	8d 30       	cpi	r24, 0x0D	; 13
    1d64:	09 f4       	brne	.+2      	; 0x1d68 <parseCommands+0x1d0>
    1d66:	38 cf       	rjmp	.-400    	; 0x1bd8 <parseCommands+0x40>
    1d68:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <__data_end>
    1d6c:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <ring_write>
    1d70:	98 17       	cp	r25, r24
    1d72:	09 f4       	brne	.+2      	; 0x1d76 <parseCommands+0x1de>
    1d74:	31 cf       	rjmp	.-414    	; 0x1bd8 <parseCommands+0x40>
        ring_read++;
    1d76:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    1d7a:	8f 5f       	subi	r24, 0xFF	; 255
    1d7c:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__data_end>

/*
    Reads ring buffer until it finds linefeed, carrier return or ring buffer is empty.
*/
void read_until_line_end(void){
    while(buffer[ring_read] != '\n' &&  buffer[ring_read] != '\r'  && ring_read != ring_write){
    1d80:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1d84:	f0 e0       	ldi	r31, 0x00	; 0
    1d86:	e6 51       	subi	r30, 0x16	; 22
    1d88:	fd 4f       	sbci	r31, 0xFD	; 253
    1d8a:	80 81       	ld	r24, Z
    1d8c:	8a 30       	cpi	r24, 0x0A	; 10
    1d8e:	19 f7       	brne	.-58     	; 0x1d56 <parseCommands+0x1be>
    1d90:	23 cf       	rjmp	.-442    	; 0x1bd8 <parseCommands+0x40>
volatile char buffer[BUFSIZE+1];

FILE *port; //Serialport to host machine

__attribute__((always_inline)) inline static void clearBuffer(volatile char *buffer,uint8_t len){
	for(uint8_t i=0;i<len;i++){	*buffer++ = '\0';}
    1d92:	19 82       	std	Y+1, r1	; 0x01
    1d94:	1a 82       	std	Y+2, r1	; 0x02
        }
        else if (command == 'A'){ //ADC read voltage, commands A0\n  A1\n ,A2\n ,A3\n ,A4\n and so on are possible
            //ring_read++;
            char buff[2];
            clearBuffer(buff, 2);
            buff[0] = buffer[ring_read];
    1d96:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1d9a:	f0 e0       	ldi	r31, 0x00	; 0
    1d9c:	e6 51       	subi	r30, 0x16	; 22
    1d9e:	fd 4f       	sbci	r31, 0xFD	; 253
    1da0:	80 81       	ld	r24, Z
    1da2:	89 83       	std	Y+1, r24	; 0x01
            uint8_t channel = atoi(buff);
    1da4:	c7 01       	movw	r24, r14
    1da6:	0e 94 df 1c 	call	0x39be	; 0x39be <atoi>
    1daa:	1c 01       	movw	r2, r24
            if (channel < 8){
    1dac:	88 30       	cpi	r24, 0x08	; 8
    1dae:	08 f4       	brcc	.+2      	; 0x1db2 <parseCommands+0x21a>
    1db0:	3f c0       	rjmp	.+126    	; 0x1e30 <parseCommands+0x298>
                fprintf(port, "A%d:%d\n", channel, GetVoltage(channel, 0x40));
            }
            else if (channel == 8){
    1db2:	88 30       	cpi	r24, 0x08	; 8
    1db4:	09 f4       	brne	.+2      	; 0x1db8 <parseCommands+0x220>
    1db6:	6d c0       	rjmp	.+218    	; 0x1e92 <parseCommands+0x2fa>
                    fprintf(port, "%d:%d:", i, GetVoltage(i, 0x40));
                }
                fprintf(port,"\n");
            }
            else{
                fprintf(port, "ERR\n");
    1db8:	20 91 dc 02 	lds	r18, 0x02DC	; 0x8002dc <port>
    1dbc:	30 91 dd 02 	lds	r19, 0x02DD	; 0x8002dd <port+0x1>
    1dc0:	44 e0       	ldi	r20, 0x04	; 4
    1dc2:	50 e0       	ldi	r21, 0x00	; 0
    1dc4:	61 e0       	ldi	r22, 0x01	; 1
    1dc6:	70 e0       	ldi	r23, 0x00	; 0
    1dc8:	84 e7       	ldi	r24, 0x74	; 116
    1dca:	92 e0       	ldi	r25, 0x02	; 2
    1dcc:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <fwrite>
    1dd0:	15 c0       	rjmp	.+42     	; 0x1dfc <parseCommands+0x264>

/*
    Reads ring buffer until it finds linefeed, carrier return or ring buffer is empty.
*/
void read_until_line_end(void){
    while(buffer[ring_read] != '\n' &&  buffer[ring_read] != '\r'  && ring_read != ring_write){
    1dd2:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1dd6:	f0 e0       	ldi	r31, 0x00	; 0
    1dd8:	e6 51       	subi	r30, 0x16	; 22
    1dda:	fd 4f       	sbci	r31, 0xFD	; 253
    1ddc:	80 81       	ld	r24, Z
    1dde:	8d 30       	cpi	r24, 0x0D	; 13
    1de0:	09 f4       	brne	.+2      	; 0x1de4 <parseCommands+0x24c>
    1de2:	fa ce       	rjmp	.-524    	; 0x1bd8 <parseCommands+0x40>
    1de4:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <__data_end>
    1de8:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <ring_write>
    1dec:	98 17       	cp	r25, r24
    1dee:	09 f4       	brne	.+2      	; 0x1df2 <parseCommands+0x25a>
    1df0:	f3 ce       	rjmp	.-538    	; 0x1bd8 <parseCommands+0x40>
        ring_read++;
    1df2:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    1df6:	8f 5f       	subi	r24, 0xFF	; 255
    1df8:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__data_end>

/*
    Reads ring buffer until it finds linefeed, carrier return or ring buffer is empty.
*/
void read_until_line_end(void){
    while(buffer[ring_read] != '\n' &&  buffer[ring_read] != '\r'  && ring_read != ring_write){
    1dfc:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1e00:	f0 e0       	ldi	r31, 0x00	; 0
    1e02:	e6 51       	subi	r30, 0x16	; 22
    1e04:	fd 4f       	sbci	r31, 0xFD	; 253
    1e06:	80 81       	ld	r24, Z
    1e08:	8a 30       	cpi	r24, 0x0A	; 10
    1e0a:	19 f7       	brne	.-58     	; 0x1dd2 <parseCommands+0x23a>
    1e0c:	e5 ce       	rjmp	.-566    	; 0x1bd8 <parseCommands+0x40>
        if (command == 'P'){ //PUT new values command: P1:20:40    last  angle:tilt
            uint8_t start = 0;
            uint8_t stop = 0;
                
            if (buffer[ring_read] == '1'){
                if (readAutoManualState() == AUTO){    
    1e0e:	86 d2       	rcall	.+1292   	; 0x231c <readAutoManualState>
    1e10:	81 30       	cpi	r24, 0x01	; 1
    1e12:	09 f4       	brne	.+2      	; 0x1e16 <parseCommands+0x27e>
    1e14:	a6 c0       	rjmp	.+332    	; 0x1f62 <parseCommands+0x3ca>
                    else{
                        fprintf(port,"ERR\n");
                    }
                }
                else{
                    fprintf(port, "MANUAL_MODE\n");
    1e16:	20 91 dc 02 	lds	r18, 0x02DC	; 0x8002dc <port>
    1e1a:	30 91 dd 02 	lds	r19, 0x02DD	; 0x8002dd <port+0x1>
    1e1e:	4c e0       	ldi	r20, 0x0C	; 12
    1e20:	50 e0       	ldi	r21, 0x00	; 0
    1e22:	61 e0       	ldi	r22, 0x01	; 1
    1e24:	70 e0       	ldi	r23, 0x00	; 0
    1e26:	89 e7       	ldi	r24, 0x79	; 121
    1e28:	92 e0       	ldi	r25, 0x02	; 2
    1e2a:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <fwrite>
    1e2e:	64 cf       	rjmp	.-312    	; 0x1cf8 <parseCommands+0x160>
            char buff[2];
            clearBuffer(buff, 2);
            buff[0] = buffer[ring_read];
            uint8_t channel = atoi(buff);
            if (channel < 8){
                fprintf(port, "A%d:%d\n", channel, GetVoltage(channel, 0x40));
    1e30:	60 e4       	ldi	r22, 0x40	; 64
    1e32:	0e 94 c7 01 	call	0x38e	; 0x38e <GetVoltage>
    1e36:	9f 93       	push	r25
    1e38:	8f 93       	push	r24
    1e3a:	91 01       	movw	r18, r2
    1e3c:	33 27       	eor	r19, r19
    1e3e:	3f 93       	push	r19
    1e40:	2f 93       	push	r18
    1e42:	bf 92       	push	r11
    1e44:	af 92       	push	r10
    1e46:	80 91 dd 02 	lds	r24, 0x02DD	; 0x8002dd <port+0x1>
    1e4a:	8f 93       	push	r24
    1e4c:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <port>
    1e50:	8f 93       	push	r24
    1e52:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <fprintf>
    1e56:	0f b6       	in	r0, 0x3f	; 63
    1e58:	f8 94       	cli
    1e5a:	de bf       	out	0x3e, r29	; 62
    1e5c:	0f be       	out	0x3f, r0	; 63
    1e5e:	cd bf       	out	0x3d, r28	; 61
    1e60:	cd cf       	rjmp	.-102    	; 0x1dfc <parseCommands+0x264>
            }
            else if (value == '4'){ //get motor statuses
                fprintf(port, "G4:%d:%d\n", getAngleMotorStatus(), getTiltMotorStatus());
            }
            else if (value == '5'){
                fprintf(port, "G5:%d:%d\n", getAngleActuatorCurrentLength(), getTiltActuatorCurrentLength());
    1e62:	b1 d8       	rcall	.-3742   	; 0xfc6 <getTiltActuatorCurrentLength>
    1e64:	38 2e       	mov	r3, r24
    1e66:	29 2e       	mov	r2, r25
    1e68:	22 d9       	rcall	.-3516   	; 0x10ae <getAngleActuatorCurrentLength>
    1e6a:	2f 92       	push	r2
    1e6c:	3f 92       	push	r3
    1e6e:	9f 93       	push	r25
    1e70:	8f 93       	push	r24
    1e72:	9f 92       	push	r9
    1e74:	8f 92       	push	r8
    1e76:	80 91 dd 02 	lds	r24, 0x02DD	; 0x8002dd <port+0x1>
    1e7a:	8f 93       	push	r24
    1e7c:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <port>
    1e80:	8f 93       	push	r24
    1e82:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <fprintf>
    1e86:	0f b6       	in	r0, 0x3f	; 63
    1e88:	f8 94       	cli
    1e8a:	de bf       	out	0x3e, r29	; 62
    1e8c:	0f be       	out	0x3f, r0	; 63
    1e8e:	cd bf       	out	0x3d, r28	; 61
    1e90:	77 cf       	rjmp	.-274    	; 0x1d80 <parseCommands+0x1e8>
            uint8_t channel = atoi(buff);
            if (channel < 8){
                fprintf(port, "A%d:%d\n", channel, GetVoltage(channel, 0x40));
            }
            else if (channel == 8){
                fprintf(port,"A");
    1e92:	60 91 dc 02 	lds	r22, 0x02DC	; 0x8002dc <port>
    1e96:	70 91 dd 02 	lds	r23, 0x02DD	; 0x8002dd <port+0x1>
    1e9a:	81 e4       	ldi	r24, 0x41	; 65
    1e9c:	90 e0       	ldi	r25, 0x00	; 0
    1e9e:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    1ea2:	21 2c       	mov	r2, r1
    1ea4:	31 2c       	mov	r3, r1
                for (uint8_t i=0; i<8; i++){
                    fprintf(port, "%d:%d:", i, GetVoltage(i, 0x40));
    1ea6:	60 e4       	ldi	r22, 0x40	; 64
    1ea8:	82 2d       	mov	r24, r2
    1eaa:	0e 94 c7 01 	call	0x38e	; 0x38e <GetVoltage>
    1eae:	9f 93       	push	r25
    1eb0:	8f 93       	push	r24
    1eb2:	3f 92       	push	r3
    1eb4:	2f 92       	push	r2
    1eb6:	1f 93       	push	r17
    1eb8:	0f 93       	push	r16
    1eba:	80 91 dd 02 	lds	r24, 0x02DD	; 0x8002dd <port+0x1>
    1ebe:	8f 93       	push	r24
    1ec0:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <port>
    1ec4:	8f 93       	push	r24
    1ec6:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <fprintf>
    1eca:	bf ef       	ldi	r27, 0xFF	; 255
    1ecc:	2b 1a       	sub	r2, r27
    1ece:	3b 0a       	sbc	r3, r27
            if (channel < 8){
                fprintf(port, "A%d:%d\n", channel, GetVoltage(channel, 0x40));
            }
            else if (channel == 8){
                fprintf(port,"A");
                for (uint8_t i=0; i<8; i++){
    1ed0:	0f b6       	in	r0, 0x3f	; 63
    1ed2:	f8 94       	cli
    1ed4:	de bf       	out	0x3e, r29	; 62
    1ed6:	0f be       	out	0x3f, r0	; 63
    1ed8:	cd bf       	out	0x3d, r28	; 61
    1eda:	f8 e0       	ldi	r31, 0x08	; 8
    1edc:	2f 16       	cp	r2, r31
    1ede:	31 04       	cpc	r3, r1
    1ee0:	11 f7       	brne	.-60     	; 0x1ea6 <parseCommands+0x30e>
                    fprintf(port, "%d:%d:", i, GetVoltage(i, 0x40));
                }
                fprintf(port,"\n");
    1ee2:	60 91 dc 02 	lds	r22, 0x02DC	; 0x8002dc <port>
    1ee6:	70 91 dd 02 	lds	r23, 0x02DD	; 0x8002dd <port+0x1>
    1eea:	8a e0       	ldi	r24, 0x0A	; 10
    1eec:	90 e0       	ldi	r25, 0x00	; 0
    1eee:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    1ef2:	84 cf       	rjmp	.-248    	; 0x1dfc <parseCommands+0x264>
            read_until_line_end();
        }
        else if (command == 'G'){ //Get values
            uint8_t value = buffer[ring_read++]; 
            if (value == '1'){ //Rread generic info
                fprintf(port,"G1:%d\n", SW_VERSION);
    1ef4:	1f 92       	push	r1
    1ef6:	f1 e0       	ldi	r31, 0x01	; 1
    1ef8:	ff 93       	push	r31
    1efa:	7f 92       	push	r7
    1efc:	6f 92       	push	r6
    1efe:	80 91 dd 02 	lds	r24, 0x02DD	; 0x8002dd <port+0x1>
    1f02:	8f 93       	push	r24
    1f04:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <port>
    1f08:	8f 93       	push	r24
    1f0a:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <fprintf>
    1f0e:	0f 90       	pop	r0
    1f10:	0f 90       	pop	r0
    1f12:	0f 90       	pop	r0
    1f14:	0f 90       	pop	r0
    1f16:	0f 90       	pop	r0
    1f18:	0f 90       	pop	r0
    1f1a:	32 cf       	rjmp	.-412    	; 0x1d80 <parseCommands+0x1e8>
            }
            else if (value == '2'){ //Read current angle and tilt set_values
                fprintf(port,"G2:%5.2f:%5.2f\n", getSetAngle(), getSetTilt());
    1f1c:	0e 94 50 04 	call	0x8a0	; 0x8a0 <getSetTilt>
    1f20:	36 2e       	mov	r3, r22
    1f22:	27 2e       	mov	r2, r23
    1f24:	ac 01       	movw	r20, r24
    1f26:	8b 87       	std	Y+11, r24	; 0x0b
    1f28:	5c 87       	std	Y+12, r21	; 0x0c
    1f2a:	0e 94 47 04 	call	0x88e	; 0x88e <getSetAngle>
    1f2e:	5c 85       	ldd	r21, Y+12	; 0x0c
    1f30:	5f 93       	push	r21
    1f32:	4b 85       	ldd	r20, Y+11	; 0x0b
    1f34:	4f 93       	push	r20
    1f36:	2f 92       	push	r2
    1f38:	3f 92       	push	r3
    1f3a:	9f 93       	push	r25
    1f3c:	8f 93       	push	r24
    1f3e:	7f 93       	push	r23
    1f40:	6f 93       	push	r22
    1f42:	5f 92       	push	r5
    1f44:	4f 92       	push	r4
            }
            else if (value == '3'){ //Reads current values from motorctrl -module, actual values
                fprintf(port,"G3:%5.2f:%5.2f\n", getAngle(), getTilt());
    1f46:	80 91 dd 02 	lds	r24, 0x02DD	; 0x8002dd <port+0x1>
    1f4a:	8f 93       	push	r24
    1f4c:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <port>
    1f50:	8f 93       	push	r24
    1f52:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <fprintf>
    1f56:	0f b6       	in	r0, 0x3f	; 63
    1f58:	f8 94       	cli
    1f5a:	de bf       	out	0x3e, r29	; 62
    1f5c:	0f be       	out	0x3f, r0	; 63
    1f5e:	cd bf       	out	0x3d, r28	; 61
    1f60:	0f cf       	rjmp	.-482    	; 0x1d80 <parseCommands+0x1e8>
    1f62:	94 e1       	ldi	r25, 0x14	; 20
    1f64:	0e c0       	rjmp	.+28     	; 0x1f82 <parseCommands+0x3ea>
}

//Start and Stop values are pointing to Global ring buffer
uint8_t findParameter(char startchar, char stopchar, char secondstopchar, uint8_t maxlength, uint8_t *start, uint8_t *stop){
    //Find correct start character
    while(buffer[ring_read] != startchar && ring_read != ring_write){ 
    1f66:	20 91 da 02 	lds	r18, 0x02DA	; 0x8002da <__data_end>
    1f6a:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <ring_write>
    1f6e:	28 17       	cp	r18, r24
    1f70:	81 f0       	breq	.+32     	; 0x1f92 <parseCommands+0x3fa>
        ring_read++;
    1f72:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    1f76:	8f 5f       	subi	r24, 0xFF	; 255
    1f78:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__data_end>
    1f7c:	91 50       	subi	r25, 0x01	; 1
        maxlength --;
        if (maxlength == 0){
    1f7e:	09 f4       	brne	.+2      	; 0x1f82 <parseCommands+0x3ea>
    1f80:	99 ce       	rjmp	.-718    	; 0x1cb4 <parseCommands+0x11c>
}

//Start and Stop values are pointing to Global ring buffer
uint8_t findParameter(char startchar, char stopchar, char secondstopchar, uint8_t maxlength, uint8_t *start, uint8_t *stop){
    //Find correct start character
    while(buffer[ring_read] != startchar && ring_read != ring_write){ 
    1f82:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1f86:	f0 e0       	ldi	r31, 0x00	; 0
    1f88:	e6 51       	subi	r30, 0x16	; 22
    1f8a:	fd 4f       	sbci	r31, 0xFD	; 253
    1f8c:	80 81       	ld	r24, Z
    1f8e:	8a 33       	cpi	r24, 0x3A	; 58
    1f90:	51 f7       	brne	.-44     	; 0x1f66 <parseCommands+0x3ce>
        maxlength --;
        if (maxlength == 0){
            return ERROR_MAX_LENGTH;
        }
    }
    if (ring_read == ring_write){
    1f92:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <__data_end>
    1f96:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <ring_write>
    1f9a:	98 17       	cp	r25, r24
    1f9c:	09 f4       	brne	.+2      	; 0x1fa0 <parseCommands+0x408>
    1f9e:	8a ce       	rjmp	.-748    	; 0x1cb4 <parseCommands+0x11c>
        return ERROR_CANNOT_FIND;
    }

    ring_read++; ///Next character is what we are looking for
    1fa0:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    1fa4:	8f 5f       	subi	r24, 0xFF	; 255
    1fa6:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__data_end>

    //Find stop character
    *start = ring_read;
    1faa:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <__data_end>
    1fae:	0d c0       	rjmp	.+26     	; 0x1fca <parseCommands+0x432>
    while(buffer[ring_read] != stopchar && buffer[ring_read] != secondstopchar){ //Find next delimiter or end of line
    1fb0:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1fb4:	f0 e0       	ldi	r31, 0x00	; 0
    1fb6:	e6 51       	subi	r30, 0x16	; 22
    1fb8:	fd 4f       	sbci	r31, 0xFD	; 253
    1fba:	80 81       	ld	r24, Z
    1fbc:	8a 30       	cpi	r24, 0x0A	; 10
    1fbe:	69 f0       	breq	.+26     	; 0x1fda <parseCommands+0x442>
        ring_read++; //Step forward
    1fc0:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    1fc4:	8f 5f       	subi	r24, 0xFF	; 255
    1fc6:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__data_end>

    ring_read++; ///Next character is what we are looking for

    //Find stop character
    *start = ring_read;
    while(buffer[ring_read] != stopchar && buffer[ring_read] != secondstopchar){ //Find next delimiter or end of line
    1fca:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    1fce:	f0 e0       	ldi	r31, 0x00	; 0
    1fd0:	e6 51       	subi	r30, 0x16	; 22
    1fd2:	fd 4f       	sbci	r31, 0xFD	; 253
    1fd4:	80 81       	ld	r24, Z
    1fd6:	8a 33       	cpi	r24, 0x3A	; 58
    1fd8:	59 f7       	brne	.-42     	; 0x1fb0 <parseCommands+0x418>
        ring_read++; //Step forward
    }
    *stop = ring_read;
    1fda:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
/*
    Reads floating point value from ringbuffer. 
    Function must be used because serial data is stored in to ring buffer
*/
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    1fde:	2a e0       	ldi	r18, 0x0A	; 10
    1fe0:	d7 01       	movw	r26, r14
    1fe2:	1d 92       	st	X+, r1
    1fe4:	2a 95       	dec	r18
    1fe6:	e9 f7       	brne	.-6      	; 0x1fe2 <parseCommands+0x44a>
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    1fe8:	e1 e0       	ldi	r30, 0x01	; 1
    1fea:	e9 0f       	add	r30, r25
    1fec:	a9 2f       	mov	r26, r25
    1fee:	b0 e0       	ldi	r27, 0x00	; 0
    1ff0:	a6 51       	subi	r26, 0x16	; 22
    1ff2:	bd 4f       	sbci	r27, 0xFD	; 253
    1ff4:	2c 91       	ld	r18, X
    1ff6:	29 83       	std	Y+1, r18	; 0x01
        if (start == stop){
    1ff8:	8e 17       	cp	r24, r30
    1ffa:	09 f4       	brne	.+2      	; 0x1ffe <parseCommands+0x466>
    1ffc:	4e c0       	rjmp	.+156    	; 0x209a <parseCommands+0x502>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    1ffe:	a2 e0       	ldi	r26, 0x02	; 2
    2000:	a9 0f       	add	r26, r25
    2002:	f0 e0       	ldi	r31, 0x00	; 0
    2004:	e6 51       	subi	r30, 0x16	; 22
    2006:	fd 4f       	sbci	r31, 0xFD	; 253
    2008:	20 81       	ld	r18, Z
    200a:	2a 83       	std	Y+2, r18	; 0x02
        if (start == stop){
    200c:	8a 17       	cp	r24, r26
    200e:	09 f4       	brne	.+2      	; 0x2012 <parseCommands+0x47a>
    2010:	44 c0       	rjmp	.+136    	; 0x209a <parseCommands+0x502>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    2012:	e3 e0       	ldi	r30, 0x03	; 3
    2014:	e9 0f       	add	r30, r25
    2016:	b0 e0       	ldi	r27, 0x00	; 0
    2018:	a6 51       	subi	r26, 0x16	; 22
    201a:	bd 4f       	sbci	r27, 0xFD	; 253
    201c:	2c 91       	ld	r18, X
    201e:	2b 83       	std	Y+3, r18	; 0x03
        if (start == stop){
    2020:	8e 17       	cp	r24, r30
    2022:	d9 f1       	breq	.+118    	; 0x209a <parseCommands+0x502>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    2024:	a4 e0       	ldi	r26, 0x04	; 4
    2026:	a9 0f       	add	r26, r25
    2028:	f0 e0       	ldi	r31, 0x00	; 0
    202a:	e6 51       	subi	r30, 0x16	; 22
    202c:	fd 4f       	sbci	r31, 0xFD	; 253
    202e:	20 81       	ld	r18, Z
    2030:	2c 83       	std	Y+4, r18	; 0x04
        if (start == stop){
    2032:	8a 17       	cp	r24, r26
    2034:	91 f1       	breq	.+100    	; 0x209a <parseCommands+0x502>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    2036:	e5 e0       	ldi	r30, 0x05	; 5
    2038:	e9 0f       	add	r30, r25
    203a:	b0 e0       	ldi	r27, 0x00	; 0
    203c:	a6 51       	subi	r26, 0x16	; 22
    203e:	bd 4f       	sbci	r27, 0xFD	; 253
    2040:	2c 91       	ld	r18, X
    2042:	2d 83       	std	Y+5, r18	; 0x05
        if (start == stop){
    2044:	8e 17       	cp	r24, r30
    2046:	49 f1       	breq	.+82     	; 0x209a <parseCommands+0x502>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    2048:	a6 e0       	ldi	r26, 0x06	; 6
    204a:	a9 0f       	add	r26, r25
    204c:	f0 e0       	ldi	r31, 0x00	; 0
    204e:	e6 51       	subi	r30, 0x16	; 22
    2050:	fd 4f       	sbci	r31, 0xFD	; 253
    2052:	20 81       	ld	r18, Z
    2054:	2e 83       	std	Y+6, r18	; 0x06
        if (start == stop){
    2056:	8a 17       	cp	r24, r26
    2058:	01 f1       	breq	.+64     	; 0x209a <parseCommands+0x502>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    205a:	e7 e0       	ldi	r30, 0x07	; 7
    205c:	e9 0f       	add	r30, r25
    205e:	b0 e0       	ldi	r27, 0x00	; 0
    2060:	a6 51       	subi	r26, 0x16	; 22
    2062:	bd 4f       	sbci	r27, 0xFD	; 253
    2064:	2c 91       	ld	r18, X
    2066:	2f 83       	std	Y+7, r18	; 0x07
        if (start == stop){
    2068:	8e 17       	cp	r24, r30
    206a:	b9 f0       	breq	.+46     	; 0x209a <parseCommands+0x502>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    206c:	a8 e0       	ldi	r26, 0x08	; 8
    206e:	a9 0f       	add	r26, r25
    2070:	f0 e0       	ldi	r31, 0x00	; 0
    2072:	e6 51       	subi	r30, 0x16	; 22
    2074:	fd 4f       	sbci	r31, 0xFD	; 253
    2076:	20 81       	ld	r18, Z
    2078:	28 87       	std	Y+8, r18	; 0x08
        if (start == stop){
    207a:	8a 17       	cp	r24, r26
    207c:	71 f0       	breq	.+28     	; 0x209a <parseCommands+0x502>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    207e:	e9 e0       	ldi	r30, 0x09	; 9
    2080:	e9 0f       	add	r30, r25
    2082:	b0 e0       	ldi	r27, 0x00	; 0
    2084:	a6 51       	subi	r26, 0x16	; 22
    2086:	bd 4f       	sbci	r27, 0xFD	; 253
    2088:	9c 91       	ld	r25, X
    208a:	99 87       	std	Y+9, r25	; 0x09
        if (start == stop){
    208c:	8e 17       	cp	r24, r30
    208e:	29 f0       	breq	.+10     	; 0x209a <parseCommands+0x502>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    2090:	f0 e0       	ldi	r31, 0x00	; 0
    2092:	e6 51       	subi	r30, 0x16	; 22
    2094:	fd 4f       	sbci	r31, 0xFD	; 253
    2096:	80 81       	ld	r24, Z
    2098:	8a 87       	std	Y+10, r24	; 0x0a
        if (start == stop){
           i = 10;
        }
    }
    printf(buf);
    209a:	ff 92       	push	r15
    209c:	ef 92       	push	r14
    209e:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <printf>
    printf("\n");
    20a2:	8a e0       	ldi	r24, 0x0A	; 10
    20a4:	90 e0       	ldi	r25, 0x00	; 0
    20a6:	0e 94 d9 1e 	call	0x3db2	; 0x3db2 <putchar>
    return atof(buf);
    20aa:	c7 01       	movw	r24, r14
    20ac:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <atof>
                
            if (buffer[ring_read] == '1'){
                if (readAutoManualState() == AUTO){    
                    uint8_t succ = findParameter(':', ':', '\n', 20, &start, &stop);
                    if (succ == FIND_SUCCESS){
                        uint8_t asuccess = setAngle(readFloat(start, stop));
    20b0:	0e 94 7f 03 	call	0x6fe	; 0x6fe <setAngle>
    20b4:	38 2e       	mov	r3, r24
    20b6:	0f 90       	pop	r0
    20b8:	0f 90       	pop	r0
    20ba:	94 e1       	ldi	r25, 0x14	; 20
    20bc:	0e c0       	rjmp	.+28     	; 0x20da <parseCommands+0x542>
}

//Start and Stop values are pointing to Global ring buffer
uint8_t findParameter(char startchar, char stopchar, char secondstopchar, uint8_t maxlength, uint8_t *start, uint8_t *stop){
    //Find correct start character
    while(buffer[ring_read] != startchar && ring_read != ring_write){ 
    20be:	30 91 da 02 	lds	r19, 0x02DA	; 0x8002da <__data_end>
    20c2:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <ring_write>
    20c6:	38 17       	cp	r19, r24
    20c8:	81 f0       	breq	.+32     	; 0x20ea <parseCommands+0x552>
        ring_read++;
    20ca:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    20ce:	8f 5f       	subi	r24, 0xFF	; 255
    20d0:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__data_end>
    20d4:	91 50       	subi	r25, 0x01	; 1
        maxlength --;
        if (maxlength == 0){
    20d6:	09 f4       	brne	.+2      	; 0x20da <parseCommands+0x542>
    20d8:	ed cd       	rjmp	.-1062   	; 0x1cb4 <parseCommands+0x11c>
}

//Start and Stop values are pointing to Global ring buffer
uint8_t findParameter(char startchar, char stopchar, char secondstopchar, uint8_t maxlength, uint8_t *start, uint8_t *stop){
    //Find correct start character
    while(buffer[ring_read] != startchar && ring_read != ring_write){ 
    20da:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    20de:	f0 e0       	ldi	r31, 0x00	; 0
    20e0:	e6 51       	subi	r30, 0x16	; 22
    20e2:	fd 4f       	sbci	r31, 0xFD	; 253
    20e4:	80 81       	ld	r24, Z
    20e6:	8a 33       	cpi	r24, 0x3A	; 58
    20e8:	51 f7       	brne	.-44     	; 0x20be <parseCommands+0x526>
        maxlength --;
        if (maxlength == 0){
            return ERROR_MAX_LENGTH;
        }
    }
    if (ring_read == ring_write){
    20ea:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <__data_end>
    20ee:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <ring_write>
    20f2:	98 17       	cp	r25, r24
    20f4:	09 f4       	brne	.+2      	; 0x20f8 <parseCommands+0x560>
    20f6:	de cd       	rjmp	.-1092   	; 0x1cb4 <parseCommands+0x11c>
        return ERROR_CANNOT_FIND;
    }

    ring_read++; ///Next character is what we are looking for
    20f8:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    20fc:	8f 5f       	subi	r24, 0xFF	; 255
    20fe:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__data_end>

    //Find stop character
    *start = ring_read;
    2102:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <__data_end>
    2106:	0d c0       	rjmp	.+26     	; 0x2122 <parseCommands+0x58a>
    while(buffer[ring_read] != stopchar && buffer[ring_read] != secondstopchar){ //Find next delimiter or end of line
    2108:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    210c:	f0 e0       	ldi	r31, 0x00	; 0
    210e:	e6 51       	subi	r30, 0x16	; 22
    2110:	fd 4f       	sbci	r31, 0xFD	; 253
    2112:	90 81       	ld	r25, Z
    2114:	9a 30       	cpi	r25, 0x0A	; 10
    2116:	69 f0       	breq	.+26     	; 0x2132 <parseCommands+0x59a>
        ring_read++; //Step forward
    2118:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <__data_end>
    211c:	9f 5f       	subi	r25, 0xFF	; 255
    211e:	90 93 da 02 	sts	0x02DA, r25	; 0x8002da <__data_end>

    ring_read++; ///Next character is what we are looking for

    //Find stop character
    *start = ring_read;
    while(buffer[ring_read] != stopchar && buffer[ring_read] != secondstopchar){ //Find next delimiter or end of line
    2122:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__data_end>
    2126:	f0 e0       	ldi	r31, 0x00	; 0
    2128:	e6 51       	subi	r30, 0x16	; 22
    212a:	fd 4f       	sbci	r31, 0xFD	; 253
    212c:	90 81       	ld	r25, Z
    212e:	9a 33       	cpi	r25, 0x3A	; 58
    2130:	59 f7       	brne	.-42     	; 0x2108 <parseCommands+0x570>
        ring_read++; //Step forward
    }
    *stop = ring_read;
    2132:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <__data_end>
/*
    Reads floating point value from ringbuffer. 
    Function must be used because serial data is stored in to ring buffer
*/
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    2136:	3a e0       	ldi	r19, 0x0A	; 10
    2138:	f7 01       	movw	r30, r14
    213a:	11 92       	st	Z+, r1
    213c:	3a 95       	dec	r19
    213e:	e9 f7       	brne	.-6      	; 0x213a <parseCommands+0x5a2>
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    2140:	e1 e0       	ldi	r30, 0x01	; 1
    2142:	e8 0f       	add	r30, r24
    2144:	a8 2f       	mov	r26, r24
    2146:	b0 e0       	ldi	r27, 0x00	; 0
    2148:	a6 51       	subi	r26, 0x16	; 22
    214a:	bd 4f       	sbci	r27, 0xFD	; 253
    214c:	3c 91       	ld	r19, X
    214e:	39 83       	std	Y+1, r19	; 0x01
        if (start == stop){
    2150:	9e 17       	cp	r25, r30
    2152:	09 f4       	brne	.+2      	; 0x2156 <parseCommands+0x5be>
    2154:	4e c0       	rjmp	.+156    	; 0x21f2 <parseCommands+0x65a>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    2156:	a2 e0       	ldi	r26, 0x02	; 2
    2158:	a8 0f       	add	r26, r24
    215a:	f0 e0       	ldi	r31, 0x00	; 0
    215c:	e6 51       	subi	r30, 0x16	; 22
    215e:	fd 4f       	sbci	r31, 0xFD	; 253
    2160:	30 81       	ld	r19, Z
    2162:	3a 83       	std	Y+2, r19	; 0x02
        if (start == stop){
    2164:	9a 17       	cp	r25, r26
    2166:	09 f4       	brne	.+2      	; 0x216a <parseCommands+0x5d2>
    2168:	44 c0       	rjmp	.+136    	; 0x21f2 <parseCommands+0x65a>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    216a:	e3 e0       	ldi	r30, 0x03	; 3
    216c:	e8 0f       	add	r30, r24
    216e:	b0 e0       	ldi	r27, 0x00	; 0
    2170:	a6 51       	subi	r26, 0x16	; 22
    2172:	bd 4f       	sbci	r27, 0xFD	; 253
    2174:	3c 91       	ld	r19, X
    2176:	3b 83       	std	Y+3, r19	; 0x03
        if (start == stop){
    2178:	9e 17       	cp	r25, r30
    217a:	d9 f1       	breq	.+118    	; 0x21f2 <parseCommands+0x65a>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    217c:	a4 e0       	ldi	r26, 0x04	; 4
    217e:	a8 0f       	add	r26, r24
    2180:	f0 e0       	ldi	r31, 0x00	; 0
    2182:	e6 51       	subi	r30, 0x16	; 22
    2184:	fd 4f       	sbci	r31, 0xFD	; 253
    2186:	30 81       	ld	r19, Z
    2188:	3c 83       	std	Y+4, r19	; 0x04
        if (start == stop){
    218a:	9a 17       	cp	r25, r26
    218c:	91 f1       	breq	.+100    	; 0x21f2 <parseCommands+0x65a>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    218e:	e5 e0       	ldi	r30, 0x05	; 5
    2190:	e8 0f       	add	r30, r24
    2192:	b0 e0       	ldi	r27, 0x00	; 0
    2194:	a6 51       	subi	r26, 0x16	; 22
    2196:	bd 4f       	sbci	r27, 0xFD	; 253
    2198:	3c 91       	ld	r19, X
    219a:	3d 83       	std	Y+5, r19	; 0x05
        if (start == stop){
    219c:	9e 17       	cp	r25, r30
    219e:	49 f1       	breq	.+82     	; 0x21f2 <parseCommands+0x65a>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    21a0:	a6 e0       	ldi	r26, 0x06	; 6
    21a2:	a8 0f       	add	r26, r24
    21a4:	f0 e0       	ldi	r31, 0x00	; 0
    21a6:	e6 51       	subi	r30, 0x16	; 22
    21a8:	fd 4f       	sbci	r31, 0xFD	; 253
    21aa:	30 81       	ld	r19, Z
    21ac:	3e 83       	std	Y+6, r19	; 0x06
        if (start == stop){
    21ae:	9a 17       	cp	r25, r26
    21b0:	01 f1       	breq	.+64     	; 0x21f2 <parseCommands+0x65a>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    21b2:	e7 e0       	ldi	r30, 0x07	; 7
    21b4:	e8 0f       	add	r30, r24
    21b6:	b0 e0       	ldi	r27, 0x00	; 0
    21b8:	a6 51       	subi	r26, 0x16	; 22
    21ba:	bd 4f       	sbci	r27, 0xFD	; 253
    21bc:	3c 91       	ld	r19, X
    21be:	3f 83       	std	Y+7, r19	; 0x07
        if (start == stop){
    21c0:	9e 17       	cp	r25, r30
    21c2:	b9 f0       	breq	.+46     	; 0x21f2 <parseCommands+0x65a>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    21c4:	a8 e0       	ldi	r26, 0x08	; 8
    21c6:	a8 0f       	add	r26, r24
    21c8:	f0 e0       	ldi	r31, 0x00	; 0
    21ca:	e6 51       	subi	r30, 0x16	; 22
    21cc:	fd 4f       	sbci	r31, 0xFD	; 253
    21ce:	30 81       	ld	r19, Z
    21d0:	38 87       	std	Y+8, r19	; 0x08
        if (start == stop){
    21d2:	9a 17       	cp	r25, r26
    21d4:	71 f0       	breq	.+28     	; 0x21f2 <parseCommands+0x65a>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    21d6:	e9 e0       	ldi	r30, 0x09	; 9
    21d8:	e8 0f       	add	r30, r24
    21da:	b0 e0       	ldi	r27, 0x00	; 0
    21dc:	a6 51       	subi	r26, 0x16	; 22
    21de:	bd 4f       	sbci	r27, 0xFD	; 253
    21e0:	8c 91       	ld	r24, X
    21e2:	89 87       	std	Y+9, r24	; 0x09
        if (start == stop){
    21e4:	9e 17       	cp	r25, r30
    21e6:	29 f0       	breq	.+10     	; 0x21f2 <parseCommands+0x65a>
double readFloat(uint8_t start, uint8_t stop){
    char buf[10] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
    
    //clearBuffer(buf,5);
    for (uint8_t i=0; i<10; i++){
        buf[i] = buffer[start++];
    21e8:	f0 e0       	ldi	r31, 0x00	; 0
    21ea:	e6 51       	subi	r30, 0x16	; 22
    21ec:	fd 4f       	sbci	r31, 0xFD	; 253
    21ee:	80 81       	ld	r24, Z
    21f0:	8a 87       	std	Y+10, r24	; 0x0a
        if (start == stop){
           i = 10;
        }
    }
    printf(buf);
    21f2:	ff 92       	push	r15
    21f4:	ef 92       	push	r14
    21f6:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <printf>
    printf("\n");
    21fa:	8a e0       	ldi	r24, 0x0A	; 10
    21fc:	90 e0       	ldi	r25, 0x00	; 0
    21fe:	0e 94 d9 1e 	call	0x3db2	; 0x3db2 <putchar>
    return atof(buf);
    2202:	c7 01       	movw	r24, r14
    2204:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <atof>
                    uint8_t succ = findParameter(':', ':', '\n', 20, &start, &stop);
                    if (succ == FIND_SUCCESS){
                        uint8_t asuccess = setAngle(readFloat(start, stop));
                        succ = findParameter(':', ':', '\n', 20, &start, &stop);
                        if (succ == FIND_SUCCESS){
                            uint8_t tsuccess = setTilt(readFloat(start, stop));
    2208:	0e 94 c3 03 	call	0x786	; 0x786 <setTilt>
                            if (asuccess == 0 && tsuccess == 0){
    220c:	0f 90       	pop	r0
    220e:	0f 90       	pop	r0
                                fprintf(port,"OK\n");
    2210:	20 91 dc 02 	lds	r18, 0x02DC	; 0x8002dc <port>
    2214:	30 91 dd 02 	lds	r19, 0x02DD	; 0x8002dd <port+0x1>
                    if (succ == FIND_SUCCESS){
                        uint8_t asuccess = setAngle(readFloat(start, stop));
                        succ = findParameter(':', ':', '\n', 20, &start, &stop);
                        if (succ == FIND_SUCCESS){
                            uint8_t tsuccess = setTilt(readFloat(start, stop));
                            if (asuccess == 0 && tsuccess == 0){
    2218:	31 10       	cpse	r3, r1
    221a:	50 cd       	rjmp	.-1376   	; 0x1cbc <parseCommands+0x124>
    221c:	81 11       	cpse	r24, r1
    221e:	4e cd       	rjmp	.-1380   	; 0x1cbc <parseCommands+0x124>
                                fprintf(port,"OK\n");
    2220:	43 e0       	ldi	r20, 0x03	; 3
    2222:	50 e0       	ldi	r21, 0x00	; 0
    2224:	61 e0       	ldi	r22, 0x01	; 1
    2226:	70 e0       	ldi	r23, 0x00	; 0
    2228:	80 e7       	ldi	r24, 0x70	; 112
    222a:	92 e0       	ldi	r25, 0x02	; 2
    222c:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <fwrite>
    2230:	63 cd       	rjmp	.-1338   	; 0x1cf8 <parseCommands+0x160>
            }
            else if (value == '2'){ //Read current angle and tilt set_values
                fprintf(port,"G2:%5.2f:%5.2f\n", getSetAngle(), getSetTilt());
            }
            else if (value == '3'){ //Reads current values from motorctrl -module, actual values
                fprintf(port,"G3:%5.2f:%5.2f\n", getAngle(), getTilt());
    2232:	0e 94 76 03 	call	0x6ec	; 0x6ec <getTilt>
    2236:	36 2e       	mov	r3, r22
    2238:	27 2e       	mov	r2, r23
    223a:	ac 01       	movw	r20, r24
    223c:	8b 87       	std	Y+11, r24	; 0x0b
    223e:	5c 87       	std	Y+12, r21	; 0x0c
    2240:	0e 94 6d 03 	call	0x6da	; 0x6da <getAngle>
    2244:	5c 85       	ldd	r21, Y+12	; 0x0c
    2246:	5f 93       	push	r21
    2248:	4b 85       	ldd	r20, Y+11	; 0x0b
    224a:	4f 93       	push	r20
    224c:	2f 92       	push	r2
    224e:	3f 92       	push	r3
    2250:	9f 93       	push	r25
    2252:	8f 93       	push	r24
    2254:	7f 93       	push	r23
    2256:	6f 93       	push	r22
    2258:	ad e9       	ldi	r26, 0x9D	; 157
    225a:	b2 e0       	ldi	r27, 0x02	; 2
    225c:	bf 93       	push	r27
    225e:	af 93       	push	r26
    2260:	72 ce       	rjmp	.-796    	; 0x1f46 <parseCommands+0x3ae>
            }
            else if (value == '4'){ //get motor statuses
                fprintf(port, "G4:%d:%d\n", getAngleMotorStatus(), getTiltMotorStatus());
    2262:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <getTiltMotorStatus>
    2266:	38 2e       	mov	r3, r24
    2268:	0e 94 59 04 	call	0x8b2	; 0x8b2 <getAngleMotorStatus>
    226c:	1f 92       	push	r1
    226e:	3f 92       	push	r3
    2270:	1f 92       	push	r1
    2272:	8f 93       	push	r24
    2274:	ad ea       	ldi	r26, 0xAD	; 173
    2276:	b2 e0       	ldi	r27, 0x02	; 2
    2278:	bf 93       	push	r27
    227a:	af 93       	push	r26
    227c:	fc cd       	rjmp	.-1032   	; 0x1e76 <parseCommands+0x2de>

0000227e <__vector_18>:
__attribute__((always_inline)) inline static void clearBuffer(volatile char *buffer,uint8_t len){
	for(uint8_t i=0;i<len;i++){	*buffer++ = '\0';}
}

ISR(USART_RX_vect) //Serial port to Host machine
{
    227e:	1f 92       	push	r1
    2280:	0f 92       	push	r0
    2282:	0f b6       	in	r0, 0x3f	; 63
    2284:	0f 92       	push	r0
    2286:	11 24       	eor	r1, r1
    2288:	2f 93       	push	r18
    228a:	3f 93       	push	r19
    228c:	4f 93       	push	r20
    228e:	5f 93       	push	r21
    2290:	6f 93       	push	r22
    2292:	7f 93       	push	r23
    2294:	8f 93       	push	r24
    2296:	9f 93       	push	r25
    2298:	af 93       	push	r26
    229a:	bf 93       	push	r27
    229c:	ef 93       	push	r30
    229e:	ff 93       	push	r31
    22a0:	cf 93       	push	r28
    22a2:	df 93       	push	r29
    22a4:	1f 92       	push	r1
    22a6:	cd b7       	in	r28, 0x3d	; 61
    22a8:	de b7       	in	r29, 0x3e	; 62
#include <avr/io.h>	

#define USART_FREQ 16000000UL

__attribute__((always_inline)) inline static uint8_t USART_Receive0(void) {
	while ( !(UCSR0A & (1<<RXC0)) );
    22aa:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
    22ae:	87 ff       	sbrs	r24, 7
    22b0:	fc cf       	rjmp	.-8      	; 0x22aa <__vector_18+0x2c>
	return UDR0;
    22b2:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	volatile char temp = USART_Receive0();
    22b6:	89 83       	std	Y+1, r24	; 0x01
	buffer[ring_write++] = temp;
    22b8:	e0 91 db 02 	lds	r30, 0x02DB	; 0x8002db <ring_write>
    22bc:	81 e0       	ldi	r24, 0x01	; 1
    22be:	8e 0f       	add	r24, r30
    22c0:	80 93 db 02 	sts	0x02DB, r24	; 0x8002db <ring_write>
    22c4:	f0 e0       	ldi	r31, 0x00	; 0
    22c6:	89 81       	ldd	r24, Y+1	; 0x01
    22c8:	e6 51       	subi	r30, 0x16	; 22
    22ca:	fd 4f       	sbci	r31, 0xFD	; 253
    22cc:	80 83       	st	Z, r24
	if (temp == '\n' || temp == '\r'){
    22ce:	89 81       	ldd	r24, Y+1	; 0x01
    22d0:	8a 30       	cpi	r24, 0x0A	; 10
    22d2:	b9 f0       	breq	.+46     	; 0x2302 <__vector_18+0x84>
    22d4:	89 81       	ldd	r24, Y+1	; 0x01
    22d6:	8d 30       	cpi	r24, 0x0D	; 13
    22d8:	a1 f0       	breq	.+40     	; 0x2302 <__vector_18+0x84>
        parseCommands();
	}
}
    22da:	0f 90       	pop	r0
    22dc:	df 91       	pop	r29
    22de:	cf 91       	pop	r28
    22e0:	ff 91       	pop	r31
    22e2:	ef 91       	pop	r30
    22e4:	bf 91       	pop	r27
    22e6:	af 91       	pop	r26
    22e8:	9f 91       	pop	r25
    22ea:	8f 91       	pop	r24
    22ec:	7f 91       	pop	r23
    22ee:	6f 91       	pop	r22
    22f0:	5f 91       	pop	r21
    22f2:	4f 91       	pop	r20
    22f4:	3f 91       	pop	r19
    22f6:	2f 91       	pop	r18
    22f8:	0f 90       	pop	r0
    22fa:	0f be       	out	0x3f, r0	; 63
    22fc:	0f 90       	pop	r0
    22fe:	1f 90       	pop	r1
    2300:	18 95       	reti
ISR(USART_RX_vect) //Serial port to Host machine
{
	volatile char temp = USART_Receive0();
	buffer[ring_write++] = temp;
	if (temp == '\n' || temp == '\r'){
        parseCommands();
    2302:	4a dc       	rcall	.-1900   	; 0x1b98 <parseCommands>
    2304:	ea cf       	rjmp	.-44     	; 0x22da <__vector_18+0x5c>

00002306 <initButtons>:
#define TURN_RIGHT_PORT PORTD
#define TURN_RIGHT_INPUT PIND
#define TURN_RIGHT_PIN 4

void initButtons(void){
    AUTO_MANUAL_SWITCH_DIR &= ~(1<<AUTO_MANUAL_SWITCH_PIN); //Input
    2306:	52 98       	cbi	0x0a, 2	; 10
    AUTO_MANUAL_SWITCH_PORT &= ~(1<<AUTO_MANUAL_SWITCH_PIN); //Pulldown
    2308:	5a 98       	cbi	0x0b, 2	; 11
    
    TILT_UP_DIR &= ~(1<<TILT_UP_PIN); //Input
    230a:	22 98       	cbi	0x04, 2	; 4
    TILT_UP_PORT &= ~(1<<TILT_UP_PIN); //Pulldown
    230c:	2a 98       	cbi	0x05, 2	; 5
    
    TILT_DOWN_DIR &= ~(1<<TILT_DOWN_PIN); //Input
    230e:	21 98       	cbi	0x04, 1	; 4
    TILT_DOWN_PORT &= ~(1<<TILT_DOWN_PIN); //Pulldown
    2310:	29 98       	cbi	0x05, 1	; 5
    
    TURN_LEFT_DIR &= ~(1<<TURN_LEFT_PIN); //Input
    2312:	20 98       	cbi	0x04, 0	; 4
    TURN_LEFT_PORT &= ~(1<<TURN_LEFT_PIN); //Pulldown
    2314:	28 98       	cbi	0x05, 0	; 5
    
    TURN_RIGHT_DIR &= ~(1<<TURN_RIGHT_PIN); //Input
    2316:	54 98       	cbi	0x0a, 4	; 10
    TURN_RIGHT_PORT &= ~(1<<TURN_RIGHT_PIN); //Pulldown   
    2318:	5c 98       	cbi	0x0b, 4	; 11
    231a:	08 95       	ret

0000231c <readAutoManualState>:
}

uint8_t readAutoManualState(void){
    if (AUTO_MANUAL_SWITCH_INPUT & (1<<AUTO_MANUAL_SWITCH_PIN)){
    231c:	89 b1       	in	r24, 0x09	; 9
        return 1;
    }
    else{
        return 0;
    }
}
    231e:	82 fb       	bst	r24, 2
    2320:	88 27       	eor	r24, r24
    2322:	80 f9       	bld	r24, 0
    2324:	08 95       	ret

00002326 <readTiltButtonState>:

uint8_t readTiltButtonState(void){
    if (TILT_UP_INPUT & (1<<TILT_UP_PIN)){
    2326:	1a 99       	sbic	0x03, 2	; 3
    2328:	08 c0       	rjmp	.+16     	; 0x233a <readTiltButtonState+0x14>
        return 1;
    }
    else if (TILT_DOWN_INPUT & (1<<TILT_DOWN_PIN)){
    232a:	93 b1       	in	r25, 0x03	; 3
    232c:	89 2f       	mov	r24, r25
    232e:	82 70       	andi	r24, 0x02	; 2
    2330:	91 ff       	sbrs	r25, 1
    2332:	02 c0       	rjmp	.+4      	; 0x2338 <readTiltButtonState+0x12>
        return 2;
    2334:	82 e0       	ldi	r24, 0x02	; 2
    }
    else{
        return 0;
    }
}
    2336:	08 95       	ret
    2338:	08 95       	ret
    }
}

uint8_t readTiltButtonState(void){
    if (TILT_UP_INPUT & (1<<TILT_UP_PIN)){
        return 1;
    233a:	81 e0       	ldi	r24, 0x01	; 1
    233c:	08 95       	ret

0000233e <readTurnButtonState>:
    233e:	18 99       	sbic	0x03, 0	; 3
    2340:	08 c0       	rjmp	.+16     	; 0x2352 <readTurnButtonState+0x14>
    2342:	99 b1       	in	r25, 0x09	; 9
    2344:	89 2f       	mov	r24, r25
    2346:	80 71       	andi	r24, 0x10	; 16
    2348:	94 ff       	sbrs	r25, 4
    234a:	02 c0       	rjmp	.+4      	; 0x2350 <readTurnButtonState+0x12>
    234c:	82 e0       	ldi	r24, 0x02	; 2
    234e:	08 95       	ret
    2350:	08 95       	ret
    2352:	81 e0       	ldi	r24, 0x01	; 1
    2354:	08 95       	ret

00002356 <main>:
    2356:	2f ef       	ldi	r18, 0xFF	; 255
    2358:	80 e7       	ldi	r24, 0x70	; 112
    235a:	92 e0       	ldi	r25, 0x02	; 2
    235c:	21 50       	subi	r18, 0x01	; 1
    235e:	80 40       	sbci	r24, 0x00	; 0
    2360:	90 40       	sbci	r25, 0x00	; 0
    2362:	e1 f7       	brne	.-8      	; 0x235c <main+0x6>
    2364:	00 c0       	rjmp	.+0      	; 0x2366 <main+0x10>
    2366:	00 00       	nop
}
int main (int argc, char *argv[])
{
    _delay_ms(50);
	USART_Init(&port, 115200);
    2368:	40 e0       	ldi	r20, 0x00	; 0
    236a:	52 ec       	ldi	r21, 0xC2	; 194
    236c:	61 e0       	ldi	r22, 0x01	; 1
    236e:	70 e0       	ldi	r23, 0x00	; 0
    2370:	8c ed       	ldi	r24, 0xDC	; 220
    2372:	92 e0       	ldi	r25, 0x02	; 2
    2374:	0e 94 45 01 	call	0x28a	; 0x28a <USART_Init>
	USART0_Flush();
    2378:	0e 94 96 01 	call	0x32c	; 0x32c <USART0_Flush>
    //Set interrupt to TIMER1 COMPA
    //TIMSK1 = 0x02; //OCIEA enabled
    GTCCR = 0x00;    
}
void initLED(void){
    LED_DDR |= (1<<LED_PIN_NUM); 
    237c:	25 9a       	sbi	0x04, 5	; 4
{
    _delay_ms(50);
	USART_Init(&port, 115200);
	USART0_Flush();
    initLED();
    initADC();
    237e:	0e 94 d6 01 	call	0x3ac	; 0x3ac <initADC>
    initMotor(&port);
    2382:	8c ed       	ldi	r24, 0xDC	; 220
    2384:	92 e0       	ldi	r25, 0x02	; 2
    2386:	55 d9       	rcall	.-3414   	; 0x1632 <initMotor>
	initSerialParser(&port);
    2388:	8c ed       	ldi	r24, 0xDC	; 220
    238a:	92 e0       	ldi	r25, 0x02	; 2
    238c:	e0 da       	rcall	.-2624   	; 0x194e <initSerialParser>
    initButtons();    
    238e:	bb df       	rcall	.-138    	; 0x2306 <initButtons>
    //TCCR1B = 0x08 + 0x05; //WGM12 = 1, WGM 13 = 0        => CTC mode, Clock divider 1024 = 0x05
    //OCR1AH = 0x05; //Zero this when tests are done
    //OCR1AL = 0x64;  // interrupt 100 times per second 15625/156~about 100 
    //Set interrupt to TIMER1 COMPA
    //TIMSK1 = 0x02; //OCIEA enabled
    GTCCR = 0x00;    
    2390:	13 bc       	out	0x23, r1	; 35
//     for (uint16_t i = 515; i < 890; i++){
//         fprintf(&port, "angle:%5.2f f:%d\n",angleConversion(i),i);
//     }
//     while(1){}
// 
    GTCCR = 0x00;
    2392:	13 bc       	out	0x23, r1	; 35
    sei();
    2394:	78 94       	sei

    uint8_t current_mode = readAutoManualState();
    2396:	c2 df       	rcall	.-124    	; 0x231c <readAutoManualState>
    2398:	c8 2f       	mov	r28, r24
                    break;
                }
            }
        }
        else{
             TOGGLE_LED
    239a:	d0 e2       	ldi	r29, 0x20	; 32
    239c:	06 c0       	rjmp	.+12     	; 0x23aa <main+0x54>
    239e:	95 b1       	in	r25, 0x05	; 5
    23a0:	9d 27       	eor	r25, r29
    23a2:	95 b9       	out	0x05, r25	; 5
        }

        if (current_mode != readAutoManualState()){
    23a4:	bb df       	rcall	.-138    	; 0x231c <readAutoManualState>
    23a6:	8c 13       	cpse	r24, r28
    23a8:	47 c0       	rjmp	.+142    	; 0x2438 <main+0xe2>
    GTCCR = 0x00;
    sei();

    uint8_t current_mode = readAutoManualState();
    while(1){
        uint8_t status = motorController();
    23aa:	0e 94 46 09 	call	0x128c	; 0x128c <motorController>
//        if (status > STATUS_OK){
                //sendError();
//        }

        if (readAutoManualState() == MANUAL){ 
    23ae:	b6 df       	rcall	.-148    	; 0x231c <readAutoManualState>
    23b0:	81 11       	cpse	r24, r1
    23b2:	f5 cf       	rjmp	.-22     	; 0x239e <main+0x48>
            switch(readTiltButtonState()){
    23b4:	b8 df       	rcall	.-144    	; 0x2326 <readTiltButtonState>
    23b6:	81 30       	cpi	r24, 0x01	; 1
    23b8:	09 f4       	brne	.+2      	; 0x23bc <main+0x66>
    23ba:	50 c0       	rjmp	.+160    	; 0x245c <main+0x106>
    23bc:	82 30       	cpi	r24, 0x02	; 2
    23be:	c9 f4       	brne	.+50     	; 0x23f2 <main+0x9c>
                    fprintf(&port,"Turning 2 degrees left\n");
                    while(readTiltButtonState() != 0){motorController();} //Wait until button is released
                    break;
                }
                case 2:{
                    setAngle(getSetAngle()-2);
    23c0:	0e 94 47 04 	call	0x88e	; 0x88e <getSetAngle>
    23c4:	20 e0       	ldi	r18, 0x00	; 0
    23c6:	30 e0       	ldi	r19, 0x00	; 0
    23c8:	40 e0       	ldi	r20, 0x00	; 0
    23ca:	50 e4       	ldi	r21, 0x40	; 64
    23cc:	c9 d7       	rcall	.+3986   	; 0x3360 <__subsf3>
    23ce:	0e 94 7f 03 	call	0x6fe	; 0x6fe <setAngle>
                    fprintf(&port,"Turning 2 degrees right\n");
    23d2:	2c ed       	ldi	r18, 0xDC	; 220
    23d4:	32 e0       	ldi	r19, 0x02	; 2
    23d6:	48 e1       	ldi	r20, 0x18	; 24
    23d8:	50 e0       	ldi	r21, 0x00	; 0
    23da:	61 e0       	ldi	r22, 0x01	; 1
    23dc:	70 e0       	ldi	r23, 0x00	; 0
    23de:	80 ef       	ldi	r24, 0xF0	; 240
    23e0:	91 e0       	ldi	r25, 0x01	; 1
    23e2:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <fwrite>
                    while(readTiltButtonState() != 0){motorController();} //Wait until button is released
    23e6:	02 c0       	rjmp	.+4      	; 0x23ec <main+0x96>
    23e8:	0e 94 46 09 	call	0x128c	; 0x128c <motorController>
    23ec:	9c df       	rcall	.-200    	; 0x2326 <readTiltButtonState>
    23ee:	81 11       	cpse	r24, r1
    23f0:	fb cf       	rjmp	.-10     	; 0x23e8 <main+0x92>
                    break;
                }
            }
            switch(readTurnButtonState()){
    23f2:	a5 df       	rcall	.-182    	; 0x233e <readTurnButtonState>
    23f4:	81 30       	cpi	r24, 0x01	; 1
    23f6:	09 f4       	brne	.+2      	; 0x23fa <main+0xa4>
    23f8:	4e c0       	rjmp	.+156    	; 0x2496 <main+0x140>
    23fa:	82 30       	cpi	r24, 0x02	; 2
    23fc:	99 f6       	brne	.-90     	; 0x23a4 <main+0x4e>
                    fprintf(&port,"Turning 2 degree UP\n");
                    while(readTurnButtonState() != 0){motorController();} //Wait until button is released
                    break;
                }
                case 2:{
                    setTilt(getSetTilt()-2);
    23fe:	0e 94 50 04 	call	0x8a0	; 0x8a0 <getSetTilt>
    2402:	20 e0       	ldi	r18, 0x00	; 0
    2404:	30 e0       	ldi	r19, 0x00	; 0
    2406:	40 e0       	ldi	r20, 0x00	; 0
    2408:	50 e4       	ldi	r21, 0x40	; 64
    240a:	aa d7       	rcall	.+3924   	; 0x3360 <__subsf3>
    240c:	0e 94 c3 03 	call	0x786	; 0x786 <setTilt>
                    fprintf(&port,"Turning 2 degrees DOWN\n");
    2410:	2c ed       	ldi	r18, 0xDC	; 220
    2412:	32 e0       	ldi	r19, 0x02	; 2
    2414:	47 e1       	ldi	r20, 0x17	; 23
    2416:	50 e0       	ldi	r21, 0x00	; 0
    2418:	61 e0       	ldi	r22, 0x01	; 1
    241a:	70 e0       	ldi	r23, 0x00	; 0
    241c:	8e e1       	ldi	r24, 0x1E	; 30
    241e:	92 e0       	ldi	r25, 0x02	; 2
    2420:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <fwrite>
                    while(readTurnButtonState() != 0){motorController();} //Wait until button is released
    2424:	02 c0       	rjmp	.+4      	; 0x242a <main+0xd4>
    2426:	0e 94 46 09 	call	0x128c	; 0x128c <motorController>
    242a:	89 df       	rcall	.-238    	; 0x233e <readTurnButtonState>
    242c:	81 11       	cpse	r24, r1
    242e:	fb cf       	rjmp	.-10     	; 0x2426 <main+0xd0>
        }
        else{
             TOGGLE_LED
        }

        if (current_mode != readAutoManualState()){
    2430:	75 df       	rcall	.-278    	; 0x231c <readAutoManualState>
    2432:	8c 17       	cp	r24, r28
    2434:	09 f4       	brne	.+2      	; 0x2438 <main+0xe2>
    2436:	b9 cf       	rjmp	.-142    	; 0x23aa <main+0x54>
            if (readAutoManualState() == 1){
    2438:	71 df       	rcall	.-286    	; 0x231c <readAutoManualState>
                fprintf(&port, "Automatic mode turned ON\n");
    243a:	2c ed       	ldi	r18, 0xDC	; 220
    243c:	32 e0       	ldi	r19, 0x02	; 2
        else{
             TOGGLE_LED
        }

        if (current_mode != readAutoManualState()){
            if (readAutoManualState() == 1){
    243e:	81 30       	cpi	r24, 0x01	; 1
    2440:	09 f4       	brne	.+2      	; 0x2444 <main+0xee>
    2442:	43 c0       	rjmp	.+134    	; 0x24ca <main+0x174>
                fprintf(&port, "Automatic mode turned ON\n");
                current_mode = 1;
            }
            else{
                fprintf(&port, "Manual mode Activated\n");
    2444:	46 e1       	ldi	r20, 0x16	; 22
    2446:	50 e0       	ldi	r21, 0x00	; 0
    2448:	61 e0       	ldi	r22, 0x01	; 1
    244a:	70 e0       	ldi	r23, 0x00	; 0
    244c:	80 e5       	ldi	r24, 0x50	; 80
    244e:	92 e0       	ldi	r25, 0x02	; 2
    2450:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <fwrite>
                current_mode = 0;
                shutdownMotors();
    2454:	0e 94 0d 0a 	call	0x141a	; 0x141a <shutdownMotors>
                fprintf(&port, "Automatic mode turned ON\n");
                current_mode = 1;
            }
            else{
                fprintf(&port, "Manual mode Activated\n");
                current_mode = 0;
    2458:	c0 e0       	ldi	r28, 0x00	; 0
    245a:	a7 cf       	rjmp	.-178    	; 0x23aa <main+0x54>
//        }

        if (readAutoManualState() == MANUAL){ 
            switch(readTiltButtonState()){
                case 1:{
                    setAngle(getSetAngle()+2);
    245c:	0e 94 47 04 	call	0x88e	; 0x88e <getSetAngle>
    2460:	20 e0       	ldi	r18, 0x00	; 0
    2462:	30 e0       	ldi	r19, 0x00	; 0
    2464:	40 e0       	ldi	r20, 0x00	; 0
    2466:	50 e4       	ldi	r21, 0x40	; 64
    2468:	7c d7       	rcall	.+3832   	; 0x3362 <__addsf3>
    246a:	0e 94 7f 03 	call	0x6fe	; 0x6fe <setAngle>
                    fprintf(&port,"Turning 2 degrees left\n");
    246e:	2c ed       	ldi	r18, 0xDC	; 220
    2470:	32 e0       	ldi	r19, 0x02	; 2
    2472:	47 e1       	ldi	r20, 0x17	; 23
    2474:	50 e0       	ldi	r21, 0x00	; 0
    2476:	61 e0       	ldi	r22, 0x01	; 1
    2478:	70 e0       	ldi	r23, 0x00	; 0
    247a:	88 ed       	ldi	r24, 0xD8	; 216
    247c:	91 e0       	ldi	r25, 0x01	; 1
    247e:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <fwrite>
                    while(readTiltButtonState() != 0){motorController();} //Wait until button is released
    2482:	02 c0       	rjmp	.+4      	; 0x2488 <main+0x132>
    2484:	0e 94 46 09 	call	0x128c	; 0x128c <motorController>
    2488:	4e df       	rcall	.-356    	; 0x2326 <readTiltButtonState>
    248a:	81 11       	cpse	r24, r1
    248c:	fb cf       	rjmp	.-10     	; 0x2484 <main+0x12e>
                    fprintf(&port,"Turning 2 degrees right\n");
                    while(readTiltButtonState() != 0){motorController();} //Wait until button is released
                    break;
                }
            }
            switch(readTurnButtonState()){
    248e:	57 df       	rcall	.-338    	; 0x233e <readTurnButtonState>
    2490:	81 30       	cpi	r24, 0x01	; 1
    2492:	09 f0       	breq	.+2      	; 0x2496 <main+0x140>
    2494:	b2 cf       	rjmp	.-156    	; 0x23fa <main+0xa4>
                case 1:{
                    setTilt(getSetTilt()+2);
    2496:	0e 94 50 04 	call	0x8a0	; 0x8a0 <getSetTilt>
    249a:	20 e0       	ldi	r18, 0x00	; 0
    249c:	30 e0       	ldi	r19, 0x00	; 0
    249e:	40 e0       	ldi	r20, 0x00	; 0
    24a0:	50 e4       	ldi	r21, 0x40	; 64
    24a2:	5f d7       	rcall	.+3774   	; 0x3362 <__addsf3>
    24a4:	0e 94 c3 03 	call	0x786	; 0x786 <setTilt>
                    fprintf(&port,"Turning 2 degree UP\n");
    24a8:	2c ed       	ldi	r18, 0xDC	; 220
    24aa:	32 e0       	ldi	r19, 0x02	; 2
    24ac:	44 e1       	ldi	r20, 0x14	; 20
    24ae:	50 e0       	ldi	r21, 0x00	; 0
    24b0:	61 e0       	ldi	r22, 0x01	; 1
    24b2:	70 e0       	ldi	r23, 0x00	; 0
    24b4:	89 e0       	ldi	r24, 0x09	; 9
    24b6:	92 e0       	ldi	r25, 0x02	; 2
    24b8:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <fwrite>
                    while(readTurnButtonState() != 0){motorController();} //Wait until button is released
    24bc:	02 c0       	rjmp	.+4      	; 0x24c2 <main+0x16c>
    24be:	0e 94 46 09 	call	0x128c	; 0x128c <motorController>
    24c2:	3d df       	rcall	.-390    	; 0x233e <readTurnButtonState>
    24c4:	81 11       	cpse	r24, r1
    24c6:	fb cf       	rjmp	.-10     	; 0x24be <main+0x168>
    24c8:	6d cf       	rjmp	.-294    	; 0x23a4 <main+0x4e>
             TOGGLE_LED
        }

        if (current_mode != readAutoManualState()){
            if (readAutoManualState() == 1){
                fprintf(&port, "Automatic mode turned ON\n");
    24ca:	49 e1       	ldi	r20, 0x19	; 25
    24cc:	50 e0       	ldi	r21, 0x00	; 0
    24ce:	61 e0       	ldi	r22, 0x01	; 1
    24d0:	70 e0       	ldi	r23, 0x00	; 0
    24d2:	86 e3       	ldi	r24, 0x36	; 54
    24d4:	92 e0       	ldi	r25, 0x02	; 2
    24d6:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <fwrite>
                current_mode = 1;
    24da:	c1 e0       	ldi	r28, 0x01	; 1
    24dc:	66 cf       	rjmp	.-308    	; 0x23aa <main+0x54>

000024de <vfprintf>:
    24de:	a3 e1       	ldi	r26, 0x13	; 19
    24e0:	b0 e0       	ldi	r27, 0x00	; 0
    24e2:	e5 e7       	ldi	r30, 0x75	; 117
    24e4:	f2 e1       	ldi	r31, 0x12	; 18
    24e6:	0c 94 a5 1c 	jmp	0x394a	; 0x394a <__prologue_saves__>
    24ea:	6c 01       	movw	r12, r24
    24ec:	4b 01       	movw	r8, r22
    24ee:	2a 01       	movw	r4, r20
    24f0:	fc 01       	movw	r30, r24
    24f2:	17 82       	std	Z+7, r1	; 0x07
    24f4:	16 82       	std	Z+6, r1	; 0x06
    24f6:	83 81       	ldd	r24, Z+3	; 0x03
    24f8:	81 ff       	sbrs	r24, 1
    24fa:	43 c3       	rjmp	.+1670   	; 0x2b82 <vfprintf+0x6a4>
    24fc:	ae 01       	movw	r20, r28
    24fe:	4f 5f       	subi	r20, 0xFF	; 255
    2500:	5f 4f       	sbci	r21, 0xFF	; 255
    2502:	3a 01       	movw	r6, r20
    2504:	f6 01       	movw	r30, r12
    2506:	93 81       	ldd	r25, Z+3	; 0x03
    2508:	f4 01       	movw	r30, r8
    250a:	93 fd       	sbrc	r25, 3
    250c:	85 91       	lpm	r24, Z+
    250e:	93 ff       	sbrs	r25, 3
    2510:	81 91       	ld	r24, Z+
    2512:	4f 01       	movw	r8, r30
    2514:	88 23       	and	r24, r24
    2516:	09 f4       	brne	.+2      	; 0x251a <vfprintf+0x3c>
    2518:	30 c3       	rjmp	.+1632   	; 0x2b7a <vfprintf+0x69c>
    251a:	85 32       	cpi	r24, 0x25	; 37
    251c:	39 f4       	brne	.+14     	; 0x252c <vfprintf+0x4e>
    251e:	93 fd       	sbrc	r25, 3
    2520:	85 91       	lpm	r24, Z+
    2522:	93 ff       	sbrs	r25, 3
    2524:	81 91       	ld	r24, Z+
    2526:	4f 01       	movw	r8, r30
    2528:	85 32       	cpi	r24, 0x25	; 37
    252a:	39 f4       	brne	.+14     	; 0x253a <vfprintf+0x5c>
    252c:	b6 01       	movw	r22, r12
    252e:	90 e0       	ldi	r25, 0x00	; 0
    2530:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    2534:	52 01       	movw	r10, r4
    2536:	25 01       	movw	r4, r10
    2538:	e5 cf       	rjmp	.-54     	; 0x2504 <vfprintf+0x26>
    253a:	10 e0       	ldi	r17, 0x00	; 0
    253c:	f1 2c       	mov	r15, r1
    253e:	20 e0       	ldi	r18, 0x00	; 0
    2540:	20 32       	cpi	r18, 0x20	; 32
    2542:	a0 f4       	brcc	.+40     	; 0x256c <vfprintf+0x8e>
    2544:	8b 32       	cpi	r24, 0x2B	; 43
    2546:	69 f0       	breq	.+26     	; 0x2562 <vfprintf+0x84>
    2548:	30 f4       	brcc	.+12     	; 0x2556 <vfprintf+0x78>
    254a:	80 32       	cpi	r24, 0x20	; 32
    254c:	59 f0       	breq	.+22     	; 0x2564 <vfprintf+0x86>
    254e:	83 32       	cpi	r24, 0x23	; 35
    2550:	69 f4       	brne	.+26     	; 0x256c <vfprintf+0x8e>
    2552:	20 61       	ori	r18, 0x10	; 16
    2554:	2c c0       	rjmp	.+88     	; 0x25ae <vfprintf+0xd0>
    2556:	8d 32       	cpi	r24, 0x2D	; 45
    2558:	39 f0       	breq	.+14     	; 0x2568 <vfprintf+0x8a>
    255a:	80 33       	cpi	r24, 0x30	; 48
    255c:	39 f4       	brne	.+14     	; 0x256c <vfprintf+0x8e>
    255e:	21 60       	ori	r18, 0x01	; 1
    2560:	26 c0       	rjmp	.+76     	; 0x25ae <vfprintf+0xd0>
    2562:	22 60       	ori	r18, 0x02	; 2
    2564:	24 60       	ori	r18, 0x04	; 4
    2566:	23 c0       	rjmp	.+70     	; 0x25ae <vfprintf+0xd0>
    2568:	28 60       	ori	r18, 0x08	; 8
    256a:	21 c0       	rjmp	.+66     	; 0x25ae <vfprintf+0xd0>
    256c:	27 fd       	sbrc	r18, 7
    256e:	27 c0       	rjmp	.+78     	; 0x25be <vfprintf+0xe0>
    2570:	30 ed       	ldi	r19, 0xD0	; 208
    2572:	38 0f       	add	r19, r24
    2574:	3a 30       	cpi	r19, 0x0A	; 10
    2576:	78 f4       	brcc	.+30     	; 0x2596 <vfprintf+0xb8>
    2578:	26 ff       	sbrs	r18, 6
    257a:	06 c0       	rjmp	.+12     	; 0x2588 <vfprintf+0xaa>
    257c:	fa e0       	ldi	r31, 0x0A	; 10
    257e:	1f 9f       	mul	r17, r31
    2580:	30 0d       	add	r19, r0
    2582:	11 24       	eor	r1, r1
    2584:	13 2f       	mov	r17, r19
    2586:	13 c0       	rjmp	.+38     	; 0x25ae <vfprintf+0xd0>
    2588:	4a e0       	ldi	r20, 0x0A	; 10
    258a:	f4 9e       	mul	r15, r20
    258c:	30 0d       	add	r19, r0
    258e:	11 24       	eor	r1, r1
    2590:	f3 2e       	mov	r15, r19
    2592:	20 62       	ori	r18, 0x20	; 32
    2594:	0c c0       	rjmp	.+24     	; 0x25ae <vfprintf+0xd0>
    2596:	8e 32       	cpi	r24, 0x2E	; 46
    2598:	21 f4       	brne	.+8      	; 0x25a2 <vfprintf+0xc4>
    259a:	26 fd       	sbrc	r18, 6
    259c:	ee c2       	rjmp	.+1500   	; 0x2b7a <vfprintf+0x69c>
    259e:	20 64       	ori	r18, 0x40	; 64
    25a0:	06 c0       	rjmp	.+12     	; 0x25ae <vfprintf+0xd0>
    25a2:	8c 36       	cpi	r24, 0x6C	; 108
    25a4:	11 f4       	brne	.+4      	; 0x25aa <vfprintf+0xcc>
    25a6:	20 68       	ori	r18, 0x80	; 128
    25a8:	02 c0       	rjmp	.+4      	; 0x25ae <vfprintf+0xd0>
    25aa:	88 36       	cpi	r24, 0x68	; 104
    25ac:	41 f4       	brne	.+16     	; 0x25be <vfprintf+0xe0>
    25ae:	f4 01       	movw	r30, r8
    25b0:	93 fd       	sbrc	r25, 3
    25b2:	85 91       	lpm	r24, Z+
    25b4:	93 ff       	sbrs	r25, 3
    25b6:	81 91       	ld	r24, Z+
    25b8:	4f 01       	movw	r8, r30
    25ba:	81 11       	cpse	r24, r1
    25bc:	c1 cf       	rjmp	.-126    	; 0x2540 <vfprintf+0x62>
    25be:	9b eb       	ldi	r25, 0xBB	; 187
    25c0:	98 0f       	add	r25, r24
    25c2:	93 30       	cpi	r25, 0x03	; 3
    25c4:	18 f4       	brcc	.+6      	; 0x25cc <vfprintf+0xee>
    25c6:	20 61       	ori	r18, 0x10	; 16
    25c8:	80 5e       	subi	r24, 0xE0	; 224
    25ca:	06 c0       	rjmp	.+12     	; 0x25d8 <vfprintf+0xfa>
    25cc:	9b e9       	ldi	r25, 0x9B	; 155
    25ce:	98 0f       	add	r25, r24
    25d0:	93 30       	cpi	r25, 0x03	; 3
    25d2:	08 f0       	brcs	.+2      	; 0x25d6 <vfprintf+0xf8>
    25d4:	71 c1       	rjmp	.+738    	; 0x28b8 <vfprintf+0x3da>
    25d6:	2f 7e       	andi	r18, 0xEF	; 239
    25d8:	26 ff       	sbrs	r18, 6
    25da:	16 e0       	ldi	r17, 0x06	; 6
    25dc:	2f 73       	andi	r18, 0x3F	; 63
    25de:	32 2e       	mov	r3, r18
    25e0:	85 36       	cpi	r24, 0x65	; 101
    25e2:	19 f4       	brne	.+6      	; 0x25ea <vfprintf+0x10c>
    25e4:	20 64       	ori	r18, 0x40	; 64
    25e6:	32 2e       	mov	r3, r18
    25e8:	08 c0       	rjmp	.+16     	; 0x25fa <vfprintf+0x11c>
    25ea:	86 36       	cpi	r24, 0x66	; 102
    25ec:	21 f4       	brne	.+8      	; 0x25f6 <vfprintf+0x118>
    25ee:	f2 2f       	mov	r31, r18
    25f0:	f0 68       	ori	r31, 0x80	; 128
    25f2:	3f 2e       	mov	r3, r31
    25f4:	02 c0       	rjmp	.+4      	; 0x25fa <vfprintf+0x11c>
    25f6:	11 11       	cpse	r17, r1
    25f8:	11 50       	subi	r17, 0x01	; 1
    25fa:	37 fe       	sbrs	r3, 7
    25fc:	07 c0       	rjmp	.+14     	; 0x260c <vfprintf+0x12e>
    25fe:	1c 33       	cpi	r17, 0x3C	; 60
    2600:	50 f4       	brcc	.+20     	; 0x2616 <vfprintf+0x138>
    2602:	ee 24       	eor	r14, r14
    2604:	e3 94       	inc	r14
    2606:	e1 0e       	add	r14, r17
    2608:	27 e0       	ldi	r18, 0x07	; 7
    260a:	0b c0       	rjmp	.+22     	; 0x2622 <vfprintf+0x144>
    260c:	18 30       	cpi	r17, 0x08	; 8
    260e:	38 f0       	brcs	.+14     	; 0x261e <vfprintf+0x140>
    2610:	27 e0       	ldi	r18, 0x07	; 7
    2612:	17 e0       	ldi	r17, 0x07	; 7
    2614:	05 c0       	rjmp	.+10     	; 0x2620 <vfprintf+0x142>
    2616:	27 e0       	ldi	r18, 0x07	; 7
    2618:	4c e3       	ldi	r20, 0x3C	; 60
    261a:	e4 2e       	mov	r14, r20
    261c:	02 c0       	rjmp	.+4      	; 0x2622 <vfprintf+0x144>
    261e:	21 2f       	mov	r18, r17
    2620:	e1 2c       	mov	r14, r1
    2622:	52 01       	movw	r10, r4
    2624:	44 e0       	ldi	r20, 0x04	; 4
    2626:	a4 0e       	add	r10, r20
    2628:	b1 1c       	adc	r11, r1
    262a:	f2 01       	movw	r30, r4
    262c:	60 81       	ld	r22, Z
    262e:	71 81       	ldd	r23, Z+1	; 0x01
    2630:	82 81       	ldd	r24, Z+2	; 0x02
    2632:	93 81       	ldd	r25, Z+3	; 0x03
    2634:	0e 2d       	mov	r16, r14
    2636:	a3 01       	movw	r20, r6
    2638:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <__ftoa_engine>
    263c:	2c 01       	movw	r4, r24
    263e:	09 81       	ldd	r16, Y+1	; 0x01
    2640:	00 ff       	sbrs	r16, 0
    2642:	02 c0       	rjmp	.+4      	; 0x2648 <vfprintf+0x16a>
    2644:	03 ff       	sbrs	r16, 3
    2646:	07 c0       	rjmp	.+14     	; 0x2656 <vfprintf+0x178>
    2648:	31 fc       	sbrc	r3, 1
    264a:	08 c0       	rjmp	.+16     	; 0x265c <vfprintf+0x17e>
    264c:	32 fe       	sbrs	r3, 2
    264e:	09 c0       	rjmp	.+18     	; 0x2662 <vfprintf+0x184>
    2650:	30 e2       	ldi	r19, 0x20	; 32
    2652:	23 2e       	mov	r2, r19
    2654:	07 c0       	rjmp	.+14     	; 0x2664 <vfprintf+0x186>
    2656:	2d e2       	ldi	r18, 0x2D	; 45
    2658:	22 2e       	mov	r2, r18
    265a:	04 c0       	rjmp	.+8      	; 0x2664 <vfprintf+0x186>
    265c:	9b e2       	ldi	r25, 0x2B	; 43
    265e:	29 2e       	mov	r2, r25
    2660:	01 c0       	rjmp	.+2      	; 0x2664 <vfprintf+0x186>
    2662:	21 2c       	mov	r2, r1
    2664:	80 2f       	mov	r24, r16
    2666:	8c 70       	andi	r24, 0x0C	; 12
    2668:	19 f0       	breq	.+6      	; 0x2670 <vfprintf+0x192>
    266a:	21 10       	cpse	r2, r1
    266c:	68 c2       	rjmp	.+1232   	; 0x2b3e <vfprintf+0x660>
    266e:	a8 c2       	rjmp	.+1360   	; 0x2bc0 <vfprintf+0x6e2>
    2670:	37 fe       	sbrs	r3, 7
    2672:	0f c0       	rjmp	.+30     	; 0x2692 <vfprintf+0x1b4>
    2674:	e4 0c       	add	r14, r4
    2676:	04 ff       	sbrs	r16, 4
    2678:	04 c0       	rjmp	.+8      	; 0x2682 <vfprintf+0x1a4>
    267a:	8a 81       	ldd	r24, Y+2	; 0x02
    267c:	81 33       	cpi	r24, 0x31	; 49
    267e:	09 f4       	brne	.+2      	; 0x2682 <vfprintf+0x1a4>
    2680:	ea 94       	dec	r14
    2682:	1e 14       	cp	r1, r14
    2684:	74 f5       	brge	.+92     	; 0x26e2 <vfprintf+0x204>
    2686:	f8 e0       	ldi	r31, 0x08	; 8
    2688:	fe 15       	cp	r31, r14
    268a:	78 f5       	brcc	.+94     	; 0x26ea <vfprintf+0x20c>
    268c:	88 e0       	ldi	r24, 0x08	; 8
    268e:	e8 2e       	mov	r14, r24
    2690:	2c c0       	rjmp	.+88     	; 0x26ea <vfprintf+0x20c>
    2692:	36 fc       	sbrc	r3, 6
    2694:	2a c0       	rjmp	.+84     	; 0x26ea <vfprintf+0x20c>
    2696:	81 2f       	mov	r24, r17
    2698:	90 e0       	ldi	r25, 0x00	; 0
    269a:	84 15       	cp	r24, r4
    269c:	95 05       	cpc	r25, r5
    269e:	9c f0       	brlt	.+38     	; 0x26c6 <vfprintf+0x1e8>
    26a0:	2c ef       	ldi	r18, 0xFC	; 252
    26a2:	42 16       	cp	r4, r18
    26a4:	2f ef       	ldi	r18, 0xFF	; 255
    26a6:	52 06       	cpc	r5, r18
    26a8:	74 f0       	brlt	.+28     	; 0x26c6 <vfprintf+0x1e8>
    26aa:	43 2d       	mov	r20, r3
    26ac:	40 68       	ori	r20, 0x80	; 128
    26ae:	34 2e       	mov	r3, r20
    26b0:	0a c0       	rjmp	.+20     	; 0x26c6 <vfprintf+0x1e8>
    26b2:	e2 e0       	ldi	r30, 0x02	; 2
    26b4:	f0 e0       	ldi	r31, 0x00	; 0
    26b6:	ec 0f       	add	r30, r28
    26b8:	fd 1f       	adc	r31, r29
    26ba:	e1 0f       	add	r30, r17
    26bc:	f1 1d       	adc	r31, r1
    26be:	80 81       	ld	r24, Z
    26c0:	80 33       	cpi	r24, 0x30	; 48
    26c2:	19 f4       	brne	.+6      	; 0x26ca <vfprintf+0x1ec>
    26c4:	11 50       	subi	r17, 0x01	; 1
    26c6:	11 11       	cpse	r17, r1
    26c8:	f4 cf       	rjmp	.-24     	; 0x26b2 <vfprintf+0x1d4>
    26ca:	37 fe       	sbrs	r3, 7
    26cc:	0e c0       	rjmp	.+28     	; 0x26ea <vfprintf+0x20c>
    26ce:	ee 24       	eor	r14, r14
    26d0:	e3 94       	inc	r14
    26d2:	e1 0e       	add	r14, r17
    26d4:	81 2f       	mov	r24, r17
    26d6:	90 e0       	ldi	r25, 0x00	; 0
    26d8:	48 16       	cp	r4, r24
    26da:	59 06       	cpc	r5, r25
    26dc:	2c f4       	brge	.+10     	; 0x26e8 <vfprintf+0x20a>
    26de:	14 19       	sub	r17, r4
    26e0:	04 c0       	rjmp	.+8      	; 0x26ea <vfprintf+0x20c>
    26e2:	ee 24       	eor	r14, r14
    26e4:	e3 94       	inc	r14
    26e6:	01 c0       	rjmp	.+2      	; 0x26ea <vfprintf+0x20c>
    26e8:	10 e0       	ldi	r17, 0x00	; 0
    26ea:	37 fe       	sbrs	r3, 7
    26ec:	06 c0       	rjmp	.+12     	; 0x26fa <vfprintf+0x21c>
    26ee:	14 14       	cp	r1, r4
    26f0:	15 04       	cpc	r1, r5
    26f2:	34 f4       	brge	.+12     	; 0x2700 <vfprintf+0x222>
    26f4:	c2 01       	movw	r24, r4
    26f6:	01 96       	adiw	r24, 0x01	; 1
    26f8:	05 c0       	rjmp	.+10     	; 0x2704 <vfprintf+0x226>
    26fa:	85 e0       	ldi	r24, 0x05	; 5
    26fc:	90 e0       	ldi	r25, 0x00	; 0
    26fe:	02 c0       	rjmp	.+4      	; 0x2704 <vfprintf+0x226>
    2700:	81 e0       	ldi	r24, 0x01	; 1
    2702:	90 e0       	ldi	r25, 0x00	; 0
    2704:	21 10       	cpse	r2, r1
    2706:	01 96       	adiw	r24, 0x01	; 1
    2708:	11 23       	and	r17, r17
    270a:	31 f0       	breq	.+12     	; 0x2718 <vfprintf+0x23a>
    270c:	21 2f       	mov	r18, r17
    270e:	30 e0       	ldi	r19, 0x00	; 0
    2710:	2f 5f       	subi	r18, 0xFF	; 255
    2712:	3f 4f       	sbci	r19, 0xFF	; 255
    2714:	82 0f       	add	r24, r18
    2716:	93 1f       	adc	r25, r19
    2718:	2f 2d       	mov	r18, r15
    271a:	30 e0       	ldi	r19, 0x00	; 0
    271c:	82 17       	cp	r24, r18
    271e:	93 07       	cpc	r25, r19
    2720:	14 f4       	brge	.+4      	; 0x2726 <vfprintf+0x248>
    2722:	f8 1a       	sub	r15, r24
    2724:	01 c0       	rjmp	.+2      	; 0x2728 <vfprintf+0x24a>
    2726:	f1 2c       	mov	r15, r1
    2728:	83 2d       	mov	r24, r3
    272a:	89 70       	andi	r24, 0x09	; 9
    272c:	49 f4       	brne	.+18     	; 0x2740 <vfprintf+0x262>
    272e:	ff 20       	and	r15, r15
    2730:	39 f0       	breq	.+14     	; 0x2740 <vfprintf+0x262>
    2732:	b6 01       	movw	r22, r12
    2734:	80 e2       	ldi	r24, 0x20	; 32
    2736:	90 e0       	ldi	r25, 0x00	; 0
    2738:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    273c:	fa 94       	dec	r15
    273e:	f7 cf       	rjmp	.-18     	; 0x272e <vfprintf+0x250>
    2740:	22 20       	and	r2, r2
    2742:	29 f0       	breq	.+10     	; 0x274e <vfprintf+0x270>
    2744:	b6 01       	movw	r22, r12
    2746:	82 2d       	mov	r24, r2
    2748:	90 e0       	ldi	r25, 0x00	; 0
    274a:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    274e:	33 fc       	sbrc	r3, 3
    2750:	09 c0       	rjmp	.+18     	; 0x2764 <vfprintf+0x286>
    2752:	ff 20       	and	r15, r15
    2754:	39 f0       	breq	.+14     	; 0x2764 <vfprintf+0x286>
    2756:	b6 01       	movw	r22, r12
    2758:	80 e3       	ldi	r24, 0x30	; 48
    275a:	90 e0       	ldi	r25, 0x00	; 0
    275c:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    2760:	fa 94       	dec	r15
    2762:	f7 cf       	rjmp	.-18     	; 0x2752 <vfprintf+0x274>
    2764:	37 fe       	sbrs	r3, 7
    2766:	5a c0       	rjmp	.+180    	; 0x281c <vfprintf+0x33e>
    2768:	94 2d       	mov	r25, r4
    276a:	85 2d       	mov	r24, r5
    276c:	57 fe       	sbrs	r5, 7
    276e:	02 c0       	rjmp	.+4      	; 0x2774 <vfprintf+0x296>
    2770:	90 e0       	ldi	r25, 0x00	; 0
    2772:	80 e0       	ldi	r24, 0x00	; 0
    2774:	29 2e       	mov	r2, r25
    2776:	38 2e       	mov	r3, r24
    2778:	20 e0       	ldi	r18, 0x00	; 0
    277a:	30 e0       	ldi	r19, 0x00	; 0
    277c:	a2 01       	movw	r20, r4
    277e:	4e 19       	sub	r20, r14
    2780:	51 09       	sbc	r21, r1
    2782:	5d 87       	std	Y+13, r21	; 0x0d
    2784:	4c 87       	std	Y+12, r20	; 0x0c
    2786:	a2 01       	movw	r20, r4
    2788:	42 19       	sub	r20, r2
    278a:	53 09       	sbc	r21, r3
    278c:	5f 87       	std	Y+15, r21	; 0x0f
    278e:	4e 87       	std	Y+14, r20	; 0x0e
    2790:	61 2f       	mov	r22, r17
    2792:	70 e0       	ldi	r23, 0x00	; 0
    2794:	44 27       	eor	r20, r20
    2796:	55 27       	eor	r21, r21
    2798:	46 1b       	sub	r20, r22
    279a:	57 0b       	sbc	r21, r23
    279c:	59 8b       	std	Y+17, r21	; 0x11
    279e:	48 8b       	std	Y+16, r20	; 0x10
    27a0:	5f ef       	ldi	r21, 0xFF	; 255
    27a2:	25 16       	cp	r2, r21
    27a4:	35 06       	cpc	r3, r21
    27a6:	49 f4       	brne	.+18     	; 0x27ba <vfprintf+0x2dc>
    27a8:	b6 01       	movw	r22, r12
    27aa:	8e e2       	ldi	r24, 0x2E	; 46
    27ac:	90 e0       	ldi	r25, 0x00	; 0
    27ae:	2a 8b       	std	Y+18, r18	; 0x12
    27b0:	3b 8b       	std	Y+19, r19	; 0x13
    27b2:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    27b6:	3b 89       	ldd	r19, Y+19	; 0x13
    27b8:	2a 89       	ldd	r18, Y+18	; 0x12
    27ba:	42 14       	cp	r4, r2
    27bc:	53 04       	cpc	r5, r3
    27be:	6c f0       	brlt	.+26     	; 0x27da <vfprintf+0x2fc>
    27c0:	4c 85       	ldd	r20, Y+12	; 0x0c
    27c2:	5d 85       	ldd	r21, Y+13	; 0x0d
    27c4:	42 15       	cp	r20, r2
    27c6:	53 05       	cpc	r21, r3
    27c8:	44 f4       	brge	.+16     	; 0x27da <vfprintf+0x2fc>
    27ca:	ee 85       	ldd	r30, Y+14	; 0x0e
    27cc:	ff 85       	ldd	r31, Y+15	; 0x0f
    27ce:	e2 0f       	add	r30, r18
    27d0:	f3 1f       	adc	r31, r19
    27d2:	e6 0d       	add	r30, r6
    27d4:	f7 1d       	adc	r31, r7
    27d6:	81 81       	ldd	r24, Z+1	; 0x01
    27d8:	01 c0       	rjmp	.+2      	; 0x27dc <vfprintf+0x2fe>
    27da:	80 e3       	ldi	r24, 0x30	; 48
    27dc:	51 e0       	ldi	r21, 0x01	; 1
    27de:	25 1a       	sub	r2, r21
    27e0:	31 08       	sbc	r3, r1
    27e2:	2f 5f       	subi	r18, 0xFF	; 255
    27e4:	3f 4f       	sbci	r19, 0xFF	; 255
    27e6:	48 89       	ldd	r20, Y+16	; 0x10
    27e8:	59 89       	ldd	r21, Y+17	; 0x11
    27ea:	24 16       	cp	r2, r20
    27ec:	35 06       	cpc	r3, r21
    27ee:	4c f0       	brlt	.+18     	; 0x2802 <vfprintf+0x324>
    27f0:	b6 01       	movw	r22, r12
    27f2:	90 e0       	ldi	r25, 0x00	; 0
    27f4:	2a 8b       	std	Y+18, r18	; 0x12
    27f6:	3b 8b       	std	Y+19, r19	; 0x13
    27f8:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    27fc:	2a 89       	ldd	r18, Y+18	; 0x12
    27fe:	3b 89       	ldd	r19, Y+19	; 0x13
    2800:	cf cf       	rjmp	.-98     	; 0x27a0 <vfprintf+0x2c2>
    2802:	24 14       	cp	r2, r4
    2804:	35 04       	cpc	r3, r5
    2806:	39 f4       	brne	.+14     	; 0x2816 <vfprintf+0x338>
    2808:	9a 81       	ldd	r25, Y+2	; 0x02
    280a:	96 33       	cpi	r25, 0x36	; 54
    280c:	18 f4       	brcc	.+6      	; 0x2814 <vfprintf+0x336>
    280e:	95 33       	cpi	r25, 0x35	; 53
    2810:	11 f4       	brne	.+4      	; 0x2816 <vfprintf+0x338>
    2812:	04 ff       	sbrs	r16, 4
    2814:	81 e3       	ldi	r24, 0x31	; 49
    2816:	b6 01       	movw	r22, r12
    2818:	90 e0       	ldi	r25, 0x00	; 0
    281a:	4b c0       	rjmp	.+150    	; 0x28b2 <vfprintf+0x3d4>
    281c:	8a 81       	ldd	r24, Y+2	; 0x02
    281e:	81 33       	cpi	r24, 0x31	; 49
    2820:	09 f0       	breq	.+2      	; 0x2824 <vfprintf+0x346>
    2822:	0f 7e       	andi	r16, 0xEF	; 239
    2824:	b6 01       	movw	r22, r12
    2826:	90 e0       	ldi	r25, 0x00	; 0
    2828:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    282c:	11 11       	cpse	r17, r1
    282e:	05 c0       	rjmp	.+10     	; 0x283a <vfprintf+0x35c>
    2830:	34 fc       	sbrc	r3, 4
    2832:	18 c0       	rjmp	.+48     	; 0x2864 <vfprintf+0x386>
    2834:	85 e6       	ldi	r24, 0x65	; 101
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	17 c0       	rjmp	.+46     	; 0x2868 <vfprintf+0x38a>
    283a:	b6 01       	movw	r22, r12
    283c:	8e e2       	ldi	r24, 0x2E	; 46
    283e:	90 e0       	ldi	r25, 0x00	; 0
    2840:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    2844:	82 e0       	ldi	r24, 0x02	; 2
    2846:	ee 24       	eor	r14, r14
    2848:	e3 94       	inc	r14
    284a:	e8 0e       	add	r14, r24
    284c:	f3 01       	movw	r30, r6
    284e:	e8 0f       	add	r30, r24
    2850:	f1 1d       	adc	r31, r1
    2852:	80 81       	ld	r24, Z
    2854:	b6 01       	movw	r22, r12
    2856:	90 e0       	ldi	r25, 0x00	; 0
    2858:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    285c:	11 50       	subi	r17, 0x01	; 1
    285e:	8e 2d       	mov	r24, r14
    2860:	91 f7       	brne	.-28     	; 0x2846 <vfprintf+0x368>
    2862:	e6 cf       	rjmp	.-52     	; 0x2830 <vfprintf+0x352>
    2864:	85 e4       	ldi	r24, 0x45	; 69
    2866:	90 e0       	ldi	r25, 0x00	; 0
    2868:	b6 01       	movw	r22, r12
    286a:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    286e:	57 fc       	sbrc	r5, 7
    2870:	05 c0       	rjmp	.+10     	; 0x287c <vfprintf+0x39e>
    2872:	41 14       	cp	r4, r1
    2874:	51 04       	cpc	r5, r1
    2876:	39 f4       	brne	.+14     	; 0x2886 <vfprintf+0x3a8>
    2878:	04 ff       	sbrs	r16, 4
    287a:	05 c0       	rjmp	.+10     	; 0x2886 <vfprintf+0x3a8>
    287c:	51 94       	neg	r5
    287e:	41 94       	neg	r4
    2880:	51 08       	sbc	r5, r1
    2882:	8d e2       	ldi	r24, 0x2D	; 45
    2884:	01 c0       	rjmp	.+2      	; 0x2888 <vfprintf+0x3aa>
    2886:	8b e2       	ldi	r24, 0x2B	; 43
    2888:	b6 01       	movw	r22, r12
    288a:	90 e0       	ldi	r25, 0x00	; 0
    288c:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    2890:	80 e3       	ldi	r24, 0x30	; 48
    2892:	9a e0       	ldi	r25, 0x0A	; 10
    2894:	49 16       	cp	r4, r25
    2896:	51 04       	cpc	r5, r1
    2898:	2c f0       	brlt	.+10     	; 0x28a4 <vfprintf+0x3c6>
    289a:	8f 5f       	subi	r24, 0xFF	; 255
    289c:	5a e0       	ldi	r21, 0x0A	; 10
    289e:	45 1a       	sub	r4, r21
    28a0:	51 08       	sbc	r5, r1
    28a2:	f7 cf       	rjmp	.-18     	; 0x2892 <vfprintf+0x3b4>
    28a4:	b6 01       	movw	r22, r12
    28a6:	90 e0       	ldi	r25, 0x00	; 0
    28a8:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    28ac:	b6 01       	movw	r22, r12
    28ae:	c2 01       	movw	r24, r4
    28b0:	c0 96       	adiw	r24, 0x30	; 48
    28b2:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    28b6:	57 c1       	rjmp	.+686    	; 0x2b66 <vfprintf+0x688>
    28b8:	83 36       	cpi	r24, 0x63	; 99
    28ba:	31 f0       	breq	.+12     	; 0x28c8 <vfprintf+0x3ea>
    28bc:	83 37       	cpi	r24, 0x73	; 115
    28be:	79 f0       	breq	.+30     	; 0x28de <vfprintf+0x400>
    28c0:	83 35       	cpi	r24, 0x53	; 83
    28c2:	09 f0       	breq	.+2      	; 0x28c6 <vfprintf+0x3e8>
    28c4:	58 c0       	rjmp	.+176    	; 0x2976 <vfprintf+0x498>
    28c6:	21 c0       	rjmp	.+66     	; 0x290a <vfprintf+0x42c>
    28c8:	52 01       	movw	r10, r4
    28ca:	e2 e0       	ldi	r30, 0x02	; 2
    28cc:	ae 0e       	add	r10, r30
    28ce:	b1 1c       	adc	r11, r1
    28d0:	f2 01       	movw	r30, r4
    28d2:	80 81       	ld	r24, Z
    28d4:	89 83       	std	Y+1, r24	; 0x01
    28d6:	01 e0       	ldi	r16, 0x01	; 1
    28d8:	10 e0       	ldi	r17, 0x00	; 0
    28da:	23 01       	movw	r4, r6
    28dc:	14 c0       	rjmp	.+40     	; 0x2906 <vfprintf+0x428>
    28de:	52 01       	movw	r10, r4
    28e0:	f2 e0       	ldi	r31, 0x02	; 2
    28e2:	af 0e       	add	r10, r31
    28e4:	b1 1c       	adc	r11, r1
    28e6:	f2 01       	movw	r30, r4
    28e8:	40 80       	ld	r4, Z
    28ea:	51 80       	ldd	r5, Z+1	; 0x01
    28ec:	26 ff       	sbrs	r18, 6
    28ee:	03 c0       	rjmp	.+6      	; 0x28f6 <vfprintf+0x418>
    28f0:	61 2f       	mov	r22, r17
    28f2:	70 e0       	ldi	r23, 0x00	; 0
    28f4:	02 c0       	rjmp	.+4      	; 0x28fa <vfprintf+0x41c>
    28f6:	6f ef       	ldi	r22, 0xFF	; 255
    28f8:	7f ef       	ldi	r23, 0xFF	; 255
    28fa:	c2 01       	movw	r24, r4
    28fc:	2a 8b       	std	Y+18, r18	; 0x12
    28fe:	0e 94 fa 1d 	call	0x3bf4	; 0x3bf4 <strnlen>
    2902:	8c 01       	movw	r16, r24
    2904:	2a 89       	ldd	r18, Y+18	; 0x12
    2906:	2f 77       	andi	r18, 0x7F	; 127
    2908:	15 c0       	rjmp	.+42     	; 0x2934 <vfprintf+0x456>
    290a:	52 01       	movw	r10, r4
    290c:	f2 e0       	ldi	r31, 0x02	; 2
    290e:	af 0e       	add	r10, r31
    2910:	b1 1c       	adc	r11, r1
    2912:	f2 01       	movw	r30, r4
    2914:	40 80       	ld	r4, Z
    2916:	51 80       	ldd	r5, Z+1	; 0x01
    2918:	26 ff       	sbrs	r18, 6
    291a:	03 c0       	rjmp	.+6      	; 0x2922 <vfprintf+0x444>
    291c:	61 2f       	mov	r22, r17
    291e:	70 e0       	ldi	r23, 0x00	; 0
    2920:	02 c0       	rjmp	.+4      	; 0x2926 <vfprintf+0x448>
    2922:	6f ef       	ldi	r22, 0xFF	; 255
    2924:	7f ef       	ldi	r23, 0xFF	; 255
    2926:	c2 01       	movw	r24, r4
    2928:	2a 8b       	std	Y+18, r18	; 0x12
    292a:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <strnlen_P>
    292e:	8c 01       	movw	r16, r24
    2930:	2a 89       	ldd	r18, Y+18	; 0x12
    2932:	20 68       	ori	r18, 0x80	; 128
    2934:	32 2e       	mov	r3, r18
    2936:	23 fd       	sbrc	r18, 3
    2938:	1a c0       	rjmp	.+52     	; 0x296e <vfprintf+0x490>
    293a:	8f 2d       	mov	r24, r15
    293c:	90 e0       	ldi	r25, 0x00	; 0
    293e:	08 17       	cp	r16, r24
    2940:	19 07       	cpc	r17, r25
    2942:	a8 f4       	brcc	.+42     	; 0x296e <vfprintf+0x490>
    2944:	b6 01       	movw	r22, r12
    2946:	80 e2       	ldi	r24, 0x20	; 32
    2948:	90 e0       	ldi	r25, 0x00	; 0
    294a:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    294e:	fa 94       	dec	r15
    2950:	f4 cf       	rjmp	.-24     	; 0x293a <vfprintf+0x45c>
    2952:	f2 01       	movw	r30, r4
    2954:	37 fc       	sbrc	r3, 7
    2956:	85 91       	lpm	r24, Z+
    2958:	37 fe       	sbrs	r3, 7
    295a:	81 91       	ld	r24, Z+
    295c:	2f 01       	movw	r4, r30
    295e:	b6 01       	movw	r22, r12
    2960:	90 e0       	ldi	r25, 0x00	; 0
    2962:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    2966:	f1 10       	cpse	r15, r1
    2968:	fa 94       	dec	r15
    296a:	01 50       	subi	r16, 0x01	; 1
    296c:	11 09       	sbc	r17, r1
    296e:	01 15       	cp	r16, r1
    2970:	11 05       	cpc	r17, r1
    2972:	79 f7       	brne	.-34     	; 0x2952 <vfprintf+0x474>
    2974:	f8 c0       	rjmp	.+496    	; 0x2b66 <vfprintf+0x688>
    2976:	84 36       	cpi	r24, 0x64	; 100
    2978:	11 f0       	breq	.+4      	; 0x297e <vfprintf+0x4a0>
    297a:	89 36       	cpi	r24, 0x69	; 105
    297c:	59 f5       	brne	.+86     	; 0x29d4 <vfprintf+0x4f6>
    297e:	52 01       	movw	r10, r4
    2980:	27 ff       	sbrs	r18, 7
    2982:	09 c0       	rjmp	.+18     	; 0x2996 <vfprintf+0x4b8>
    2984:	f4 e0       	ldi	r31, 0x04	; 4
    2986:	af 0e       	add	r10, r31
    2988:	b1 1c       	adc	r11, r1
    298a:	f2 01       	movw	r30, r4
    298c:	60 81       	ld	r22, Z
    298e:	71 81       	ldd	r23, Z+1	; 0x01
    2990:	82 81       	ldd	r24, Z+2	; 0x02
    2992:	93 81       	ldd	r25, Z+3	; 0x03
    2994:	0a c0       	rjmp	.+20     	; 0x29aa <vfprintf+0x4cc>
    2996:	f2 e0       	ldi	r31, 0x02	; 2
    2998:	af 0e       	add	r10, r31
    299a:	b1 1c       	adc	r11, r1
    299c:	f2 01       	movw	r30, r4
    299e:	60 81       	ld	r22, Z
    29a0:	71 81       	ldd	r23, Z+1	; 0x01
    29a2:	07 2e       	mov	r0, r23
    29a4:	00 0c       	add	r0, r0
    29a6:	88 0b       	sbc	r24, r24
    29a8:	99 0b       	sbc	r25, r25
    29aa:	2f 76       	andi	r18, 0x6F	; 111
    29ac:	32 2e       	mov	r3, r18
    29ae:	97 ff       	sbrs	r25, 7
    29b0:	09 c0       	rjmp	.+18     	; 0x29c4 <vfprintf+0x4e6>
    29b2:	90 95       	com	r25
    29b4:	80 95       	com	r24
    29b6:	70 95       	com	r23
    29b8:	61 95       	neg	r22
    29ba:	7f 4f       	sbci	r23, 0xFF	; 255
    29bc:	8f 4f       	sbci	r24, 0xFF	; 255
    29be:	9f 4f       	sbci	r25, 0xFF	; 255
    29c0:	20 68       	ori	r18, 0x80	; 128
    29c2:	32 2e       	mov	r3, r18
    29c4:	2a e0       	ldi	r18, 0x0A	; 10
    29c6:	30 e0       	ldi	r19, 0x00	; 0
    29c8:	a3 01       	movw	r20, r6
    29ca:	0e 94 f7 1e 	call	0x3dee	; 0x3dee <__ultoa_invert>
    29ce:	e8 2e       	mov	r14, r24
    29d0:	e6 18       	sub	r14, r6
    29d2:	3f c0       	rjmp	.+126    	; 0x2a52 <vfprintf+0x574>
    29d4:	02 2f       	mov	r16, r18
    29d6:	85 37       	cpi	r24, 0x75	; 117
    29d8:	21 f4       	brne	.+8      	; 0x29e2 <vfprintf+0x504>
    29da:	0f 7e       	andi	r16, 0xEF	; 239
    29dc:	2a e0       	ldi	r18, 0x0A	; 10
    29de:	30 e0       	ldi	r19, 0x00	; 0
    29e0:	1d c0       	rjmp	.+58     	; 0x2a1c <vfprintf+0x53e>
    29e2:	09 7f       	andi	r16, 0xF9	; 249
    29e4:	8f 36       	cpi	r24, 0x6F	; 111
    29e6:	91 f0       	breq	.+36     	; 0x2a0c <vfprintf+0x52e>
    29e8:	18 f4       	brcc	.+6      	; 0x29f0 <vfprintf+0x512>
    29ea:	88 35       	cpi	r24, 0x58	; 88
    29ec:	59 f0       	breq	.+22     	; 0x2a04 <vfprintf+0x526>
    29ee:	c5 c0       	rjmp	.+394    	; 0x2b7a <vfprintf+0x69c>
    29f0:	80 37       	cpi	r24, 0x70	; 112
    29f2:	19 f0       	breq	.+6      	; 0x29fa <vfprintf+0x51c>
    29f4:	88 37       	cpi	r24, 0x78	; 120
    29f6:	11 f0       	breq	.+4      	; 0x29fc <vfprintf+0x51e>
    29f8:	c0 c0       	rjmp	.+384    	; 0x2b7a <vfprintf+0x69c>
    29fa:	00 61       	ori	r16, 0x10	; 16
    29fc:	04 ff       	sbrs	r16, 4
    29fe:	09 c0       	rjmp	.+18     	; 0x2a12 <vfprintf+0x534>
    2a00:	04 60       	ori	r16, 0x04	; 4
    2a02:	07 c0       	rjmp	.+14     	; 0x2a12 <vfprintf+0x534>
    2a04:	24 ff       	sbrs	r18, 4
    2a06:	08 c0       	rjmp	.+16     	; 0x2a18 <vfprintf+0x53a>
    2a08:	06 60       	ori	r16, 0x06	; 6
    2a0a:	06 c0       	rjmp	.+12     	; 0x2a18 <vfprintf+0x53a>
    2a0c:	28 e0       	ldi	r18, 0x08	; 8
    2a0e:	30 e0       	ldi	r19, 0x00	; 0
    2a10:	05 c0       	rjmp	.+10     	; 0x2a1c <vfprintf+0x53e>
    2a12:	20 e1       	ldi	r18, 0x10	; 16
    2a14:	30 e0       	ldi	r19, 0x00	; 0
    2a16:	02 c0       	rjmp	.+4      	; 0x2a1c <vfprintf+0x53e>
    2a18:	20 e1       	ldi	r18, 0x10	; 16
    2a1a:	32 e0       	ldi	r19, 0x02	; 2
    2a1c:	52 01       	movw	r10, r4
    2a1e:	07 ff       	sbrs	r16, 7
    2a20:	09 c0       	rjmp	.+18     	; 0x2a34 <vfprintf+0x556>
    2a22:	f4 e0       	ldi	r31, 0x04	; 4
    2a24:	af 0e       	add	r10, r31
    2a26:	b1 1c       	adc	r11, r1
    2a28:	f2 01       	movw	r30, r4
    2a2a:	60 81       	ld	r22, Z
    2a2c:	71 81       	ldd	r23, Z+1	; 0x01
    2a2e:	82 81       	ldd	r24, Z+2	; 0x02
    2a30:	93 81       	ldd	r25, Z+3	; 0x03
    2a32:	08 c0       	rjmp	.+16     	; 0x2a44 <vfprintf+0x566>
    2a34:	f2 e0       	ldi	r31, 0x02	; 2
    2a36:	af 0e       	add	r10, r31
    2a38:	b1 1c       	adc	r11, r1
    2a3a:	f2 01       	movw	r30, r4
    2a3c:	60 81       	ld	r22, Z
    2a3e:	71 81       	ldd	r23, Z+1	; 0x01
    2a40:	80 e0       	ldi	r24, 0x00	; 0
    2a42:	90 e0       	ldi	r25, 0x00	; 0
    2a44:	a3 01       	movw	r20, r6
    2a46:	0e 94 f7 1e 	call	0x3dee	; 0x3dee <__ultoa_invert>
    2a4a:	e8 2e       	mov	r14, r24
    2a4c:	e6 18       	sub	r14, r6
    2a4e:	0f 77       	andi	r16, 0x7F	; 127
    2a50:	30 2e       	mov	r3, r16
    2a52:	36 fe       	sbrs	r3, 6
    2a54:	0b c0       	rjmp	.+22     	; 0x2a6c <vfprintf+0x58e>
    2a56:	33 2d       	mov	r19, r3
    2a58:	3e 7f       	andi	r19, 0xFE	; 254
    2a5a:	e1 16       	cp	r14, r17
    2a5c:	50 f4       	brcc	.+20     	; 0x2a72 <vfprintf+0x594>
    2a5e:	34 fe       	sbrs	r3, 4
    2a60:	0a c0       	rjmp	.+20     	; 0x2a76 <vfprintf+0x598>
    2a62:	32 fc       	sbrc	r3, 2
    2a64:	08 c0       	rjmp	.+16     	; 0x2a76 <vfprintf+0x598>
    2a66:	33 2d       	mov	r19, r3
    2a68:	3e 7e       	andi	r19, 0xEE	; 238
    2a6a:	05 c0       	rjmp	.+10     	; 0x2a76 <vfprintf+0x598>
    2a6c:	0e 2d       	mov	r16, r14
    2a6e:	33 2d       	mov	r19, r3
    2a70:	03 c0       	rjmp	.+6      	; 0x2a78 <vfprintf+0x59a>
    2a72:	0e 2d       	mov	r16, r14
    2a74:	01 c0       	rjmp	.+2      	; 0x2a78 <vfprintf+0x59a>
    2a76:	01 2f       	mov	r16, r17
    2a78:	34 ff       	sbrs	r19, 4
    2a7a:	0c c0       	rjmp	.+24     	; 0x2a94 <vfprintf+0x5b6>
    2a7c:	fe 01       	movw	r30, r28
    2a7e:	ee 0d       	add	r30, r14
    2a80:	f1 1d       	adc	r31, r1
    2a82:	80 81       	ld	r24, Z
    2a84:	80 33       	cpi	r24, 0x30	; 48
    2a86:	11 f4       	brne	.+4      	; 0x2a8c <vfprintf+0x5ae>
    2a88:	39 7e       	andi	r19, 0xE9	; 233
    2a8a:	08 c0       	rjmp	.+16     	; 0x2a9c <vfprintf+0x5be>
    2a8c:	32 ff       	sbrs	r19, 2
    2a8e:	05 c0       	rjmp	.+10     	; 0x2a9a <vfprintf+0x5bc>
    2a90:	0e 5f       	subi	r16, 0xFE	; 254
    2a92:	04 c0       	rjmp	.+8      	; 0x2a9c <vfprintf+0x5be>
    2a94:	83 2f       	mov	r24, r19
    2a96:	86 78       	andi	r24, 0x86	; 134
    2a98:	09 f0       	breq	.+2      	; 0x2a9c <vfprintf+0x5be>
    2a9a:	0f 5f       	subi	r16, 0xFF	; 255
    2a9c:	33 fd       	sbrc	r19, 3
    2a9e:	13 c0       	rjmp	.+38     	; 0x2ac6 <vfprintf+0x5e8>
    2aa0:	30 ff       	sbrs	r19, 0
    2aa2:	06 c0       	rjmp	.+12     	; 0x2ab0 <vfprintf+0x5d2>
    2aa4:	1e 2d       	mov	r17, r14
    2aa6:	0f 15       	cp	r16, r15
    2aa8:	18 f4       	brcc	.+6      	; 0x2ab0 <vfprintf+0x5d2>
    2aaa:	1f 0d       	add	r17, r15
    2aac:	10 1b       	sub	r17, r16
    2aae:	0f 2d       	mov	r16, r15
    2ab0:	0f 15       	cp	r16, r15
    2ab2:	68 f4       	brcc	.+26     	; 0x2ace <vfprintf+0x5f0>
    2ab4:	b6 01       	movw	r22, r12
    2ab6:	80 e2       	ldi	r24, 0x20	; 32
    2ab8:	90 e0       	ldi	r25, 0x00	; 0
    2aba:	3b 8b       	std	Y+19, r19	; 0x13
    2abc:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    2ac0:	0f 5f       	subi	r16, 0xFF	; 255
    2ac2:	3b 89       	ldd	r19, Y+19	; 0x13
    2ac4:	f5 cf       	rjmp	.-22     	; 0x2ab0 <vfprintf+0x5d2>
    2ac6:	0f 15       	cp	r16, r15
    2ac8:	10 f4       	brcc	.+4      	; 0x2ace <vfprintf+0x5f0>
    2aca:	f0 1a       	sub	r15, r16
    2acc:	01 c0       	rjmp	.+2      	; 0x2ad0 <vfprintf+0x5f2>
    2ace:	f1 2c       	mov	r15, r1
    2ad0:	34 ff       	sbrs	r19, 4
    2ad2:	12 c0       	rjmp	.+36     	; 0x2af8 <vfprintf+0x61a>
    2ad4:	b6 01       	movw	r22, r12
    2ad6:	80 e3       	ldi	r24, 0x30	; 48
    2ad8:	90 e0       	ldi	r25, 0x00	; 0
    2ada:	3b 8b       	std	Y+19, r19	; 0x13
    2adc:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    2ae0:	3b 89       	ldd	r19, Y+19	; 0x13
    2ae2:	32 ff       	sbrs	r19, 2
    2ae4:	17 c0       	rjmp	.+46     	; 0x2b14 <vfprintf+0x636>
    2ae6:	31 fd       	sbrc	r19, 1
    2ae8:	03 c0       	rjmp	.+6      	; 0x2af0 <vfprintf+0x612>
    2aea:	88 e7       	ldi	r24, 0x78	; 120
    2aec:	90 e0       	ldi	r25, 0x00	; 0
    2aee:	02 c0       	rjmp	.+4      	; 0x2af4 <vfprintf+0x616>
    2af0:	88 e5       	ldi	r24, 0x58	; 88
    2af2:	90 e0       	ldi	r25, 0x00	; 0
    2af4:	b6 01       	movw	r22, r12
    2af6:	0c c0       	rjmp	.+24     	; 0x2b10 <vfprintf+0x632>
    2af8:	83 2f       	mov	r24, r19
    2afa:	86 78       	andi	r24, 0x86	; 134
    2afc:	59 f0       	breq	.+22     	; 0x2b14 <vfprintf+0x636>
    2afe:	31 ff       	sbrs	r19, 1
    2b00:	02 c0       	rjmp	.+4      	; 0x2b06 <vfprintf+0x628>
    2b02:	8b e2       	ldi	r24, 0x2B	; 43
    2b04:	01 c0       	rjmp	.+2      	; 0x2b08 <vfprintf+0x62a>
    2b06:	80 e2       	ldi	r24, 0x20	; 32
    2b08:	37 fd       	sbrc	r19, 7
    2b0a:	8d e2       	ldi	r24, 0x2D	; 45
    2b0c:	b6 01       	movw	r22, r12
    2b0e:	90 e0       	ldi	r25, 0x00	; 0
    2b10:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    2b14:	e1 16       	cp	r14, r17
    2b16:	38 f4       	brcc	.+14     	; 0x2b26 <vfprintf+0x648>
    2b18:	b6 01       	movw	r22, r12
    2b1a:	80 e3       	ldi	r24, 0x30	; 48
    2b1c:	90 e0       	ldi	r25, 0x00	; 0
    2b1e:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    2b22:	11 50       	subi	r17, 0x01	; 1
    2b24:	f7 cf       	rjmp	.-18     	; 0x2b14 <vfprintf+0x636>
    2b26:	ea 94       	dec	r14
    2b28:	f3 01       	movw	r30, r6
    2b2a:	ee 0d       	add	r30, r14
    2b2c:	f1 1d       	adc	r31, r1
    2b2e:	80 81       	ld	r24, Z
    2b30:	b6 01       	movw	r22, r12
    2b32:	90 e0       	ldi	r25, 0x00	; 0
    2b34:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    2b38:	e1 10       	cpse	r14, r1
    2b3a:	f5 cf       	rjmp	.-22     	; 0x2b26 <vfprintf+0x648>
    2b3c:	14 c0       	rjmp	.+40     	; 0x2b66 <vfprintf+0x688>
    2b3e:	f4 e0       	ldi	r31, 0x04	; 4
    2b40:	ff 15       	cp	r31, r15
    2b42:	58 f5       	brcc	.+86     	; 0x2b9a <vfprintf+0x6bc>
    2b44:	84 e0       	ldi	r24, 0x04	; 4
    2b46:	f8 1a       	sub	r15, r24
    2b48:	33 fe       	sbrs	r3, 3
    2b4a:	1e c0       	rjmp	.+60     	; 0x2b88 <vfprintf+0x6aa>
    2b4c:	21 10       	cpse	r2, r1
    2b4e:	26 c0       	rjmp	.+76     	; 0x2b9c <vfprintf+0x6be>
    2b50:	03 ff       	sbrs	r16, 3
    2b52:	2a c0       	rjmp	.+84     	; 0x2ba8 <vfprintf+0x6ca>
    2b54:	06 e9       	ldi	r16, 0x96	; 150
    2b56:	10 e0       	ldi	r17, 0x00	; 0
    2b58:	f3 2d       	mov	r31, r3
    2b5a:	f0 71       	andi	r31, 0x10	; 16
    2b5c:	3f 2e       	mov	r3, r31
    2b5e:	f8 01       	movw	r30, r16
    2b60:	84 91       	lpm	r24, Z
    2b62:	81 11       	cpse	r24, r1
    2b64:	24 c0       	rjmp	.+72     	; 0x2bae <vfprintf+0x6d0>
    2b66:	ff 20       	and	r15, r15
    2b68:	09 f4       	brne	.+2      	; 0x2b6c <vfprintf+0x68e>
    2b6a:	e5 cc       	rjmp	.-1590   	; 0x2536 <vfprintf+0x58>
    2b6c:	b6 01       	movw	r22, r12
    2b6e:	80 e2       	ldi	r24, 0x20	; 32
    2b70:	90 e0       	ldi	r25, 0x00	; 0
    2b72:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    2b76:	fa 94       	dec	r15
    2b78:	f6 cf       	rjmp	.-20     	; 0x2b66 <vfprintf+0x688>
    2b7a:	f6 01       	movw	r30, r12
    2b7c:	86 81       	ldd	r24, Z+6	; 0x06
    2b7e:	97 81       	ldd	r25, Z+7	; 0x07
    2b80:	26 c0       	rjmp	.+76     	; 0x2bce <vfprintf+0x6f0>
    2b82:	8f ef       	ldi	r24, 0xFF	; 255
    2b84:	9f ef       	ldi	r25, 0xFF	; 255
    2b86:	23 c0       	rjmp	.+70     	; 0x2bce <vfprintf+0x6f0>
    2b88:	b6 01       	movw	r22, r12
    2b8a:	80 e2       	ldi	r24, 0x20	; 32
    2b8c:	90 e0       	ldi	r25, 0x00	; 0
    2b8e:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    2b92:	fa 94       	dec	r15
    2b94:	f1 10       	cpse	r15, r1
    2b96:	f8 cf       	rjmp	.-16     	; 0x2b88 <vfprintf+0x6aa>
    2b98:	d9 cf       	rjmp	.-78     	; 0x2b4c <vfprintf+0x66e>
    2b9a:	f1 2c       	mov	r15, r1
    2b9c:	b6 01       	movw	r22, r12
    2b9e:	82 2d       	mov	r24, r2
    2ba0:	90 e0       	ldi	r25, 0x00	; 0
    2ba2:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    2ba6:	d4 cf       	rjmp	.-88     	; 0x2b50 <vfprintf+0x672>
    2ba8:	0a e9       	ldi	r16, 0x9A	; 154
    2baa:	10 e0       	ldi	r17, 0x00	; 0
    2bac:	d5 cf       	rjmp	.-86     	; 0x2b58 <vfprintf+0x67a>
    2bae:	31 10       	cpse	r3, r1
    2bb0:	80 52       	subi	r24, 0x20	; 32
    2bb2:	b6 01       	movw	r22, r12
    2bb4:	90 e0       	ldi	r25, 0x00	; 0
    2bb6:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <fputc>
    2bba:	0f 5f       	subi	r16, 0xFF	; 255
    2bbc:	1f 4f       	sbci	r17, 0xFF	; 255
    2bbe:	cf cf       	rjmp	.-98     	; 0x2b5e <vfprintf+0x680>
    2bc0:	23 e0       	ldi	r18, 0x03	; 3
    2bc2:	2f 15       	cp	r18, r15
    2bc4:	10 f4       	brcc	.+4      	; 0x2bca <vfprintf+0x6ec>
    2bc6:	83 e0       	ldi	r24, 0x03	; 3
    2bc8:	be cf       	rjmp	.-132    	; 0x2b46 <vfprintf+0x668>
    2bca:	f1 2c       	mov	r15, r1
    2bcc:	c1 cf       	rjmp	.-126    	; 0x2b50 <vfprintf+0x672>
    2bce:	63 96       	adiw	r28, 0x13	; 19
    2bd0:	e2 e1       	ldi	r30, 0x12	; 18
    2bd2:	d7 c6       	rjmp	.+3502   	; 0x3982 <__epilogue_restores__>

00002bd4 <putval>:
    2bd4:	20 fd       	sbrc	r18, 0
    2bd6:	09 c0       	rjmp	.+18     	; 0x2bea <putval+0x16>
    2bd8:	fc 01       	movw	r30, r24
    2bda:	23 fd       	sbrc	r18, 3
    2bdc:	05 c0       	rjmp	.+10     	; 0x2be8 <putval+0x14>
    2bde:	22 ff       	sbrs	r18, 2
    2be0:	02 c0       	rjmp	.+4      	; 0x2be6 <putval+0x12>
    2be2:	73 83       	std	Z+3, r23	; 0x03
    2be4:	62 83       	std	Z+2, r22	; 0x02
    2be6:	51 83       	std	Z+1, r21	; 0x01
    2be8:	40 83       	st	Z, r20
    2bea:	08 95       	ret

00002bec <mulacc>:
    2bec:	44 fd       	sbrc	r20, 4
    2bee:	10 c0       	rjmp	.+32     	; 0x2c10 <mulacc+0x24>
    2bf0:	46 fd       	sbrc	r20, 6
    2bf2:	10 c0       	rjmp	.+32     	; 0x2c14 <mulacc+0x28>
    2bf4:	db 01       	movw	r26, r22
    2bf6:	fc 01       	movw	r30, r24
    2bf8:	aa 0f       	add	r26, r26
    2bfa:	bb 1f       	adc	r27, r27
    2bfc:	ee 1f       	adc	r30, r30
    2bfe:	ff 1f       	adc	r31, r31
    2c00:	10 94       	com	r1
    2c02:	d1 f7       	brne	.-12     	; 0x2bf8 <mulacc+0xc>
    2c04:	6a 0f       	add	r22, r26
    2c06:	7b 1f       	adc	r23, r27
    2c08:	8e 1f       	adc	r24, r30
    2c0a:	9f 1f       	adc	r25, r31
    2c0c:	31 e0       	ldi	r19, 0x01	; 1
    2c0e:	03 c0       	rjmp	.+6      	; 0x2c16 <mulacc+0x2a>
    2c10:	33 e0       	ldi	r19, 0x03	; 3
    2c12:	01 c0       	rjmp	.+2      	; 0x2c16 <mulacc+0x2a>
    2c14:	34 e0       	ldi	r19, 0x04	; 4
    2c16:	66 0f       	add	r22, r22
    2c18:	77 1f       	adc	r23, r23
    2c1a:	88 1f       	adc	r24, r24
    2c1c:	99 1f       	adc	r25, r25
    2c1e:	31 50       	subi	r19, 0x01	; 1
    2c20:	d1 f7       	brne	.-12     	; 0x2c16 <mulacc+0x2a>
    2c22:	62 0f       	add	r22, r18
    2c24:	71 1d       	adc	r23, r1
    2c26:	81 1d       	adc	r24, r1
    2c28:	91 1d       	adc	r25, r1
    2c2a:	08 95       	ret

00002c2c <skip_spaces>:
    2c2c:	0f 93       	push	r16
    2c2e:	1f 93       	push	r17
    2c30:	cf 93       	push	r28
    2c32:	df 93       	push	r29
    2c34:	8c 01       	movw	r16, r24
    2c36:	c8 01       	movw	r24, r16
    2c38:	f0 d7       	rcall	.+4064   	; 0x3c1a <fgetc>
    2c3a:	ec 01       	movw	r28, r24
    2c3c:	97 fd       	sbrc	r25, 7
    2c3e:	07 c0       	rjmp	.+14     	; 0x2c4e <skip_spaces+0x22>
    2c40:	b3 d7       	rcall	.+3942   	; 0x3ba8 <isspace>
    2c42:	89 2b       	or	r24, r25
    2c44:	c1 f7       	brne	.-16     	; 0x2c36 <skip_spaces+0xa>
    2c46:	b8 01       	movw	r22, r16
    2c48:	ce 01       	movw	r24, r28
    2c4a:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <ungetc>
    2c4e:	ce 01       	movw	r24, r28
    2c50:	df 91       	pop	r29
    2c52:	cf 91       	pop	r28
    2c54:	1f 91       	pop	r17
    2c56:	0f 91       	pop	r16
    2c58:	08 95       	ret

00002c5a <conv_int>:
    2c5a:	a0 e0       	ldi	r26, 0x00	; 0
    2c5c:	b0 e0       	ldi	r27, 0x00	; 0
    2c5e:	e2 e3       	ldi	r30, 0x32	; 50
    2c60:	f6 e1       	ldi	r31, 0x16	; 22
    2c62:	79 c6       	rjmp	.+3314   	; 0x3956 <__prologue_saves__+0xc>
    2c64:	7c 01       	movw	r14, r24
    2c66:	8b 01       	movw	r16, r22
    2c68:	6a 01       	movw	r12, r20
    2c6a:	d2 2f       	mov	r29, r18
    2c6c:	d6 d7       	rcall	.+4012   	; 0x3c1a <fgetc>
    2c6e:	9c 01       	movw	r18, r24
    2c70:	33 27       	eor	r19, r19
    2c72:	2b 32       	cpi	r18, 0x2B	; 43
    2c74:	31 05       	cpc	r19, r1
    2c76:	21 f0       	breq	.+8      	; 0x2c80 <conv_int+0x26>
    2c78:	2d 32       	cpi	r18, 0x2D	; 45
    2c7a:	31 05       	cpc	r19, r1
    2c7c:	51 f4       	brne	.+20     	; 0x2c92 <conv_int+0x38>
    2c7e:	d0 68       	ori	r29, 0x80	; 128
    2c80:	01 50       	subi	r16, 0x01	; 1
    2c82:	11 09       	sbc	r17, r1
    2c84:	11 f4       	brne	.+4      	; 0x2c8a <conv_int+0x30>
    2c86:	80 e0       	ldi	r24, 0x00	; 0
    2c88:	63 c0       	rjmp	.+198    	; 0x2d50 <conv_int+0xf6>
    2c8a:	c7 01       	movw	r24, r14
    2c8c:	c6 d7       	rcall	.+3980   	; 0x3c1a <fgetc>
    2c8e:	97 fd       	sbrc	r25, 7
    2c90:	fa cf       	rjmp	.-12     	; 0x2c86 <conv_int+0x2c>
    2c92:	cd 2f       	mov	r28, r29
    2c94:	cd 7f       	andi	r28, 0xFD	; 253
    2c96:	2d 2f       	mov	r18, r29
    2c98:	20 73       	andi	r18, 0x30	; 48
    2c9a:	f9 f4       	brne	.+62     	; 0x2cda <conv_int+0x80>
    2c9c:	80 33       	cpi	r24, 0x30	; 48
    2c9e:	e9 f4       	brne	.+58     	; 0x2cda <conv_int+0x80>
    2ca0:	58 01       	movw	r10, r16
    2ca2:	81 e0       	ldi	r24, 0x01	; 1
    2ca4:	a8 1a       	sub	r10, r24
    2ca6:	b1 08       	sbc	r11, r1
    2ca8:	09 f4       	brne	.+2      	; 0x2cac <conv_int+0x52>
    2caa:	3f c0       	rjmp	.+126    	; 0x2d2a <conv_int+0xd0>
    2cac:	c7 01       	movw	r24, r14
    2cae:	b5 d7       	rcall	.+3946   	; 0x3c1a <fgetc>
    2cb0:	97 fd       	sbrc	r25, 7
    2cb2:	3b c0       	rjmp	.+118    	; 0x2d2a <conv_int+0xd0>
    2cb4:	28 2f       	mov	r18, r24
    2cb6:	2f 7d       	andi	r18, 0xDF	; 223
    2cb8:	28 35       	cpi	r18, 0x58	; 88
    2cba:	49 f4       	brne	.+18     	; 0x2cce <conv_int+0x74>
    2cbc:	c2 64       	ori	r28, 0x42	; 66
    2cbe:	02 50       	subi	r16, 0x02	; 2
    2cc0:	11 09       	sbc	r17, r1
    2cc2:	99 f1       	breq	.+102    	; 0x2d2a <conv_int+0xd0>
    2cc4:	c7 01       	movw	r24, r14
    2cc6:	a9 d7       	rcall	.+3922   	; 0x3c1a <fgetc>
    2cc8:	97 ff       	sbrs	r25, 7
    2cca:	07 c0       	rjmp	.+14     	; 0x2cda <conv_int+0x80>
    2ccc:	2e c0       	rjmp	.+92     	; 0x2d2a <conv_int+0xd0>
    2cce:	d6 ff       	sbrs	r29, 6
    2cd0:	02 c0       	rjmp	.+4      	; 0x2cd6 <conv_int+0x7c>
    2cd2:	c2 60       	ori	r28, 0x02	; 2
    2cd4:	01 c0       	rjmp	.+2      	; 0x2cd8 <conv_int+0x7e>
    2cd6:	c2 61       	ori	r28, 0x12	; 18
    2cd8:	85 01       	movw	r16, r10
    2cda:	81 2c       	mov	r8, r1
    2cdc:	91 2c       	mov	r9, r1
    2cde:	54 01       	movw	r10, r8
    2ce0:	20 ed       	ldi	r18, 0xD0	; 208
    2ce2:	28 0f       	add	r18, r24
    2ce4:	28 30       	cpi	r18, 0x08	; 8
    2ce6:	80 f0       	brcs	.+32     	; 0x2d08 <conv_int+0xae>
    2ce8:	c4 ff       	sbrs	r28, 4
    2cea:	04 c0       	rjmp	.+8      	; 0x2cf4 <conv_int+0x9a>
    2cec:	b7 01       	movw	r22, r14
    2cee:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <ungetc>
    2cf2:	18 c0       	rjmp	.+48     	; 0x2d24 <conv_int+0xca>
    2cf4:	2a 30       	cpi	r18, 0x0A	; 10
    2cf6:	40 f0       	brcs	.+16     	; 0x2d08 <conv_int+0xae>
    2cf8:	c6 ff       	sbrs	r28, 6
    2cfa:	f8 cf       	rjmp	.-16     	; 0x2cec <conv_int+0x92>
    2cfc:	2f 7d       	andi	r18, 0xDF	; 223
    2cfe:	3f ee       	ldi	r19, 0xEF	; 239
    2d00:	32 0f       	add	r19, r18
    2d02:	36 30       	cpi	r19, 0x06	; 6
    2d04:	98 f7       	brcc	.-26     	; 0x2cec <conv_int+0x92>
    2d06:	27 50       	subi	r18, 0x07	; 7
    2d08:	4c 2f       	mov	r20, r28
    2d0a:	c5 01       	movw	r24, r10
    2d0c:	b4 01       	movw	r22, r8
    2d0e:	6e df       	rcall	.-292    	; 0x2bec <mulacc>
    2d10:	4b 01       	movw	r8, r22
    2d12:	5c 01       	movw	r10, r24
    2d14:	c2 60       	ori	r28, 0x02	; 2
    2d16:	01 50       	subi	r16, 0x01	; 1
    2d18:	11 09       	sbc	r17, r1
    2d1a:	51 f0       	breq	.+20     	; 0x2d30 <conv_int+0xd6>
    2d1c:	c7 01       	movw	r24, r14
    2d1e:	7d d7       	rcall	.+3834   	; 0x3c1a <fgetc>
    2d20:	97 ff       	sbrs	r25, 7
    2d22:	de cf       	rjmp	.-68     	; 0x2ce0 <conv_int+0x86>
    2d24:	c1 fd       	sbrc	r28, 1
    2d26:	04 c0       	rjmp	.+8      	; 0x2d30 <conv_int+0xd6>
    2d28:	ae cf       	rjmp	.-164    	; 0x2c86 <conv_int+0x2c>
    2d2a:	81 2c       	mov	r8, r1
    2d2c:	91 2c       	mov	r9, r1
    2d2e:	54 01       	movw	r10, r8
    2d30:	c7 ff       	sbrs	r28, 7
    2d32:	08 c0       	rjmp	.+16     	; 0x2d44 <conv_int+0xea>
    2d34:	b0 94       	com	r11
    2d36:	a0 94       	com	r10
    2d38:	90 94       	com	r9
    2d3a:	80 94       	com	r8
    2d3c:	81 1c       	adc	r8, r1
    2d3e:	91 1c       	adc	r9, r1
    2d40:	a1 1c       	adc	r10, r1
    2d42:	b1 1c       	adc	r11, r1
    2d44:	2c 2f       	mov	r18, r28
    2d46:	b5 01       	movw	r22, r10
    2d48:	a4 01       	movw	r20, r8
    2d4a:	c6 01       	movw	r24, r12
    2d4c:	43 df       	rcall	.-378    	; 0x2bd4 <putval>
    2d4e:	81 e0       	ldi	r24, 0x01	; 1
    2d50:	cd b7       	in	r28, 0x3d	; 61
    2d52:	de b7       	in	r29, 0x3e	; 62
    2d54:	ec e0       	ldi	r30, 0x0C	; 12
    2d56:	1b c6       	rjmp	.+3126   	; 0x398e <__epilogue_restores__+0xc>

00002d58 <conv_brk>:
    2d58:	a0 e2       	ldi	r26, 0x20	; 32
    2d5a:	b0 e0       	ldi	r27, 0x00	; 0
    2d5c:	e1 eb       	ldi	r30, 0xB1	; 177
    2d5e:	f6 e1       	ldi	r31, 0x16	; 22
    2d60:	f6 c5       	rjmp	.+3052   	; 0x394e <__prologue_saves__+0x4>
    2d62:	4c 01       	movw	r8, r24
    2d64:	5b 01       	movw	r10, r22
    2d66:	7a 01       	movw	r14, r20
    2d68:	8e 01       	movw	r16, r28
    2d6a:	0f 5f       	subi	r16, 0xFF	; 255
    2d6c:	1f 4f       	sbci	r17, 0xFF	; 255
    2d6e:	68 01       	movw	r12, r16
    2d70:	80 e2       	ldi	r24, 0x20	; 32
    2d72:	f8 01       	movw	r30, r16
    2d74:	11 92       	st	Z+, r1
    2d76:	8a 95       	dec	r24
    2d78:	e9 f7       	brne	.-6      	; 0x2d74 <conv_brk+0x1c>
    2d7a:	f4 01       	movw	r30, r8
    2d7c:	63 80       	ldd	r6, Z+3	; 0x03
    2d7e:	40 e0       	ldi	r20, 0x00	; 0
    2d80:	50 e0       	ldi	r21, 0x00	; 0
    2d82:	71 2c       	mov	r7, r1
    2d84:	41 2c       	mov	r4, r1
    2d86:	80 e0       	ldi	r24, 0x00	; 0
    2d88:	a1 e0       	ldi	r26, 0x01	; 1
    2d8a:	b0 e0       	ldi	r27, 0x00	; 0
    2d8c:	f9 01       	movw	r30, r18
    2d8e:	63 fc       	sbrc	r6, 3
    2d90:	55 90       	lpm	r5, Z+
    2d92:	63 fe       	sbrs	r6, 3
    2d94:	51 90       	ld	r5, Z+
    2d96:	8f 01       	movw	r16, r30
    2d98:	95 2d       	mov	r25, r5
    2d9a:	9f 01       	movw	r18, r30
    2d9c:	51 10       	cpse	r5, r1
    2d9e:	03 c0       	rjmp	.+6      	; 0x2da6 <conv_brk+0x4e>
    2da0:	80 e0       	ldi	r24, 0x00	; 0
    2da2:	90 e0       	ldi	r25, 0x00	; 0
    2da4:	7e c0       	rjmp	.+252    	; 0x2ea2 <conv_brk+0x14a>
    2da6:	fe e5       	ldi	r31, 0x5E	; 94
    2da8:	5f 12       	cpse	r5, r31
    2daa:	03 c0       	rjmp	.+6      	; 0x2db2 <conv_brk+0x5a>
    2dac:	41 15       	cp	r20, r1
    2dae:	51 05       	cpc	r21, r1
    2db0:	61 f1       	breq	.+88     	; 0x2e0a <conv_brk+0xb2>
    2db2:	68 2f       	mov	r22, r24
    2db4:	70 e0       	ldi	r23, 0x00	; 0
    2db6:	64 17       	cp	r22, r20
    2db8:	75 07       	cpc	r23, r21
    2dba:	4c f4       	brge	.+18     	; 0x2dce <conv_brk+0x76>
    2dbc:	6d e5       	ldi	r22, 0x5D	; 93
    2dbe:	56 16       	cp	r5, r22
    2dc0:	69 f1       	breq	.+90     	; 0x2e1c <conv_brk+0xc4>
    2dc2:	ed e2       	ldi	r30, 0x2D	; 45
    2dc4:	5e 12       	cpse	r5, r30
    2dc6:	03 c0       	rjmp	.+6      	; 0x2dce <conv_brk+0x76>
    2dc8:	44 20       	and	r4, r4
    2dca:	09 f1       	breq	.+66     	; 0x2e0e <conv_brk+0xb6>
    2dcc:	03 c0       	rjmp	.+6      	; 0x2dd4 <conv_brk+0x7c>
    2dce:	41 10       	cpse	r4, r1
    2dd0:	01 c0       	rjmp	.+2      	; 0x2dd4 <conv_brk+0x7c>
    2dd2:	75 2c       	mov	r7, r5
    2dd4:	69 2f       	mov	r22, r25
    2dd6:	66 95       	lsr	r22
    2dd8:	66 95       	lsr	r22
    2dda:	66 95       	lsr	r22
    2ddc:	f6 01       	movw	r30, r12
    2dde:	e6 0f       	add	r30, r22
    2de0:	f1 1d       	adc	r31, r1
    2de2:	69 2f       	mov	r22, r25
    2de4:	67 70       	andi	r22, 0x07	; 7
    2de6:	8d 01       	movw	r16, r26
    2de8:	02 c0       	rjmp	.+4      	; 0x2dee <conv_brk+0x96>
    2dea:	00 0f       	add	r16, r16
    2dec:	11 1f       	adc	r17, r17
    2dee:	6a 95       	dec	r22
    2df0:	e2 f7       	brpl	.-8      	; 0x2dea <conv_brk+0x92>
    2df2:	b8 01       	movw	r22, r16
    2df4:	70 81       	ld	r23, Z
    2df6:	67 2b       	or	r22, r23
    2df8:	60 83       	st	Z, r22
    2dfa:	97 15       	cp	r25, r7
    2dfc:	59 f0       	breq	.+22     	; 0x2e14 <conv_brk+0xbc>
    2dfe:	97 15       	cp	r25, r7
    2e00:	10 f4       	brcc	.+4      	; 0x2e06 <conv_brk+0xae>
    2e02:	9f 5f       	subi	r25, 0xFF	; 255
    2e04:	e7 cf       	rjmp	.-50     	; 0x2dd4 <conv_brk+0x7c>
    2e06:	91 50       	subi	r25, 0x01	; 1
    2e08:	e5 cf       	rjmp	.-54     	; 0x2dd4 <conv_brk+0x7c>
    2e0a:	81 e0       	ldi	r24, 0x01	; 1
    2e0c:	04 c0       	rjmp	.+8      	; 0x2e16 <conv_brk+0xbe>
    2e0e:	44 24       	eor	r4, r4
    2e10:	43 94       	inc	r4
    2e12:	01 c0       	rjmp	.+2      	; 0x2e16 <conv_brk+0xbe>
    2e14:	41 2c       	mov	r4, r1
    2e16:	4f 5f       	subi	r20, 0xFF	; 255
    2e18:	5f 4f       	sbci	r21, 0xFF	; 255
    2e1a:	b8 cf       	rjmp	.-144    	; 0x2d8c <conv_brk+0x34>
    2e1c:	44 20       	and	r4, r4
    2e1e:	19 f0       	breq	.+6      	; 0x2e26 <conv_brk+0xce>
    2e20:	9e 81       	ldd	r25, Y+6	; 0x06
    2e22:	90 62       	ori	r25, 0x20	; 32
    2e24:	9e 83       	std	Y+6, r25	; 0x06
    2e26:	81 11       	cpse	r24, r1
    2e28:	03 c0       	rjmp	.+6      	; 0x2e30 <conv_brk+0xd8>
    2e2a:	77 24       	eor	r7, r7
    2e2c:	73 94       	inc	r7
    2e2e:	18 c0       	rjmp	.+48     	; 0x2e60 <conv_brk+0x108>
    2e30:	f6 01       	movw	r30, r12
    2e32:	9e 01       	movw	r18, r28
    2e34:	2f 5d       	subi	r18, 0xDF	; 223
    2e36:	3f 4f       	sbci	r19, 0xFF	; 255
    2e38:	80 81       	ld	r24, Z
    2e3a:	80 95       	com	r24
    2e3c:	81 93       	st	Z+, r24
    2e3e:	e2 17       	cp	r30, r18
    2e40:	f3 07       	cpc	r31, r19
    2e42:	d1 f7       	brne	.-12     	; 0x2e38 <conv_brk+0xe0>
    2e44:	f2 cf       	rjmp	.-28     	; 0x2e2a <conv_brk+0xd2>
    2e46:	e1 14       	cp	r14, r1
    2e48:	f1 04       	cpc	r15, r1
    2e4a:	29 f0       	breq	.+10     	; 0x2e56 <conv_brk+0xfe>
    2e4c:	f7 01       	movw	r30, r14
    2e4e:	80 83       	st	Z, r24
    2e50:	c7 01       	movw	r24, r14
    2e52:	01 96       	adiw	r24, 0x01	; 1
    2e54:	7c 01       	movw	r14, r24
    2e56:	91 e0       	ldi	r25, 0x01	; 1
    2e58:	a9 1a       	sub	r10, r25
    2e5a:	b1 08       	sbc	r11, r1
    2e5c:	71 2c       	mov	r7, r1
    2e5e:	d9 f0       	breq	.+54     	; 0x2e96 <conv_brk+0x13e>
    2e60:	c4 01       	movw	r24, r8
    2e62:	db d6       	rcall	.+3510   	; 0x3c1a <fgetc>
    2e64:	97 fd       	sbrc	r25, 7
    2e66:	15 c0       	rjmp	.+42     	; 0x2e92 <conv_brk+0x13a>
    2e68:	28 2f       	mov	r18, r24
    2e6a:	26 95       	lsr	r18
    2e6c:	26 95       	lsr	r18
    2e6e:	26 95       	lsr	r18
    2e70:	f6 01       	movw	r30, r12
    2e72:	e2 0f       	add	r30, r18
    2e74:	f1 1d       	adc	r31, r1
    2e76:	20 81       	ld	r18, Z
    2e78:	30 e0       	ldi	r19, 0x00	; 0
    2e7a:	ac 01       	movw	r20, r24
    2e7c:	47 70       	andi	r20, 0x07	; 7
    2e7e:	55 27       	eor	r21, r21
    2e80:	02 c0       	rjmp	.+4      	; 0x2e86 <conv_brk+0x12e>
    2e82:	35 95       	asr	r19
    2e84:	27 95       	ror	r18
    2e86:	4a 95       	dec	r20
    2e88:	e2 f7       	brpl	.-8      	; 0x2e82 <conv_brk+0x12a>
    2e8a:	20 fd       	sbrc	r18, 0
    2e8c:	dc cf       	rjmp	.-72     	; 0x2e46 <conv_brk+0xee>
    2e8e:	b4 01       	movw	r22, r8
    2e90:	95 d7       	rcall	.+3882   	; 0x3dbc <ungetc>
    2e92:	71 10       	cpse	r7, r1
    2e94:	85 cf       	rjmp	.-246    	; 0x2da0 <conv_brk+0x48>
    2e96:	e1 14       	cp	r14, r1
    2e98:	f1 04       	cpc	r15, r1
    2e9a:	11 f0       	breq	.+4      	; 0x2ea0 <conv_brk+0x148>
    2e9c:	f7 01       	movw	r30, r14
    2e9e:	10 82       	st	Z, r1
    2ea0:	c8 01       	movw	r24, r16
    2ea2:	a0 96       	adiw	r28, 0x20	; 32
    2ea4:	e0 e1       	ldi	r30, 0x10	; 16
    2ea6:	6f c5       	rjmp	.+2782   	; 0x3986 <__epilogue_restores__+0x4>

00002ea8 <conv_flt>:
    2ea8:	a6 e0       	ldi	r26, 0x06	; 6
    2eaa:	b0 e0       	ldi	r27, 0x00	; 0
    2eac:	e9 e5       	ldi	r30, 0x59	; 89
    2eae:	f7 e1       	ldi	r31, 0x17	; 23
    2eb0:	4c c5       	rjmp	.+2712   	; 0x394a <__prologue_saves__>
    2eb2:	5c 01       	movw	r10, r24
    2eb4:	7b 01       	movw	r14, r22
    2eb6:	1a 01       	movw	r2, r20
    2eb8:	b0 d6       	rcall	.+3424   	; 0x3c1a <fgetc>
    2eba:	9e 83       	std	Y+6, r25	; 0x06
    2ebc:	8d 83       	std	Y+5, r24	; 0x05
    2ebe:	99 27       	eor	r25, r25
    2ec0:	8b 32       	cpi	r24, 0x2B	; 43
    2ec2:	91 05       	cpc	r25, r1
    2ec4:	21 f0       	breq	.+8      	; 0x2ece <conv_flt+0x26>
    2ec6:	8d 97       	sbiw	r24, 0x2d	; 45
    2ec8:	81 f4       	brne	.+32     	; 0x2eea <conv_flt+0x42>
    2eca:	10 e8       	ldi	r17, 0x80	; 128
    2ecc:	01 c0       	rjmp	.+2      	; 0x2ed0 <conv_flt+0x28>
    2ece:	10 e0       	ldi	r17, 0x00	; 0
    2ed0:	21 e0       	ldi	r18, 0x01	; 1
    2ed2:	e2 1a       	sub	r14, r18
    2ed4:	f1 08       	sbc	r15, r1
    2ed6:	11 f4       	brne	.+4      	; 0x2edc <conv_flt+0x34>
    2ed8:	80 e0       	ldi	r24, 0x00	; 0
    2eda:	1e c1       	rjmp	.+572    	; 0x3118 <conv_flt+0x270>
    2edc:	c5 01       	movw	r24, r10
    2ede:	9d d6       	rcall	.+3386   	; 0x3c1a <fgetc>
    2ee0:	9e 83       	std	Y+6, r25	; 0x06
    2ee2:	8d 83       	std	Y+5, r24	; 0x05
    2ee4:	97 ff       	sbrs	r25, 7
    2ee6:	02 c0       	rjmp	.+4      	; 0x2eec <conv_flt+0x44>
    2ee8:	f7 cf       	rjmp	.-18     	; 0x2ed8 <conv_flt+0x30>
    2eea:	10 e0       	ldi	r17, 0x00	; 0
    2eec:	8d 81       	ldd	r24, Y+5	; 0x05
    2eee:	9e 81       	ldd	r25, Y+6	; 0x06
    2ef0:	63 d6       	rcall	.+3270   	; 0x3bb8 <tolower>
    2ef2:	89 36       	cpi	r24, 0x69	; 105
    2ef4:	91 05       	cpc	r25, r1
    2ef6:	49 f0       	breq	.+18     	; 0x2f0a <conv_flt+0x62>
    2ef8:	8e 36       	cpi	r24, 0x6E	; 110
    2efa:	91 05       	cpc	r25, r1
    2efc:	09 f0       	breq	.+2      	; 0x2f00 <conv_flt+0x58>
    2efe:	38 c0       	rjmp	.+112    	; 0x2f70 <conv_flt+0xc8>
    2f00:	65 ee       	ldi	r22, 0xE5	; 229
    2f02:	86 2e       	mov	r8, r22
    2f04:	61 e0       	ldi	r22, 0x01	; 1
    2f06:	96 2e       	mov	r9, r22
    2f08:	04 c0       	rjmp	.+8      	; 0x2f12 <conv_flt+0x6a>
    2f0a:	78 ee       	ldi	r23, 0xE8	; 232
    2f0c:	87 2e       	mov	r8, r23
    2f0e:	71 e0       	ldi	r23, 0x01	; 1
    2f10:	97 2e       	mov	r9, r23
    2f12:	ef ef       	ldi	r30, 0xFF	; 255
    2f14:	8e 1a       	sub	r8, r30
    2f16:	9e 0a       	sbc	r9, r30
    2f18:	f4 01       	movw	r30, r8
    2f1a:	31 97       	sbiw	r30, 0x01	; 1
    2f1c:	04 91       	lpm	r16, Z
    2f1e:	00 23       	and	r16, r16
    2f20:	b1 f0       	breq	.+44     	; 0x2f4e <conv_flt+0xa6>
    2f22:	81 e0       	ldi	r24, 0x01	; 1
    2f24:	e8 1a       	sub	r14, r24
    2f26:	f1 08       	sbc	r15, r1
    2f28:	59 f0       	breq	.+22     	; 0x2f40 <conv_flt+0x98>
    2f2a:	c5 01       	movw	r24, r10
    2f2c:	76 d6       	rcall	.+3308   	; 0x3c1a <fgetc>
    2f2e:	6c 01       	movw	r12, r24
    2f30:	97 fd       	sbrc	r25, 7
    2f32:	06 c0       	rjmp	.+12     	; 0x2f40 <conv_flt+0x98>
    2f34:	41 d6       	rcall	.+3202   	; 0x3bb8 <tolower>
    2f36:	08 17       	cp	r16, r24
    2f38:	61 f3       	breq	.-40     	; 0x2f12 <conv_flt+0x6a>
    2f3a:	b5 01       	movw	r22, r10
    2f3c:	c6 01       	movw	r24, r12
    2f3e:	3e d7       	rcall	.+3708   	; 0x3dbc <ungetc>
    2f40:	9b ee       	ldi	r25, 0xEB	; 235
    2f42:	89 16       	cp	r8, r25
    2f44:	91 e0       	ldi	r25, 0x01	; 1
    2f46:	99 06       	cpc	r9, r25
    2f48:	09 f0       	breq	.+2      	; 0x2f4c <conv_flt+0xa4>
    2f4a:	c6 cf       	rjmp	.-116    	; 0x2ed8 <conv_flt+0x30>
    2f4c:	05 c0       	rjmp	.+10     	; 0x2f58 <conv_flt+0xb0>
    2f4e:	f8 ee       	ldi	r31, 0xE8	; 232
    2f50:	8f 16       	cp	r8, r31
    2f52:	f1 e0       	ldi	r31, 0x01	; 1
    2f54:	9f 06       	cpc	r9, r31
    2f56:	29 f0       	breq	.+10     	; 0x2f62 <conv_flt+0xba>
    2f58:	80 e0       	ldi	r24, 0x00	; 0
    2f5a:	90 e0       	ldi	r25, 0x00	; 0
    2f5c:	a0 e8       	ldi	r26, 0x80	; 128
    2f5e:	bf e7       	ldi	r27, 0x7F	; 127
    2f60:	04 c0       	rjmp	.+8      	; 0x2f6a <conv_flt+0xc2>
    2f62:	80 e0       	ldi	r24, 0x00	; 0
    2f64:	90 e0       	ldi	r25, 0x00	; 0
    2f66:	a0 ec       	ldi	r26, 0xC0	; 192
    2f68:	bf e7       	ldi	r27, 0x7F	; 127
    2f6a:	bc 01       	movw	r22, r24
    2f6c:	cd 01       	movw	r24, r26
    2f6e:	c4 c0       	rjmp	.+392    	; 0x30f8 <conv_flt+0x250>
    2f70:	41 2c       	mov	r4, r1
    2f72:	51 2c       	mov	r5, r1
    2f74:	32 01       	movw	r6, r4
    2f76:	c1 2c       	mov	r12, r1
    2f78:	d1 2c       	mov	r13, r1
    2f7a:	2d 81       	ldd	r18, Y+5	; 0x05
    2f7c:	20 53       	subi	r18, 0x30	; 48
    2f7e:	2a 30       	cpi	r18, 0x0A	; 10
    2f80:	10 f5       	brcc	.+68     	; 0x2fc6 <conv_flt+0x11e>
    2f82:	01 2f       	mov	r16, r17
    2f84:	02 60       	ori	r16, 0x02	; 2
    2f86:	81 2f       	mov	r24, r17
    2f88:	88 70       	andi	r24, 0x08	; 8
    2f8a:	12 ff       	sbrs	r17, 2
    2f8c:	06 c0       	rjmp	.+12     	; 0x2f9a <conv_flt+0xf2>
    2f8e:	81 11       	cpse	r24, r1
    2f90:	20 c0       	rjmp	.+64     	; 0x2fd2 <conv_flt+0x12a>
    2f92:	2f ef       	ldi	r18, 0xFF	; 255
    2f94:	c2 1a       	sub	r12, r18
    2f96:	d2 0a       	sbc	r13, r18
    2f98:	1c c0       	rjmp	.+56     	; 0x2fd2 <conv_flt+0x12a>
    2f9a:	88 23       	and	r24, r24
    2f9c:	19 f0       	breq	.+6      	; 0x2fa4 <conv_flt+0xfc>
    2f9e:	81 e0       	ldi	r24, 0x01	; 1
    2fa0:	c8 1a       	sub	r12, r24
    2fa2:	d1 08       	sbc	r13, r1
    2fa4:	40 e2       	ldi	r20, 0x20	; 32
    2fa6:	c3 01       	movw	r24, r6
    2fa8:	b2 01       	movw	r22, r4
    2faa:	20 de       	rcall	.-960    	; 0x2bec <mulacc>
    2fac:	2b 01       	movw	r4, r22
    2fae:	3c 01       	movw	r6, r24
    2fb0:	98 e9       	ldi	r25, 0x98	; 152
    2fb2:	49 16       	cp	r4, r25
    2fb4:	99 e9       	ldi	r25, 0x99	; 153
    2fb6:	59 06       	cpc	r5, r25
    2fb8:	69 06       	cpc	r6, r25
    2fba:	99 e1       	ldi	r25, 0x19	; 25
    2fbc:	79 06       	cpc	r7, r25
    2fbe:	48 f0       	brcs	.+18     	; 0x2fd2 <conv_flt+0x12a>
    2fc0:	01 2f       	mov	r16, r17
    2fc2:	06 60       	ori	r16, 0x06	; 6
    2fc4:	06 c0       	rjmp	.+12     	; 0x2fd2 <conv_flt+0x12a>
    2fc6:	2e 3f       	cpi	r18, 0xFE	; 254
    2fc8:	89 f4       	brne	.+34     	; 0x2fec <conv_flt+0x144>
    2fca:	13 fd       	sbrc	r17, 3
    2fcc:	0f c0       	rjmp	.+30     	; 0x2fec <conv_flt+0x144>
    2fce:	01 2f       	mov	r16, r17
    2fd0:	08 60       	ori	r16, 0x08	; 8
    2fd2:	e1 e0       	ldi	r30, 0x01	; 1
    2fd4:	ee 1a       	sub	r14, r30
    2fd6:	f1 08       	sbc	r15, r1
    2fd8:	41 f0       	breq	.+16     	; 0x2fea <conv_flt+0x142>
    2fda:	c5 01       	movw	r24, r10
    2fdc:	1e d6       	rcall	.+3132   	; 0x3c1a <fgetc>
    2fde:	9e 83       	std	Y+6, r25	; 0x06
    2fe0:	8d 83       	std	Y+5, r24	; 0x05
    2fe2:	10 2f       	mov	r17, r16
    2fe4:	97 ff       	sbrs	r25, 7
    2fe6:	c9 cf       	rjmp	.-110    	; 0x2f7a <conv_flt+0xd2>
    2fe8:	01 c0       	rjmp	.+2      	; 0x2fec <conv_flt+0x144>
    2fea:	10 2f       	mov	r17, r16
    2fec:	11 ff       	sbrs	r17, 1
    2fee:	74 cf       	rjmp	.-280    	; 0x2ed8 <conv_flt+0x30>
    2ff0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ff2:	8f 7d       	andi	r24, 0xDF	; 223
    2ff4:	85 34       	cpi	r24, 0x45	; 69
    2ff6:	09 f0       	breq	.+2      	; 0x2ffa <conv_flt+0x152>
    2ff8:	4a c0       	rjmp	.+148    	; 0x308e <conv_flt+0x1e6>
    2ffa:	47 01       	movw	r8, r14
    2ffc:	f1 e0       	ldi	r31, 0x01	; 1
    2ffe:	8f 1a       	sub	r8, r31
    3000:	91 08       	sbc	r9, r1
    3002:	09 f4       	brne	.+2      	; 0x3006 <conv_flt+0x15e>
    3004:	69 cf       	rjmp	.-302    	; 0x2ed8 <conv_flt+0x30>
    3006:	c5 01       	movw	r24, r10
    3008:	08 d6       	rcall	.+3088   	; 0x3c1a <fgetc>
    300a:	9e 83       	std	Y+6, r25	; 0x06
    300c:	8d 83       	std	Y+5, r24	; 0x05
    300e:	97 fd       	sbrc	r25, 7
    3010:	63 cf       	rjmp	.-314    	; 0x2ed8 <conv_flt+0x30>
    3012:	99 27       	eor	r25, r25
    3014:	8b 32       	cpi	r24, 0x2B	; 43
    3016:	91 05       	cpc	r25, r1
    3018:	19 f0       	breq	.+6      	; 0x3020 <conv_flt+0x178>
    301a:	8d 97       	sbiw	r24, 0x2d	; 45
    301c:	59 f4       	brne	.+22     	; 0x3034 <conv_flt+0x18c>
    301e:	10 61       	ori	r17, 0x10	; 16
    3020:	47 01       	movw	r8, r14
    3022:	22 e0       	ldi	r18, 0x02	; 2
    3024:	82 1a       	sub	r8, r18
    3026:	91 08       	sbc	r9, r1
    3028:	09 f4       	brne	.+2      	; 0x302c <conv_flt+0x184>
    302a:	56 cf       	rjmp	.-340    	; 0x2ed8 <conv_flt+0x30>
    302c:	c5 01       	movw	r24, r10
    302e:	f5 d5       	rcall	.+3050   	; 0x3c1a <fgetc>
    3030:	9e 83       	std	Y+6, r25	; 0x06
    3032:	8d 83       	std	Y+5, r24	; 0x05
    3034:	8d 81       	ldd	r24, Y+5	; 0x05
    3036:	9e 81       	ldd	r25, Y+6	; 0x06
    3038:	c0 97       	sbiw	r24, 0x30	; 48
    303a:	0a 97       	sbiw	r24, 0x0a	; 10
    303c:	08 f0       	brcs	.+2      	; 0x3040 <conv_flt+0x198>
    303e:	4c cf       	rjmp	.-360    	; 0x2ed8 <conv_flt+0x30>
    3040:	74 01       	movw	r14, r8
    3042:	81 2c       	mov	r8, r1
    3044:	91 2c       	mov	r9, r1
    3046:	b4 01       	movw	r22, r8
    3048:	99 0c       	add	r9, r9
    304a:	88 0b       	sbc	r24, r24
    304c:	99 0b       	sbc	r25, r25
    304e:	2d 81       	ldd	r18, Y+5	; 0x05
    3050:	20 53       	subi	r18, 0x30	; 48
    3052:	40 e2       	ldi	r20, 0x20	; 32
    3054:	cb dd       	rcall	.-1130   	; 0x2bec <mulacc>
    3056:	ab 01       	movw	r20, r22
    3058:	bc 01       	movw	r22, r24
    305a:	4a 01       	movw	r8, r20
    305c:	81 e0       	ldi	r24, 0x01	; 1
    305e:	e8 1a       	sub	r14, r24
    3060:	f1 08       	sbc	r15, r1
    3062:	69 f0       	breq	.+26     	; 0x307e <conv_flt+0x1d6>
    3064:	c5 01       	movw	r24, r10
    3066:	49 83       	std	Y+1, r20	; 0x01
    3068:	5a 83       	std	Y+2, r21	; 0x02
    306a:	6b 83       	std	Y+3, r22	; 0x03
    306c:	7c 83       	std	Y+4, r23	; 0x04
    306e:	d5 d5       	rcall	.+2986   	; 0x3c1a <fgetc>
    3070:	9e 83       	std	Y+6, r25	; 0x06
    3072:	8d 83       	std	Y+5, r24	; 0x05
    3074:	c0 97       	sbiw	r24, 0x30	; 48
    3076:	49 81       	ldd	r20, Y+1	; 0x01
    3078:	5a 81       	ldd	r21, Y+2	; 0x02
    307a:	0a 97       	sbiw	r24, 0x0a	; 10
    307c:	20 f3       	brcs	.-56     	; 0x3046 <conv_flt+0x19e>
    307e:	14 ff       	sbrs	r17, 4
    3080:	04 c0       	rjmp	.+8      	; 0x308a <conv_flt+0x1e2>
    3082:	88 24       	eor	r8, r8
    3084:	99 24       	eor	r9, r9
    3086:	84 1a       	sub	r8, r20
    3088:	95 0a       	sbc	r9, r21
    308a:	c8 0c       	add	r12, r8
    308c:	d9 1c       	adc	r13, r9
    308e:	ef 28       	or	r14, r15
    3090:	39 f0       	breq	.+14     	; 0x30a0 <conv_flt+0x1f8>
    3092:	ed 81       	ldd	r30, Y+5	; 0x05
    3094:	fe 81       	ldd	r31, Y+6	; 0x06
    3096:	f7 fd       	sbrc	r31, 7
    3098:	03 c0       	rjmp	.+6      	; 0x30a0 <conv_flt+0x1f8>
    309a:	b5 01       	movw	r22, r10
    309c:	cf 01       	movw	r24, r30
    309e:	8e d6       	rcall	.+3356   	; 0x3dbc <ungetc>
    30a0:	c3 01       	movw	r24, r6
    30a2:	b2 01       	movw	r22, r4
    30a4:	82 d2       	rcall	.+1284   	; 0x35aa <__floatunsisf>
    30a6:	d7 fe       	sbrs	r13, 7
    30a8:	08 c0       	rjmp	.+16     	; 0x30ba <conv_flt+0x212>
    30aa:	d1 94       	neg	r13
    30ac:	c1 94       	neg	r12
    30ae:	d1 08       	sbc	r13, r1
    30b0:	54 e0       	ldi	r21, 0x04	; 4
    30b2:	85 2e       	mov	r8, r21
    30b4:	52 e0       	ldi	r21, 0x02	; 2
    30b6:	95 2e       	mov	r9, r21
    30b8:	04 c0       	rjmp	.+8      	; 0x30c2 <conv_flt+0x21a>
    30ba:	4c e1       	ldi	r20, 0x1C	; 28
    30bc:	84 2e       	mov	r8, r20
    30be:	42 e0       	ldi	r20, 0x02	; 2
    30c0:	94 2e       	mov	r9, r20
    30c2:	54 01       	movw	r10, r8
    30c4:	f8 e1       	ldi	r31, 0x18	; 24
    30c6:	af 1a       	sub	r10, r31
    30c8:	b1 08       	sbc	r11, r1
    30ca:	30 e2       	ldi	r19, 0x20	; 32
    30cc:	e3 2e       	mov	r14, r19
    30ce:	f1 2c       	mov	r15, r1
    30d0:	ce 14       	cp	r12, r14
    30d2:	df 04       	cpc	r13, r15
    30d4:	48 f0       	brcs	.+18     	; 0x30e8 <conv_flt+0x240>
    30d6:	f4 01       	movw	r30, r8
    30d8:	25 91       	lpm	r18, Z+
    30da:	35 91       	lpm	r19, Z+
    30dc:	45 91       	lpm	r20, Z+
    30de:	54 91       	lpm	r21, Z
    30e0:	46 d3       	rcall	.+1676   	; 0x376e <__mulsf3>
    30e2:	ce 18       	sub	r12, r14
    30e4:	df 08       	sbc	r13, r15
    30e6:	f4 cf       	rjmp	.-24     	; 0x30d0 <conv_flt+0x228>
    30e8:	24 e0       	ldi	r18, 0x04	; 4
    30ea:	82 1a       	sub	r8, r18
    30ec:	91 08       	sbc	r9, r1
    30ee:	f6 94       	lsr	r15
    30f0:	e7 94       	ror	r14
    30f2:	8a 14       	cp	r8, r10
    30f4:	9b 04       	cpc	r9, r11
    30f6:	61 f7       	brne	.-40     	; 0x30d0 <conv_flt+0x228>
    30f8:	17 ff       	sbrs	r17, 7
    30fa:	05 c0       	rjmp	.+10     	; 0x3106 <conv_flt+0x25e>
    30fc:	dc 01       	movw	r26, r24
    30fe:	cb 01       	movw	r24, r22
    3100:	b0 58       	subi	r27, 0x80	; 128
    3102:	bc 01       	movw	r22, r24
    3104:	cd 01       	movw	r24, r26
    3106:	21 14       	cp	r2, r1
    3108:	31 04       	cpc	r3, r1
    310a:	29 f0       	breq	.+10     	; 0x3116 <conv_flt+0x26e>
    310c:	f1 01       	movw	r30, r2
    310e:	60 83       	st	Z, r22
    3110:	71 83       	std	Z+1, r23	; 0x01
    3112:	82 83       	std	Z+2, r24	; 0x02
    3114:	93 83       	std	Z+3, r25	; 0x03
    3116:	81 e0       	ldi	r24, 0x01	; 1
    3118:	26 96       	adiw	r28, 0x06	; 6
    311a:	e2 e1       	ldi	r30, 0x12	; 18
    311c:	32 c4       	rjmp	.+2148   	; 0x3982 <__epilogue_restores__>

0000311e <vfscanf>:
    311e:	a1 e0       	ldi	r26, 0x01	; 1
    3120:	b0 e0       	ldi	r27, 0x00	; 0
    3122:	e4 e9       	ldi	r30, 0x94	; 148
    3124:	f8 e1       	ldi	r31, 0x18	; 24
    3126:	13 c4       	rjmp	.+2086   	; 0x394e <__prologue_saves__+0x4>
    3128:	6c 01       	movw	r12, r24
    312a:	2b 01       	movw	r4, r22
    312c:	4a 01       	movw	r8, r20
    312e:	fc 01       	movw	r30, r24
    3130:	17 82       	std	Z+7, r1	; 0x07
    3132:	16 82       	std	Z+6, r1	; 0x06
    3134:	a1 2c       	mov	r10, r1
    3136:	f6 01       	movw	r30, r12
    3138:	f3 80       	ldd	r15, Z+3	; 0x03
    313a:	f2 01       	movw	r30, r4
    313c:	f3 fc       	sbrc	r15, 3
    313e:	85 91       	lpm	r24, Z+
    3140:	f3 fe       	sbrs	r15, 3
    3142:	81 91       	ld	r24, Z+
    3144:	48 2f       	mov	r20, r24
    3146:	2f 01       	movw	r4, r30
    3148:	88 23       	and	r24, r24
    314a:	09 f4       	brne	.+2      	; 0x314e <vfscanf+0x30>
    314c:	01 c1       	rjmp	.+514    	; 0x3350 <vfscanf+0x232>
    314e:	90 e0       	ldi	r25, 0x00	; 0
    3150:	49 83       	std	Y+1, r20	; 0x01
    3152:	2a d5       	rcall	.+2644   	; 0x3ba8 <isspace>
    3154:	49 81       	ldd	r20, Y+1	; 0x01
    3156:	89 2b       	or	r24, r25
    3158:	19 f0       	breq	.+6      	; 0x3160 <vfscanf+0x42>
    315a:	c6 01       	movw	r24, r12
    315c:	67 dd       	rcall	.-1330   	; 0x2c2c <skip_spaces>
    315e:	eb cf       	rjmp	.-42     	; 0x3136 <vfscanf+0x18>
    3160:	45 32       	cpi	r20, 0x25	; 37
    3162:	41 f4       	brne	.+16     	; 0x3174 <vfscanf+0x56>
    3164:	f2 01       	movw	r30, r4
    3166:	f3 fc       	sbrc	r15, 3
    3168:	45 91       	lpm	r20, Z+
    316a:	f3 fe       	sbrs	r15, 3
    316c:	41 91       	ld	r20, Z+
    316e:	2f 01       	movw	r4, r30
    3170:	45 32       	cpi	r20, 0x25	; 37
    3172:	59 f4       	brne	.+22     	; 0x318a <vfscanf+0x6c>
    3174:	c6 01       	movw	r24, r12
    3176:	49 83       	std	Y+1, r20	; 0x01
    3178:	50 d5       	rcall	.+2720   	; 0x3c1a <fgetc>
    317a:	49 81       	ldd	r20, Y+1	; 0x01
    317c:	97 fd       	sbrc	r25, 7
    317e:	e6 c0       	rjmp	.+460    	; 0x334c <vfscanf+0x22e>
    3180:	48 17       	cp	r20, r24
    3182:	c9 f2       	breq	.-78     	; 0x3136 <vfscanf+0x18>
    3184:	b6 01       	movw	r22, r12
    3186:	1a d6       	rcall	.+3124   	; 0x3dbc <ungetc>
    3188:	e3 c0       	rjmp	.+454    	; 0x3350 <vfscanf+0x232>
    318a:	4a 32       	cpi	r20, 0x2A	; 42
    318c:	39 f4       	brne	.+14     	; 0x319c <vfscanf+0x7e>
    318e:	f3 fc       	sbrc	r15, 3
    3190:	45 91       	lpm	r20, Z+
    3192:	f3 fe       	sbrs	r15, 3
    3194:	41 91       	ld	r20, Z+
    3196:	2f 01       	movw	r4, r30
    3198:	51 e0       	ldi	r21, 0x01	; 1
    319a:	01 c0       	rjmp	.+2      	; 0x319e <vfscanf+0x80>
    319c:	50 e0       	ldi	r21, 0x00	; 0
    319e:	32 01       	movw	r6, r4
    31a0:	00 e0       	ldi	r16, 0x00	; 0
    31a2:	10 e0       	ldi	r17, 0x00	; 0
    31a4:	20 ed       	ldi	r18, 0xD0	; 208
    31a6:	24 0f       	add	r18, r20
    31a8:	2a 30       	cpi	r18, 0x0A	; 10
    31aa:	80 f4       	brcc	.+32     	; 0x31cc <vfscanf+0xae>
    31ac:	52 60       	ori	r21, 0x02	; 2
    31ae:	b8 01       	movw	r22, r16
    31b0:	80 e0       	ldi	r24, 0x00	; 0
    31b2:	90 e0       	ldi	r25, 0x00	; 0
    31b4:	40 e2       	ldi	r20, 0x20	; 32
    31b6:	59 83       	std	Y+1, r21	; 0x01
    31b8:	19 dd       	rcall	.-1486   	; 0x2bec <mulacc>
    31ba:	8b 01       	movw	r16, r22
    31bc:	f3 01       	movw	r30, r6
    31be:	f3 fc       	sbrc	r15, 3
    31c0:	45 91       	lpm	r20, Z+
    31c2:	f3 fe       	sbrs	r15, 3
    31c4:	41 91       	ld	r20, Z+
    31c6:	3f 01       	movw	r6, r30
    31c8:	59 81       	ldd	r21, Y+1	; 0x01
    31ca:	ec cf       	rjmp	.-40     	; 0x31a4 <vfscanf+0x86>
    31cc:	b5 2e       	mov	r11, r21
    31ce:	34 2f       	mov	r19, r20
    31d0:	23 01       	movw	r4, r6
    31d2:	51 ff       	sbrs	r21, 1
    31d4:	04 c0       	rjmp	.+8      	; 0x31de <vfscanf+0xc0>
    31d6:	01 15       	cp	r16, r1
    31d8:	11 05       	cpc	r17, r1
    31da:	19 f4       	brne	.+6      	; 0x31e2 <vfscanf+0xc4>
    31dc:	b9 c0       	rjmp	.+370    	; 0x3350 <vfscanf+0x232>
    31de:	0f ef       	ldi	r16, 0xFF	; 255
    31e0:	1f ef       	ldi	r17, 0xFF	; 255
    31e2:	48 36       	cpi	r20, 0x68	; 104
    31e4:	19 f0       	breq	.+6      	; 0x31ec <vfscanf+0xce>
    31e6:	4c 36       	cpi	r20, 0x6C	; 108
    31e8:	59 f0       	breq	.+22     	; 0x3200 <vfscanf+0xe2>
    31ea:	13 c0       	rjmp	.+38     	; 0x3212 <vfscanf+0xf4>
    31ec:	f3 01       	movw	r30, r6
    31ee:	f3 fc       	sbrc	r15, 3
    31f0:	35 91       	lpm	r19, Z+
    31f2:	f3 fe       	sbrs	r15, 3
    31f4:	31 91       	ld	r19, Z+
    31f6:	2f 01       	movw	r4, r30
    31f8:	38 36       	cpi	r19, 0x68	; 104
    31fa:	59 f4       	brne	.+22     	; 0x3212 <vfscanf+0xf4>
    31fc:	58 60       	ori	r21, 0x08	; 8
    31fe:	b5 2e       	mov	r11, r21
    3200:	fb 2d       	mov	r31, r11
    3202:	f4 60       	ori	r31, 0x04	; 4
    3204:	bf 2e       	mov	r11, r31
    3206:	f2 01       	movw	r30, r4
    3208:	f3 fc       	sbrc	r15, 3
    320a:	35 91       	lpm	r19, Z+
    320c:	f3 fe       	sbrs	r15, 3
    320e:	31 91       	ld	r19, Z+
    3210:	2f 01       	movw	r4, r30
    3212:	33 23       	and	r19, r19
    3214:	09 f4       	brne	.+2      	; 0x3218 <vfscanf+0xfa>
    3216:	9c c0       	rjmp	.+312    	; 0x3350 <vfscanf+0x232>
    3218:	63 2f       	mov	r22, r19
    321a:	70 e0       	ldi	r23, 0x00	; 0
    321c:	83 ed       	ldi	r24, 0xD3	; 211
    321e:	91 e0       	ldi	r25, 0x01	; 1
    3220:	39 83       	std	Y+1, r19	; 0x01
    3222:	d2 d4       	rcall	.+2468   	; 0x3bc8 <strchr_P>
    3224:	39 81       	ldd	r19, Y+1	; 0x01
    3226:	89 2b       	or	r24, r25
    3228:	09 f4       	brne	.+2      	; 0x322c <vfscanf+0x10e>
    322a:	92 c0       	rjmp	.+292    	; 0x3350 <vfscanf+0x232>
    322c:	b0 fc       	sbrc	r11, 0
    322e:	07 c0       	rjmp	.+14     	; 0x323e <vfscanf+0x120>
    3230:	f4 01       	movw	r30, r8
    3232:	e0 80       	ld	r14, Z
    3234:	f1 80       	ldd	r15, Z+1	; 0x01
    3236:	c4 01       	movw	r24, r8
    3238:	02 96       	adiw	r24, 0x02	; 2
    323a:	4c 01       	movw	r8, r24
    323c:	02 c0       	rjmp	.+4      	; 0x3242 <vfscanf+0x124>
    323e:	e1 2c       	mov	r14, r1
    3240:	f1 2c       	mov	r15, r1
    3242:	3e 36       	cpi	r19, 0x6E	; 110
    3244:	49 f4       	brne	.+18     	; 0x3258 <vfscanf+0x13a>
    3246:	f6 01       	movw	r30, r12
    3248:	46 81       	ldd	r20, Z+6	; 0x06
    324a:	57 81       	ldd	r21, Z+7	; 0x07
    324c:	60 e0       	ldi	r22, 0x00	; 0
    324e:	70 e0       	ldi	r23, 0x00	; 0
    3250:	2b 2d       	mov	r18, r11
    3252:	c7 01       	movw	r24, r14
    3254:	bf dc       	rcall	.-1666   	; 0x2bd4 <putval>
    3256:	6f cf       	rjmp	.-290    	; 0x3136 <vfscanf+0x18>
    3258:	33 36       	cpi	r19, 0x63	; 99
    325a:	a1 f4       	brne	.+40     	; 0x3284 <vfscanf+0x166>
    325c:	b1 fc       	sbrc	r11, 1
    325e:	02 c0       	rjmp	.+4      	; 0x3264 <vfscanf+0x146>
    3260:	01 e0       	ldi	r16, 0x01	; 1
    3262:	10 e0       	ldi	r17, 0x00	; 0
    3264:	c6 01       	movw	r24, r12
    3266:	d9 d4       	rcall	.+2482   	; 0x3c1a <fgetc>
    3268:	97 fd       	sbrc	r25, 7
    326a:	70 c0       	rjmp	.+224    	; 0x334c <vfscanf+0x22e>
    326c:	e1 14       	cp	r14, r1
    326e:	f1 04       	cpc	r15, r1
    3270:	29 f0       	breq	.+10     	; 0x327c <vfscanf+0x15e>
    3272:	f7 01       	movw	r30, r14
    3274:	80 83       	st	Z, r24
    3276:	c7 01       	movw	r24, r14
    3278:	01 96       	adiw	r24, 0x01	; 1
    327a:	7c 01       	movw	r14, r24
    327c:	01 50       	subi	r16, 0x01	; 1
    327e:	11 09       	sbc	r17, r1
    3280:	89 f7       	brne	.-30     	; 0x3264 <vfscanf+0x146>
    3282:	60 c0       	rjmp	.+192    	; 0x3344 <vfscanf+0x226>
    3284:	3b 35       	cpi	r19, 0x5B	; 91
    3286:	51 f4       	brne	.+20     	; 0x329c <vfscanf+0x17e>
    3288:	92 01       	movw	r18, r4
    328a:	a7 01       	movw	r20, r14
    328c:	b8 01       	movw	r22, r16
    328e:	c6 01       	movw	r24, r12
    3290:	63 dd       	rcall	.-1338   	; 0x2d58 <conv_brk>
    3292:	2c 01       	movw	r4, r24
    3294:	89 2b       	or	r24, r25
    3296:	09 f0       	breq	.+2      	; 0x329a <vfscanf+0x17c>
    3298:	55 c0       	rjmp	.+170    	; 0x3344 <vfscanf+0x226>
    329a:	4f c0       	rjmp	.+158    	; 0x333a <vfscanf+0x21c>
    329c:	c6 01       	movw	r24, r12
    329e:	39 83       	std	Y+1, r19	; 0x01
    32a0:	c5 dc       	rcall	.-1654   	; 0x2c2c <skip_spaces>
    32a2:	39 81       	ldd	r19, Y+1	; 0x01
    32a4:	97 fd       	sbrc	r25, 7
    32a6:	52 c0       	rjmp	.+164    	; 0x334c <vfscanf+0x22e>
    32a8:	3f 36       	cpi	r19, 0x6F	; 111
    32aa:	c1 f1       	breq	.+112    	; 0x331c <vfscanf+0x1fe>
    32ac:	40 f4       	brcc	.+16     	; 0x32be <vfscanf+0x1a0>
    32ae:	34 36       	cpi	r19, 0x64	; 100
    32b0:	89 f1       	breq	.+98     	; 0x3314 <vfscanf+0x1f6>
    32b2:	39 36       	cpi	r19, 0x69	; 105
    32b4:	b1 f1       	breq	.+108    	; 0x3322 <vfscanf+0x204>
    32b6:	38 35       	cpi	r19, 0x58	; 88
    32b8:	09 f0       	breq	.+2      	; 0x32bc <vfscanf+0x19e>
    32ba:	39 c0       	rjmp	.+114    	; 0x332e <vfscanf+0x210>
    32bc:	27 c0       	rjmp	.+78     	; 0x330c <vfscanf+0x1ee>
    32be:	33 37       	cpi	r19, 0x73	; 115
    32c0:	a1 f0       	breq	.+40     	; 0x32ea <vfscanf+0x1cc>
    32c2:	18 f4       	brcc	.+6      	; 0x32ca <vfscanf+0x1ac>
    32c4:	30 37       	cpi	r19, 0x70	; 112
    32c6:	11 f1       	breq	.+68     	; 0x330c <vfscanf+0x1ee>
    32c8:	32 c0       	rjmp	.+100    	; 0x332e <vfscanf+0x210>
    32ca:	35 37       	cpi	r19, 0x75	; 117
    32cc:	19 f1       	breq	.+70     	; 0x3314 <vfscanf+0x1f6>
    32ce:	38 37       	cpi	r19, 0x78	; 120
    32d0:	e9 f0       	breq	.+58     	; 0x330c <vfscanf+0x1ee>
    32d2:	2d c0       	rjmp	.+90     	; 0x332e <vfscanf+0x210>
    32d4:	e1 14       	cp	r14, r1
    32d6:	f1 04       	cpc	r15, r1
    32d8:	29 f0       	breq	.+10     	; 0x32e4 <vfscanf+0x1c6>
    32da:	f7 01       	movw	r30, r14
    32dc:	60 82       	st	Z, r6
    32de:	c7 01       	movw	r24, r14
    32e0:	01 96       	adiw	r24, 0x01	; 1
    32e2:	7c 01       	movw	r14, r24
    32e4:	01 50       	subi	r16, 0x01	; 1
    32e6:	11 09       	sbc	r17, r1
    32e8:	59 f0       	breq	.+22     	; 0x3300 <vfscanf+0x1e2>
    32ea:	c6 01       	movw	r24, r12
    32ec:	96 d4       	rcall	.+2348   	; 0x3c1a <fgetc>
    32ee:	3c 01       	movw	r6, r24
    32f0:	97 fd       	sbrc	r25, 7
    32f2:	06 c0       	rjmp	.+12     	; 0x3300 <vfscanf+0x1e2>
    32f4:	59 d4       	rcall	.+2226   	; 0x3ba8 <isspace>
    32f6:	89 2b       	or	r24, r25
    32f8:	69 f3       	breq	.-38     	; 0x32d4 <vfscanf+0x1b6>
    32fa:	b6 01       	movw	r22, r12
    32fc:	c3 01       	movw	r24, r6
    32fe:	5e d5       	rcall	.+2748   	; 0x3dbc <ungetc>
    3300:	e1 14       	cp	r14, r1
    3302:	f1 04       	cpc	r15, r1
    3304:	f9 f0       	breq	.+62     	; 0x3344 <vfscanf+0x226>
    3306:	f7 01       	movw	r30, r14
    3308:	10 82       	st	Z, r1
    330a:	1c c0       	rjmp	.+56     	; 0x3344 <vfscanf+0x226>
    330c:	fb 2d       	mov	r31, r11
    330e:	f0 64       	ori	r31, 0x40	; 64
    3310:	bf 2e       	mov	r11, r31
    3312:	07 c0       	rjmp	.+14     	; 0x3322 <vfscanf+0x204>
    3314:	8b 2d       	mov	r24, r11
    3316:	80 62       	ori	r24, 0x20	; 32
    3318:	b8 2e       	mov	r11, r24
    331a:	03 c0       	rjmp	.+6      	; 0x3322 <vfscanf+0x204>
    331c:	9b 2d       	mov	r25, r11
    331e:	90 61       	ori	r25, 0x10	; 16
    3320:	b9 2e       	mov	r11, r25
    3322:	2b 2d       	mov	r18, r11
    3324:	a7 01       	movw	r20, r14
    3326:	b8 01       	movw	r22, r16
    3328:	c6 01       	movw	r24, r12
    332a:	97 dc       	rcall	.-1746   	; 0x2c5a <conv_int>
    332c:	04 c0       	rjmp	.+8      	; 0x3336 <vfscanf+0x218>
    332e:	a7 01       	movw	r20, r14
    3330:	b8 01       	movw	r22, r16
    3332:	c6 01       	movw	r24, r12
    3334:	b9 dd       	rcall	.-1166   	; 0x2ea8 <conv_flt>
    3336:	81 11       	cpse	r24, r1
    3338:	05 c0       	rjmp	.+10     	; 0x3344 <vfscanf+0x226>
    333a:	f6 01       	movw	r30, r12
    333c:	83 81       	ldd	r24, Z+3	; 0x03
    333e:	80 73       	andi	r24, 0x30	; 48
    3340:	29 f4       	brne	.+10     	; 0x334c <vfscanf+0x22e>
    3342:	06 c0       	rjmp	.+12     	; 0x3350 <vfscanf+0x232>
    3344:	b0 fc       	sbrc	r11, 0
    3346:	f7 ce       	rjmp	.-530    	; 0x3136 <vfscanf+0x18>
    3348:	a3 94       	inc	r10
    334a:	f5 ce       	rjmp	.-534    	; 0x3136 <vfscanf+0x18>
    334c:	aa 20       	and	r10, r10
    334e:	19 f0       	breq	.+6      	; 0x3356 <vfscanf+0x238>
    3350:	8a 2d       	mov	r24, r10
    3352:	90 e0       	ldi	r25, 0x00	; 0
    3354:	02 c0       	rjmp	.+4      	; 0x335a <vfscanf+0x23c>
    3356:	8f ef       	ldi	r24, 0xFF	; 255
    3358:	9f ef       	ldi	r25, 0xFF	; 255
    335a:	21 96       	adiw	r28, 0x01	; 1
    335c:	e0 e1       	ldi	r30, 0x10	; 16
    335e:	13 c3       	rjmp	.+1574   	; 0x3986 <__epilogue_restores__+0x4>

00003360 <__subsf3>:
    3360:	50 58       	subi	r21, 0x80	; 128

00003362 <__addsf3>:
    3362:	bb 27       	eor	r27, r27
    3364:	aa 27       	eor	r26, r26
    3366:	0e d0       	rcall	.+28     	; 0x3384 <__addsf3x>
    3368:	bd c1       	rjmp	.+890    	; 0x36e4 <__fp_round>
    336a:	ae d1       	rcall	.+860    	; 0x36c8 <__fp_pscA>
    336c:	30 f0       	brcs	.+12     	; 0x337a <__addsf3+0x18>
    336e:	b3 d1       	rcall	.+870    	; 0x36d6 <__fp_pscB>
    3370:	20 f0       	brcs	.+8      	; 0x337a <__addsf3+0x18>
    3372:	31 f4       	brne	.+12     	; 0x3380 <__addsf3+0x1e>
    3374:	9f 3f       	cpi	r25, 0xFF	; 255
    3376:	11 f4       	brne	.+4      	; 0x337c <__addsf3+0x1a>
    3378:	1e f4       	brtc	.+6      	; 0x3380 <__addsf3+0x1e>
    337a:	7e c1       	rjmp	.+764    	; 0x3678 <__fp_nan>
    337c:	0e f4       	brtc	.+2      	; 0x3380 <__addsf3+0x1e>
    337e:	e0 95       	com	r30
    3380:	e7 fb       	bst	r30, 7
    3382:	74 c1       	rjmp	.+744    	; 0x366c <__fp_inf>

00003384 <__addsf3x>:
    3384:	e9 2f       	mov	r30, r25
    3386:	bf d1       	rcall	.+894    	; 0x3706 <__fp_split3>
    3388:	80 f3       	brcs	.-32     	; 0x336a <__addsf3+0x8>
    338a:	ba 17       	cp	r27, r26
    338c:	62 07       	cpc	r22, r18
    338e:	73 07       	cpc	r23, r19
    3390:	84 07       	cpc	r24, r20
    3392:	95 07       	cpc	r25, r21
    3394:	18 f0       	brcs	.+6      	; 0x339c <__addsf3x+0x18>
    3396:	71 f4       	brne	.+28     	; 0x33b4 <__addsf3x+0x30>
    3398:	9e f5       	brtc	.+102    	; 0x3400 <__addsf3x+0x7c>
    339a:	d7 c1       	rjmp	.+942    	; 0x374a <__fp_zero>
    339c:	0e f4       	brtc	.+2      	; 0x33a0 <__addsf3x+0x1c>
    339e:	e0 95       	com	r30
    33a0:	0b 2e       	mov	r0, r27
    33a2:	ba 2f       	mov	r27, r26
    33a4:	a0 2d       	mov	r26, r0
    33a6:	0b 01       	movw	r0, r22
    33a8:	b9 01       	movw	r22, r18
    33aa:	90 01       	movw	r18, r0
    33ac:	0c 01       	movw	r0, r24
    33ae:	ca 01       	movw	r24, r20
    33b0:	a0 01       	movw	r20, r0
    33b2:	11 24       	eor	r1, r1
    33b4:	ff 27       	eor	r31, r31
    33b6:	59 1b       	sub	r21, r25
    33b8:	99 f0       	breq	.+38     	; 0x33e0 <__addsf3x+0x5c>
    33ba:	59 3f       	cpi	r21, 0xF9	; 249
    33bc:	50 f4       	brcc	.+20     	; 0x33d2 <__addsf3x+0x4e>
    33be:	50 3e       	cpi	r21, 0xE0	; 224
    33c0:	68 f1       	brcs	.+90     	; 0x341c <__addsf3x+0x98>
    33c2:	1a 16       	cp	r1, r26
    33c4:	f0 40       	sbci	r31, 0x00	; 0
    33c6:	a2 2f       	mov	r26, r18
    33c8:	23 2f       	mov	r18, r19
    33ca:	34 2f       	mov	r19, r20
    33cc:	44 27       	eor	r20, r20
    33ce:	58 5f       	subi	r21, 0xF8	; 248
    33d0:	f3 cf       	rjmp	.-26     	; 0x33b8 <__addsf3x+0x34>
    33d2:	46 95       	lsr	r20
    33d4:	37 95       	ror	r19
    33d6:	27 95       	ror	r18
    33d8:	a7 95       	ror	r26
    33da:	f0 40       	sbci	r31, 0x00	; 0
    33dc:	53 95       	inc	r21
    33de:	c9 f7       	brne	.-14     	; 0x33d2 <__addsf3x+0x4e>
    33e0:	7e f4       	brtc	.+30     	; 0x3400 <__addsf3x+0x7c>
    33e2:	1f 16       	cp	r1, r31
    33e4:	ba 0b       	sbc	r27, r26
    33e6:	62 0b       	sbc	r22, r18
    33e8:	73 0b       	sbc	r23, r19
    33ea:	84 0b       	sbc	r24, r20
    33ec:	ba f0       	brmi	.+46     	; 0x341c <__addsf3x+0x98>
    33ee:	91 50       	subi	r25, 0x01	; 1
    33f0:	a1 f0       	breq	.+40     	; 0x341a <__addsf3x+0x96>
    33f2:	ff 0f       	add	r31, r31
    33f4:	bb 1f       	adc	r27, r27
    33f6:	66 1f       	adc	r22, r22
    33f8:	77 1f       	adc	r23, r23
    33fa:	88 1f       	adc	r24, r24
    33fc:	c2 f7       	brpl	.-16     	; 0x33ee <__addsf3x+0x6a>
    33fe:	0e c0       	rjmp	.+28     	; 0x341c <__addsf3x+0x98>
    3400:	ba 0f       	add	r27, r26
    3402:	62 1f       	adc	r22, r18
    3404:	73 1f       	adc	r23, r19
    3406:	84 1f       	adc	r24, r20
    3408:	48 f4       	brcc	.+18     	; 0x341c <__addsf3x+0x98>
    340a:	87 95       	ror	r24
    340c:	77 95       	ror	r23
    340e:	67 95       	ror	r22
    3410:	b7 95       	ror	r27
    3412:	f7 95       	ror	r31
    3414:	9e 3f       	cpi	r25, 0xFE	; 254
    3416:	08 f0       	brcs	.+2      	; 0x341a <__addsf3x+0x96>
    3418:	b3 cf       	rjmp	.-154    	; 0x3380 <__addsf3+0x1e>
    341a:	93 95       	inc	r25
    341c:	88 0f       	add	r24, r24
    341e:	08 f0       	brcs	.+2      	; 0x3422 <__addsf3x+0x9e>
    3420:	99 27       	eor	r25, r25
    3422:	ee 0f       	add	r30, r30
    3424:	97 95       	ror	r25
    3426:	87 95       	ror	r24
    3428:	08 95       	ret

0000342a <atan>:
    342a:	df 93       	push	r29
    342c:	dd 27       	eor	r29, r29
    342e:	b9 2f       	mov	r27, r25
    3430:	bf 77       	andi	r27, 0x7F	; 127
    3432:	40 e8       	ldi	r20, 0x80	; 128
    3434:	5f e3       	ldi	r21, 0x3F	; 63
    3436:	16 16       	cp	r1, r22
    3438:	17 06       	cpc	r1, r23
    343a:	48 07       	cpc	r20, r24
    343c:	5b 07       	cpc	r21, r27
    343e:	10 f4       	brcc	.+4      	; 0x3444 <atan+0x1a>
    3440:	d9 2f       	mov	r29, r25
    3442:	8e d1       	rcall	.+796    	; 0x3760 <inverse>
    3444:	9f 93       	push	r25
    3446:	8f 93       	push	r24
    3448:	7f 93       	push	r23
    344a:	6f 93       	push	r22
    344c:	35 d2       	rcall	.+1130   	; 0x38b8 <square>
    344e:	e8 e6       	ldi	r30, 0x68	; 104
    3450:	f0 e0       	ldi	r31, 0x00	; 0
    3452:	15 d1       	rcall	.+554    	; 0x367e <__fp_powser>
    3454:	47 d1       	rcall	.+654    	; 0x36e4 <__fp_round>
    3456:	2f 91       	pop	r18
    3458:	3f 91       	pop	r19
    345a:	4f 91       	pop	r20
    345c:	5f 91       	pop	r21
    345e:	93 d1       	rcall	.+806    	; 0x3786 <__mulsf3x>
    3460:	dd 23       	and	r29, r29
    3462:	49 f0       	breq	.+18     	; 0x3476 <atan+0x4c>
    3464:	90 58       	subi	r25, 0x80	; 128
    3466:	a2 ea       	ldi	r26, 0xA2	; 162
    3468:	2a ed       	ldi	r18, 0xDA	; 218
    346a:	3f e0       	ldi	r19, 0x0F	; 15
    346c:	49 ec       	ldi	r20, 0xC9	; 201
    346e:	5f e3       	ldi	r21, 0x3F	; 63
    3470:	d0 78       	andi	r29, 0x80	; 128
    3472:	5d 27       	eor	r21, r29
    3474:	87 df       	rcall	.-242    	; 0x3384 <__addsf3x>
    3476:	df 91       	pop	r29
    3478:	35 c1       	rjmp	.+618    	; 0x36e4 <__fp_round>

0000347a <__cmpsf2>:
    347a:	d4 d0       	rcall	.+424    	; 0x3624 <__fp_cmp>
    347c:	08 f4       	brcc	.+2      	; 0x3480 <__cmpsf2+0x6>
    347e:	81 e0       	ldi	r24, 0x01	; 1
    3480:	08 95       	ret

00003482 <__divsf3>:
    3482:	0c d0       	rcall	.+24     	; 0x349c <__divsf3x>
    3484:	2f c1       	rjmp	.+606    	; 0x36e4 <__fp_round>
    3486:	27 d1       	rcall	.+590    	; 0x36d6 <__fp_pscB>
    3488:	40 f0       	brcs	.+16     	; 0x349a <__divsf3+0x18>
    348a:	1e d1       	rcall	.+572    	; 0x36c8 <__fp_pscA>
    348c:	30 f0       	brcs	.+12     	; 0x349a <__divsf3+0x18>
    348e:	21 f4       	brne	.+8      	; 0x3498 <__divsf3+0x16>
    3490:	5f 3f       	cpi	r21, 0xFF	; 255
    3492:	19 f0       	breq	.+6      	; 0x349a <__divsf3+0x18>
    3494:	eb c0       	rjmp	.+470    	; 0x366c <__fp_inf>
    3496:	51 11       	cpse	r21, r1
    3498:	59 c1       	rjmp	.+690    	; 0x374c <__fp_szero>
    349a:	ee c0       	rjmp	.+476    	; 0x3678 <__fp_nan>

0000349c <__divsf3x>:
    349c:	34 d1       	rcall	.+616    	; 0x3706 <__fp_split3>
    349e:	98 f3       	brcs	.-26     	; 0x3486 <__divsf3+0x4>

000034a0 <__divsf3_pse>:
    34a0:	99 23       	and	r25, r25
    34a2:	c9 f3       	breq	.-14     	; 0x3496 <__divsf3+0x14>
    34a4:	55 23       	and	r21, r21
    34a6:	b1 f3       	breq	.-20     	; 0x3494 <__divsf3+0x12>
    34a8:	95 1b       	sub	r25, r21
    34aa:	55 0b       	sbc	r21, r21
    34ac:	bb 27       	eor	r27, r27
    34ae:	aa 27       	eor	r26, r26
    34b0:	62 17       	cp	r22, r18
    34b2:	73 07       	cpc	r23, r19
    34b4:	84 07       	cpc	r24, r20
    34b6:	38 f0       	brcs	.+14     	; 0x34c6 <__divsf3_pse+0x26>
    34b8:	9f 5f       	subi	r25, 0xFF	; 255
    34ba:	5f 4f       	sbci	r21, 0xFF	; 255
    34bc:	22 0f       	add	r18, r18
    34be:	33 1f       	adc	r19, r19
    34c0:	44 1f       	adc	r20, r20
    34c2:	aa 1f       	adc	r26, r26
    34c4:	a9 f3       	breq	.-22     	; 0x34b0 <__divsf3_pse+0x10>
    34c6:	33 d0       	rcall	.+102    	; 0x352e <__divsf3_pse+0x8e>
    34c8:	0e 2e       	mov	r0, r30
    34ca:	3a f0       	brmi	.+14     	; 0x34da <__divsf3_pse+0x3a>
    34cc:	e0 e8       	ldi	r30, 0x80	; 128
    34ce:	30 d0       	rcall	.+96     	; 0x3530 <__divsf3_pse+0x90>
    34d0:	91 50       	subi	r25, 0x01	; 1
    34d2:	50 40       	sbci	r21, 0x00	; 0
    34d4:	e6 95       	lsr	r30
    34d6:	00 1c       	adc	r0, r0
    34d8:	ca f7       	brpl	.-14     	; 0x34cc <__divsf3_pse+0x2c>
    34da:	29 d0       	rcall	.+82     	; 0x352e <__divsf3_pse+0x8e>
    34dc:	fe 2f       	mov	r31, r30
    34de:	27 d0       	rcall	.+78     	; 0x352e <__divsf3_pse+0x8e>
    34e0:	66 0f       	add	r22, r22
    34e2:	77 1f       	adc	r23, r23
    34e4:	88 1f       	adc	r24, r24
    34e6:	bb 1f       	adc	r27, r27
    34e8:	26 17       	cp	r18, r22
    34ea:	37 07       	cpc	r19, r23
    34ec:	48 07       	cpc	r20, r24
    34ee:	ab 07       	cpc	r26, r27
    34f0:	b0 e8       	ldi	r27, 0x80	; 128
    34f2:	09 f0       	breq	.+2      	; 0x34f6 <__divsf3_pse+0x56>
    34f4:	bb 0b       	sbc	r27, r27
    34f6:	80 2d       	mov	r24, r0
    34f8:	bf 01       	movw	r22, r30
    34fa:	ff 27       	eor	r31, r31
    34fc:	93 58       	subi	r25, 0x83	; 131
    34fe:	5f 4f       	sbci	r21, 0xFF	; 255
    3500:	2a f0       	brmi	.+10     	; 0x350c <__divsf3_pse+0x6c>
    3502:	9e 3f       	cpi	r25, 0xFE	; 254
    3504:	51 05       	cpc	r21, r1
    3506:	68 f0       	brcs	.+26     	; 0x3522 <__divsf3_pse+0x82>
    3508:	b1 c0       	rjmp	.+354    	; 0x366c <__fp_inf>
    350a:	20 c1       	rjmp	.+576    	; 0x374c <__fp_szero>
    350c:	5f 3f       	cpi	r21, 0xFF	; 255
    350e:	ec f3       	brlt	.-6      	; 0x350a <__divsf3_pse+0x6a>
    3510:	98 3e       	cpi	r25, 0xE8	; 232
    3512:	dc f3       	brlt	.-10     	; 0x350a <__divsf3_pse+0x6a>
    3514:	86 95       	lsr	r24
    3516:	77 95       	ror	r23
    3518:	67 95       	ror	r22
    351a:	b7 95       	ror	r27
    351c:	f7 95       	ror	r31
    351e:	9f 5f       	subi	r25, 0xFF	; 255
    3520:	c9 f7       	brne	.-14     	; 0x3514 <__divsf3_pse+0x74>
    3522:	88 0f       	add	r24, r24
    3524:	91 1d       	adc	r25, r1
    3526:	96 95       	lsr	r25
    3528:	87 95       	ror	r24
    352a:	97 f9       	bld	r25, 7
    352c:	08 95       	ret
    352e:	e1 e0       	ldi	r30, 0x01	; 1
    3530:	66 0f       	add	r22, r22
    3532:	77 1f       	adc	r23, r23
    3534:	88 1f       	adc	r24, r24
    3536:	bb 1f       	adc	r27, r27
    3538:	62 17       	cp	r22, r18
    353a:	73 07       	cpc	r23, r19
    353c:	84 07       	cpc	r24, r20
    353e:	ba 07       	cpc	r27, r26
    3540:	20 f0       	brcs	.+8      	; 0x354a <__divsf3_pse+0xaa>
    3542:	62 1b       	sub	r22, r18
    3544:	73 0b       	sbc	r23, r19
    3546:	84 0b       	sbc	r24, r20
    3548:	ba 0b       	sbc	r27, r26
    354a:	ee 1f       	adc	r30, r30
    354c:	88 f7       	brcc	.-30     	; 0x3530 <__divsf3_pse+0x90>
    354e:	e0 95       	com	r30
    3550:	08 95       	ret

00003552 <__fixunssfsi>:
    3552:	e1 d0       	rcall	.+450    	; 0x3716 <__fp_splitA>
    3554:	88 f0       	brcs	.+34     	; 0x3578 <__fixunssfsi+0x26>
    3556:	9f 57       	subi	r25, 0x7F	; 127
    3558:	90 f0       	brcs	.+36     	; 0x357e <__fixunssfsi+0x2c>
    355a:	b9 2f       	mov	r27, r25
    355c:	99 27       	eor	r25, r25
    355e:	b7 51       	subi	r27, 0x17	; 23
    3560:	a0 f0       	brcs	.+40     	; 0x358a <__fixunssfsi+0x38>
    3562:	d1 f0       	breq	.+52     	; 0x3598 <__fixunssfsi+0x46>
    3564:	66 0f       	add	r22, r22
    3566:	77 1f       	adc	r23, r23
    3568:	88 1f       	adc	r24, r24
    356a:	99 1f       	adc	r25, r25
    356c:	1a f0       	brmi	.+6      	; 0x3574 <__fixunssfsi+0x22>
    356e:	ba 95       	dec	r27
    3570:	c9 f7       	brne	.-14     	; 0x3564 <__fixunssfsi+0x12>
    3572:	12 c0       	rjmp	.+36     	; 0x3598 <__fixunssfsi+0x46>
    3574:	b1 30       	cpi	r27, 0x01	; 1
    3576:	81 f0       	breq	.+32     	; 0x3598 <__fixunssfsi+0x46>
    3578:	e8 d0       	rcall	.+464    	; 0x374a <__fp_zero>
    357a:	b1 e0       	ldi	r27, 0x01	; 1
    357c:	08 95       	ret
    357e:	e5 c0       	rjmp	.+458    	; 0x374a <__fp_zero>
    3580:	67 2f       	mov	r22, r23
    3582:	78 2f       	mov	r23, r24
    3584:	88 27       	eor	r24, r24
    3586:	b8 5f       	subi	r27, 0xF8	; 248
    3588:	39 f0       	breq	.+14     	; 0x3598 <__fixunssfsi+0x46>
    358a:	b9 3f       	cpi	r27, 0xF9	; 249
    358c:	cc f3       	brlt	.-14     	; 0x3580 <__fixunssfsi+0x2e>
    358e:	86 95       	lsr	r24
    3590:	77 95       	ror	r23
    3592:	67 95       	ror	r22
    3594:	b3 95       	inc	r27
    3596:	d9 f7       	brne	.-10     	; 0x358e <__fixunssfsi+0x3c>
    3598:	3e f4       	brtc	.+14     	; 0x35a8 <__fixunssfsi+0x56>
    359a:	90 95       	com	r25
    359c:	80 95       	com	r24
    359e:	70 95       	com	r23
    35a0:	61 95       	neg	r22
    35a2:	7f 4f       	sbci	r23, 0xFF	; 255
    35a4:	8f 4f       	sbci	r24, 0xFF	; 255
    35a6:	9f 4f       	sbci	r25, 0xFF	; 255
    35a8:	08 95       	ret

000035aa <__floatunsisf>:
    35aa:	e8 94       	clt
    35ac:	09 c0       	rjmp	.+18     	; 0x35c0 <__floatsisf+0x12>

000035ae <__floatsisf>:
    35ae:	97 fb       	bst	r25, 7
    35b0:	3e f4       	brtc	.+14     	; 0x35c0 <__floatsisf+0x12>
    35b2:	90 95       	com	r25
    35b4:	80 95       	com	r24
    35b6:	70 95       	com	r23
    35b8:	61 95       	neg	r22
    35ba:	7f 4f       	sbci	r23, 0xFF	; 255
    35bc:	8f 4f       	sbci	r24, 0xFF	; 255
    35be:	9f 4f       	sbci	r25, 0xFF	; 255
    35c0:	99 23       	and	r25, r25
    35c2:	a9 f0       	breq	.+42     	; 0x35ee <__floatsisf+0x40>
    35c4:	f9 2f       	mov	r31, r25
    35c6:	96 e9       	ldi	r25, 0x96	; 150
    35c8:	bb 27       	eor	r27, r27
    35ca:	93 95       	inc	r25
    35cc:	f6 95       	lsr	r31
    35ce:	87 95       	ror	r24
    35d0:	77 95       	ror	r23
    35d2:	67 95       	ror	r22
    35d4:	b7 95       	ror	r27
    35d6:	f1 11       	cpse	r31, r1
    35d8:	f8 cf       	rjmp	.-16     	; 0x35ca <__floatsisf+0x1c>
    35da:	fa f4       	brpl	.+62     	; 0x361a <__floatsisf+0x6c>
    35dc:	bb 0f       	add	r27, r27
    35de:	11 f4       	brne	.+4      	; 0x35e4 <__floatsisf+0x36>
    35e0:	60 ff       	sbrs	r22, 0
    35e2:	1b c0       	rjmp	.+54     	; 0x361a <__floatsisf+0x6c>
    35e4:	6f 5f       	subi	r22, 0xFF	; 255
    35e6:	7f 4f       	sbci	r23, 0xFF	; 255
    35e8:	8f 4f       	sbci	r24, 0xFF	; 255
    35ea:	9f 4f       	sbci	r25, 0xFF	; 255
    35ec:	16 c0       	rjmp	.+44     	; 0x361a <__floatsisf+0x6c>
    35ee:	88 23       	and	r24, r24
    35f0:	11 f0       	breq	.+4      	; 0x35f6 <__floatsisf+0x48>
    35f2:	96 e9       	ldi	r25, 0x96	; 150
    35f4:	11 c0       	rjmp	.+34     	; 0x3618 <__floatsisf+0x6a>
    35f6:	77 23       	and	r23, r23
    35f8:	21 f0       	breq	.+8      	; 0x3602 <__floatsisf+0x54>
    35fa:	9e e8       	ldi	r25, 0x8E	; 142
    35fc:	87 2f       	mov	r24, r23
    35fe:	76 2f       	mov	r23, r22
    3600:	05 c0       	rjmp	.+10     	; 0x360c <__floatsisf+0x5e>
    3602:	66 23       	and	r22, r22
    3604:	71 f0       	breq	.+28     	; 0x3622 <__floatsisf+0x74>
    3606:	96 e8       	ldi	r25, 0x86	; 134
    3608:	86 2f       	mov	r24, r22
    360a:	70 e0       	ldi	r23, 0x00	; 0
    360c:	60 e0       	ldi	r22, 0x00	; 0
    360e:	2a f0       	brmi	.+10     	; 0x361a <__floatsisf+0x6c>
    3610:	9a 95       	dec	r25
    3612:	66 0f       	add	r22, r22
    3614:	77 1f       	adc	r23, r23
    3616:	88 1f       	adc	r24, r24
    3618:	da f7       	brpl	.-10     	; 0x3610 <__floatsisf+0x62>
    361a:	88 0f       	add	r24, r24
    361c:	96 95       	lsr	r25
    361e:	87 95       	ror	r24
    3620:	97 f9       	bld	r25, 7
    3622:	08 95       	ret

00003624 <__fp_cmp>:
    3624:	99 0f       	add	r25, r25
    3626:	00 08       	sbc	r0, r0
    3628:	55 0f       	add	r21, r21
    362a:	aa 0b       	sbc	r26, r26
    362c:	e0 e8       	ldi	r30, 0x80	; 128
    362e:	fe ef       	ldi	r31, 0xFE	; 254
    3630:	16 16       	cp	r1, r22
    3632:	17 06       	cpc	r1, r23
    3634:	e8 07       	cpc	r30, r24
    3636:	f9 07       	cpc	r31, r25
    3638:	c0 f0       	brcs	.+48     	; 0x366a <__fp_cmp+0x46>
    363a:	12 16       	cp	r1, r18
    363c:	13 06       	cpc	r1, r19
    363e:	e4 07       	cpc	r30, r20
    3640:	f5 07       	cpc	r31, r21
    3642:	98 f0       	brcs	.+38     	; 0x366a <__fp_cmp+0x46>
    3644:	62 1b       	sub	r22, r18
    3646:	73 0b       	sbc	r23, r19
    3648:	84 0b       	sbc	r24, r20
    364a:	95 0b       	sbc	r25, r21
    364c:	39 f4       	brne	.+14     	; 0x365c <__fp_cmp+0x38>
    364e:	0a 26       	eor	r0, r26
    3650:	61 f0       	breq	.+24     	; 0x366a <__fp_cmp+0x46>
    3652:	23 2b       	or	r18, r19
    3654:	24 2b       	or	r18, r20
    3656:	25 2b       	or	r18, r21
    3658:	21 f4       	brne	.+8      	; 0x3662 <__fp_cmp+0x3e>
    365a:	08 95       	ret
    365c:	0a 26       	eor	r0, r26
    365e:	09 f4       	brne	.+2      	; 0x3662 <__fp_cmp+0x3e>
    3660:	a1 40       	sbci	r26, 0x01	; 1
    3662:	a6 95       	lsr	r26
    3664:	8f ef       	ldi	r24, 0xFF	; 255
    3666:	81 1d       	adc	r24, r1
    3668:	81 1d       	adc	r24, r1
    366a:	08 95       	ret

0000366c <__fp_inf>:
    366c:	97 f9       	bld	r25, 7
    366e:	9f 67       	ori	r25, 0x7F	; 127
    3670:	80 e8       	ldi	r24, 0x80	; 128
    3672:	70 e0       	ldi	r23, 0x00	; 0
    3674:	60 e0       	ldi	r22, 0x00	; 0
    3676:	08 95       	ret

00003678 <__fp_nan>:
    3678:	9f ef       	ldi	r25, 0xFF	; 255
    367a:	80 ec       	ldi	r24, 0xC0	; 192
    367c:	08 95       	ret

0000367e <__fp_powser>:
    367e:	df 93       	push	r29
    3680:	cf 93       	push	r28
    3682:	1f 93       	push	r17
    3684:	0f 93       	push	r16
    3686:	ff 92       	push	r15
    3688:	ef 92       	push	r14
    368a:	df 92       	push	r13
    368c:	7b 01       	movw	r14, r22
    368e:	8c 01       	movw	r16, r24
    3690:	68 94       	set
    3692:	05 c0       	rjmp	.+10     	; 0x369e <__fp_powser+0x20>
    3694:	da 2e       	mov	r13, r26
    3696:	ef 01       	movw	r28, r30
    3698:	76 d0       	rcall	.+236    	; 0x3786 <__mulsf3x>
    369a:	fe 01       	movw	r30, r28
    369c:	e8 94       	clt
    369e:	a5 91       	lpm	r26, Z+
    36a0:	25 91       	lpm	r18, Z+
    36a2:	35 91       	lpm	r19, Z+
    36a4:	45 91       	lpm	r20, Z+
    36a6:	55 91       	lpm	r21, Z+
    36a8:	ae f3       	brts	.-22     	; 0x3694 <__fp_powser+0x16>
    36aa:	ef 01       	movw	r28, r30
    36ac:	6b de       	rcall	.-810    	; 0x3384 <__addsf3x>
    36ae:	fe 01       	movw	r30, r28
    36b0:	97 01       	movw	r18, r14
    36b2:	a8 01       	movw	r20, r16
    36b4:	da 94       	dec	r13
    36b6:	79 f7       	brne	.-34     	; 0x3696 <__fp_powser+0x18>
    36b8:	df 90       	pop	r13
    36ba:	ef 90       	pop	r14
    36bc:	ff 90       	pop	r15
    36be:	0f 91       	pop	r16
    36c0:	1f 91       	pop	r17
    36c2:	cf 91       	pop	r28
    36c4:	df 91       	pop	r29
    36c6:	08 95       	ret

000036c8 <__fp_pscA>:
    36c8:	00 24       	eor	r0, r0
    36ca:	0a 94       	dec	r0
    36cc:	16 16       	cp	r1, r22
    36ce:	17 06       	cpc	r1, r23
    36d0:	18 06       	cpc	r1, r24
    36d2:	09 06       	cpc	r0, r25
    36d4:	08 95       	ret

000036d6 <__fp_pscB>:
    36d6:	00 24       	eor	r0, r0
    36d8:	0a 94       	dec	r0
    36da:	12 16       	cp	r1, r18
    36dc:	13 06       	cpc	r1, r19
    36de:	14 06       	cpc	r1, r20
    36e0:	05 06       	cpc	r0, r21
    36e2:	08 95       	ret

000036e4 <__fp_round>:
    36e4:	09 2e       	mov	r0, r25
    36e6:	03 94       	inc	r0
    36e8:	00 0c       	add	r0, r0
    36ea:	11 f4       	brne	.+4      	; 0x36f0 <__fp_round+0xc>
    36ec:	88 23       	and	r24, r24
    36ee:	52 f0       	brmi	.+20     	; 0x3704 <__fp_round+0x20>
    36f0:	bb 0f       	add	r27, r27
    36f2:	40 f4       	brcc	.+16     	; 0x3704 <__fp_round+0x20>
    36f4:	bf 2b       	or	r27, r31
    36f6:	11 f4       	brne	.+4      	; 0x36fc <__fp_round+0x18>
    36f8:	60 ff       	sbrs	r22, 0
    36fa:	04 c0       	rjmp	.+8      	; 0x3704 <__fp_round+0x20>
    36fc:	6f 5f       	subi	r22, 0xFF	; 255
    36fe:	7f 4f       	sbci	r23, 0xFF	; 255
    3700:	8f 4f       	sbci	r24, 0xFF	; 255
    3702:	9f 4f       	sbci	r25, 0xFF	; 255
    3704:	08 95       	ret

00003706 <__fp_split3>:
    3706:	57 fd       	sbrc	r21, 7
    3708:	90 58       	subi	r25, 0x80	; 128
    370a:	44 0f       	add	r20, r20
    370c:	55 1f       	adc	r21, r21
    370e:	59 f0       	breq	.+22     	; 0x3726 <__fp_splitA+0x10>
    3710:	5f 3f       	cpi	r21, 0xFF	; 255
    3712:	71 f0       	breq	.+28     	; 0x3730 <__fp_splitA+0x1a>
    3714:	47 95       	ror	r20

00003716 <__fp_splitA>:
    3716:	88 0f       	add	r24, r24
    3718:	97 fb       	bst	r25, 7
    371a:	99 1f       	adc	r25, r25
    371c:	61 f0       	breq	.+24     	; 0x3736 <__fp_splitA+0x20>
    371e:	9f 3f       	cpi	r25, 0xFF	; 255
    3720:	79 f0       	breq	.+30     	; 0x3740 <__fp_splitA+0x2a>
    3722:	87 95       	ror	r24
    3724:	08 95       	ret
    3726:	12 16       	cp	r1, r18
    3728:	13 06       	cpc	r1, r19
    372a:	14 06       	cpc	r1, r20
    372c:	55 1f       	adc	r21, r21
    372e:	f2 cf       	rjmp	.-28     	; 0x3714 <__fp_split3+0xe>
    3730:	46 95       	lsr	r20
    3732:	f1 df       	rcall	.-30     	; 0x3716 <__fp_splitA>
    3734:	08 c0       	rjmp	.+16     	; 0x3746 <__fp_splitA+0x30>
    3736:	16 16       	cp	r1, r22
    3738:	17 06       	cpc	r1, r23
    373a:	18 06       	cpc	r1, r24
    373c:	99 1f       	adc	r25, r25
    373e:	f1 cf       	rjmp	.-30     	; 0x3722 <__fp_splitA+0xc>
    3740:	86 95       	lsr	r24
    3742:	71 05       	cpc	r23, r1
    3744:	61 05       	cpc	r22, r1
    3746:	08 94       	sec
    3748:	08 95       	ret

0000374a <__fp_zero>:
    374a:	e8 94       	clt

0000374c <__fp_szero>:
    374c:	bb 27       	eor	r27, r27
    374e:	66 27       	eor	r22, r22
    3750:	77 27       	eor	r23, r23
    3752:	cb 01       	movw	r24, r22
    3754:	97 f9       	bld	r25, 7
    3756:	08 95       	ret

00003758 <__gesf2>:
    3758:	65 df       	rcall	.-310    	; 0x3624 <__fp_cmp>
    375a:	08 f4       	brcc	.+2      	; 0x375e <__gesf2+0x6>
    375c:	8f ef       	ldi	r24, 0xFF	; 255
    375e:	08 95       	ret

00003760 <inverse>:
    3760:	9b 01       	movw	r18, r22
    3762:	ac 01       	movw	r20, r24
    3764:	60 e0       	ldi	r22, 0x00	; 0
    3766:	70 e0       	ldi	r23, 0x00	; 0
    3768:	80 e8       	ldi	r24, 0x80	; 128
    376a:	9f e3       	ldi	r25, 0x3F	; 63
    376c:	8a ce       	rjmp	.-748    	; 0x3482 <__divsf3>

0000376e <__mulsf3>:
    376e:	0b d0       	rcall	.+22     	; 0x3786 <__mulsf3x>
    3770:	b9 cf       	rjmp	.-142    	; 0x36e4 <__fp_round>
    3772:	aa df       	rcall	.-172    	; 0x36c8 <__fp_pscA>
    3774:	28 f0       	brcs	.+10     	; 0x3780 <__mulsf3+0x12>
    3776:	af df       	rcall	.-162    	; 0x36d6 <__fp_pscB>
    3778:	18 f0       	brcs	.+6      	; 0x3780 <__mulsf3+0x12>
    377a:	95 23       	and	r25, r21
    377c:	09 f0       	breq	.+2      	; 0x3780 <__mulsf3+0x12>
    377e:	76 cf       	rjmp	.-276    	; 0x366c <__fp_inf>
    3780:	7b cf       	rjmp	.-266    	; 0x3678 <__fp_nan>
    3782:	11 24       	eor	r1, r1
    3784:	e3 cf       	rjmp	.-58     	; 0x374c <__fp_szero>

00003786 <__mulsf3x>:
    3786:	bf df       	rcall	.-130    	; 0x3706 <__fp_split3>
    3788:	a0 f3       	brcs	.-24     	; 0x3772 <__mulsf3+0x4>

0000378a <__mulsf3_pse>:
    378a:	95 9f       	mul	r25, r21
    378c:	d1 f3       	breq	.-12     	; 0x3782 <__mulsf3+0x14>
    378e:	95 0f       	add	r25, r21
    3790:	50 e0       	ldi	r21, 0x00	; 0
    3792:	55 1f       	adc	r21, r21
    3794:	62 9f       	mul	r22, r18
    3796:	f0 01       	movw	r30, r0
    3798:	72 9f       	mul	r23, r18
    379a:	bb 27       	eor	r27, r27
    379c:	f0 0d       	add	r31, r0
    379e:	b1 1d       	adc	r27, r1
    37a0:	63 9f       	mul	r22, r19
    37a2:	aa 27       	eor	r26, r26
    37a4:	f0 0d       	add	r31, r0
    37a6:	b1 1d       	adc	r27, r1
    37a8:	aa 1f       	adc	r26, r26
    37aa:	64 9f       	mul	r22, r20
    37ac:	66 27       	eor	r22, r22
    37ae:	b0 0d       	add	r27, r0
    37b0:	a1 1d       	adc	r26, r1
    37b2:	66 1f       	adc	r22, r22
    37b4:	82 9f       	mul	r24, r18
    37b6:	22 27       	eor	r18, r18
    37b8:	b0 0d       	add	r27, r0
    37ba:	a1 1d       	adc	r26, r1
    37bc:	62 1f       	adc	r22, r18
    37be:	73 9f       	mul	r23, r19
    37c0:	b0 0d       	add	r27, r0
    37c2:	a1 1d       	adc	r26, r1
    37c4:	62 1f       	adc	r22, r18
    37c6:	83 9f       	mul	r24, r19
    37c8:	a0 0d       	add	r26, r0
    37ca:	61 1d       	adc	r22, r1
    37cc:	22 1f       	adc	r18, r18
    37ce:	74 9f       	mul	r23, r20
    37d0:	33 27       	eor	r19, r19
    37d2:	a0 0d       	add	r26, r0
    37d4:	61 1d       	adc	r22, r1
    37d6:	23 1f       	adc	r18, r19
    37d8:	84 9f       	mul	r24, r20
    37da:	60 0d       	add	r22, r0
    37dc:	21 1d       	adc	r18, r1
    37de:	82 2f       	mov	r24, r18
    37e0:	76 2f       	mov	r23, r22
    37e2:	6a 2f       	mov	r22, r26
    37e4:	11 24       	eor	r1, r1
    37e6:	9f 57       	subi	r25, 0x7F	; 127
    37e8:	50 40       	sbci	r21, 0x00	; 0
    37ea:	8a f0       	brmi	.+34     	; 0x380e <__mulsf3_pse+0x84>
    37ec:	e1 f0       	breq	.+56     	; 0x3826 <__mulsf3_pse+0x9c>
    37ee:	88 23       	and	r24, r24
    37f0:	4a f0       	brmi	.+18     	; 0x3804 <__mulsf3_pse+0x7a>
    37f2:	ee 0f       	add	r30, r30
    37f4:	ff 1f       	adc	r31, r31
    37f6:	bb 1f       	adc	r27, r27
    37f8:	66 1f       	adc	r22, r22
    37fa:	77 1f       	adc	r23, r23
    37fc:	88 1f       	adc	r24, r24
    37fe:	91 50       	subi	r25, 0x01	; 1
    3800:	50 40       	sbci	r21, 0x00	; 0
    3802:	a9 f7       	brne	.-22     	; 0x37ee <__mulsf3_pse+0x64>
    3804:	9e 3f       	cpi	r25, 0xFE	; 254
    3806:	51 05       	cpc	r21, r1
    3808:	70 f0       	brcs	.+28     	; 0x3826 <__mulsf3_pse+0x9c>
    380a:	30 cf       	rjmp	.-416    	; 0x366c <__fp_inf>
    380c:	9f cf       	rjmp	.-194    	; 0x374c <__fp_szero>
    380e:	5f 3f       	cpi	r21, 0xFF	; 255
    3810:	ec f3       	brlt	.-6      	; 0x380c <__mulsf3_pse+0x82>
    3812:	98 3e       	cpi	r25, 0xE8	; 232
    3814:	dc f3       	brlt	.-10     	; 0x380c <__mulsf3_pse+0x82>
    3816:	86 95       	lsr	r24
    3818:	77 95       	ror	r23
    381a:	67 95       	ror	r22
    381c:	b7 95       	ror	r27
    381e:	f7 95       	ror	r31
    3820:	e7 95       	ror	r30
    3822:	9f 5f       	subi	r25, 0xFF	; 255
    3824:	c1 f7       	brne	.-16     	; 0x3816 <__mulsf3_pse+0x8c>
    3826:	fe 2b       	or	r31, r30
    3828:	88 0f       	add	r24, r24
    382a:	91 1d       	adc	r25, r1
    382c:	96 95       	lsr	r25
    382e:	87 95       	ror	r24
    3830:	97 f9       	bld	r25, 7
    3832:	08 95       	ret
    3834:	11 f4       	brne	.+4      	; 0x383a <__mulsf3_pse+0xb0>
    3836:	0e f4       	brtc	.+2      	; 0x383a <__mulsf3_pse+0xb0>
    3838:	1f cf       	rjmp	.-450    	; 0x3678 <__fp_nan>
    383a:	41 c0       	rjmp	.+130    	; 0x38be <__fp_mpack>

0000383c <sqrt>:
    383c:	6c df       	rcall	.-296    	; 0x3716 <__fp_splitA>
    383e:	d0 f3       	brcs	.-12     	; 0x3834 <__mulsf3_pse+0xaa>
    3840:	99 23       	and	r25, r25
    3842:	d9 f3       	breq	.-10     	; 0x383a <__mulsf3_pse+0xb0>
    3844:	ce f3       	brts	.-14     	; 0x3838 <__mulsf3_pse+0xae>
    3846:	9f 57       	subi	r25, 0x7F	; 127
    3848:	55 0b       	sbc	r21, r21
    384a:	87 ff       	sbrs	r24, 7
    384c:	46 d0       	rcall	.+140    	; 0x38da <__fp_norm2>
    384e:	00 24       	eor	r0, r0
    3850:	a0 e6       	ldi	r26, 0x60	; 96
    3852:	40 ea       	ldi	r20, 0xA0	; 160
    3854:	90 01       	movw	r18, r0
    3856:	80 58       	subi	r24, 0x80	; 128
    3858:	56 95       	lsr	r21
    385a:	97 95       	ror	r25
    385c:	28 f4       	brcc	.+10     	; 0x3868 <sqrt+0x2c>
    385e:	80 5c       	subi	r24, 0xC0	; 192
    3860:	66 0f       	add	r22, r22
    3862:	77 1f       	adc	r23, r23
    3864:	88 1f       	adc	r24, r24
    3866:	20 f0       	brcs	.+8      	; 0x3870 <sqrt+0x34>
    3868:	26 17       	cp	r18, r22
    386a:	37 07       	cpc	r19, r23
    386c:	48 07       	cpc	r20, r24
    386e:	30 f4       	brcc	.+12     	; 0x387c <sqrt+0x40>
    3870:	62 1b       	sub	r22, r18
    3872:	73 0b       	sbc	r23, r19
    3874:	84 0b       	sbc	r24, r20
    3876:	20 29       	or	r18, r0
    3878:	31 29       	or	r19, r1
    387a:	4a 2b       	or	r20, r26
    387c:	a6 95       	lsr	r26
    387e:	17 94       	ror	r1
    3880:	07 94       	ror	r0
    3882:	20 25       	eor	r18, r0
    3884:	31 25       	eor	r19, r1
    3886:	4a 27       	eor	r20, r26
    3888:	58 f7       	brcc	.-42     	; 0x3860 <sqrt+0x24>
    388a:	66 0f       	add	r22, r22
    388c:	77 1f       	adc	r23, r23
    388e:	88 1f       	adc	r24, r24
    3890:	20 f0       	brcs	.+8      	; 0x389a <sqrt+0x5e>
    3892:	26 17       	cp	r18, r22
    3894:	37 07       	cpc	r19, r23
    3896:	48 07       	cpc	r20, r24
    3898:	30 f4       	brcc	.+12     	; 0x38a6 <sqrt+0x6a>
    389a:	62 0b       	sbc	r22, r18
    389c:	73 0b       	sbc	r23, r19
    389e:	84 0b       	sbc	r24, r20
    38a0:	20 0d       	add	r18, r0
    38a2:	31 1d       	adc	r19, r1
    38a4:	41 1d       	adc	r20, r1
    38a6:	a0 95       	com	r26
    38a8:	81 f7       	brne	.-32     	; 0x388a <sqrt+0x4e>
    38aa:	b9 01       	movw	r22, r18
    38ac:	84 2f       	mov	r24, r20
    38ae:	91 58       	subi	r25, 0x81	; 129
    38b0:	88 0f       	add	r24, r24
    38b2:	96 95       	lsr	r25
    38b4:	87 95       	ror	r24
    38b6:	08 95       	ret

000038b8 <square>:
    38b8:	9b 01       	movw	r18, r22
    38ba:	ac 01       	movw	r20, r24
    38bc:	58 cf       	rjmp	.-336    	; 0x376e <__mulsf3>

000038be <__fp_mpack>:
    38be:	9f 3f       	cpi	r25, 0xFF	; 255
    38c0:	31 f0       	breq	.+12     	; 0x38ce <__fp_mpack_finite+0xc>

000038c2 <__fp_mpack_finite>:
    38c2:	91 50       	subi	r25, 0x01	; 1
    38c4:	20 f4       	brcc	.+8      	; 0x38ce <__fp_mpack_finite+0xc>
    38c6:	87 95       	ror	r24
    38c8:	77 95       	ror	r23
    38ca:	67 95       	ror	r22
    38cc:	b7 95       	ror	r27
    38ce:	88 0f       	add	r24, r24
    38d0:	91 1d       	adc	r25, r1
    38d2:	96 95       	lsr	r25
    38d4:	87 95       	ror	r24
    38d6:	97 f9       	bld	r25, 7
    38d8:	08 95       	ret

000038da <__fp_norm2>:
    38da:	91 50       	subi	r25, 0x01	; 1
    38dc:	50 40       	sbci	r21, 0x00	; 0
    38de:	66 0f       	add	r22, r22
    38e0:	77 1f       	adc	r23, r23
    38e2:	88 1f       	adc	r24, r24
    38e4:	d2 f7       	brpl	.-12     	; 0x38da <__fp_norm2>
    38e6:	08 95       	ret

000038e8 <__udivmodsi4>:
    38e8:	a1 e2       	ldi	r26, 0x21	; 33
    38ea:	1a 2e       	mov	r1, r26
    38ec:	aa 1b       	sub	r26, r26
    38ee:	bb 1b       	sub	r27, r27
    38f0:	fd 01       	movw	r30, r26
    38f2:	0d c0       	rjmp	.+26     	; 0x390e <__udivmodsi4_ep>

000038f4 <__udivmodsi4_loop>:
    38f4:	aa 1f       	adc	r26, r26
    38f6:	bb 1f       	adc	r27, r27
    38f8:	ee 1f       	adc	r30, r30
    38fa:	ff 1f       	adc	r31, r31
    38fc:	a2 17       	cp	r26, r18
    38fe:	b3 07       	cpc	r27, r19
    3900:	e4 07       	cpc	r30, r20
    3902:	f5 07       	cpc	r31, r21
    3904:	20 f0       	brcs	.+8      	; 0x390e <__udivmodsi4_ep>
    3906:	a2 1b       	sub	r26, r18
    3908:	b3 0b       	sbc	r27, r19
    390a:	e4 0b       	sbc	r30, r20
    390c:	f5 0b       	sbc	r31, r21

0000390e <__udivmodsi4_ep>:
    390e:	66 1f       	adc	r22, r22
    3910:	77 1f       	adc	r23, r23
    3912:	88 1f       	adc	r24, r24
    3914:	99 1f       	adc	r25, r25
    3916:	1a 94       	dec	r1
    3918:	69 f7       	brne	.-38     	; 0x38f4 <__udivmodsi4_loop>
    391a:	60 95       	com	r22
    391c:	70 95       	com	r23
    391e:	80 95       	com	r24
    3920:	90 95       	com	r25
    3922:	9b 01       	movw	r18, r22
    3924:	ac 01       	movw	r20, r24
    3926:	bd 01       	movw	r22, r26
    3928:	cf 01       	movw	r24, r30
    392a:	08 95       	ret

0000392c <__umulhisi3>:
    392c:	a2 9f       	mul	r26, r18
    392e:	b0 01       	movw	r22, r0
    3930:	b3 9f       	mul	r27, r19
    3932:	c0 01       	movw	r24, r0
    3934:	a3 9f       	mul	r26, r19
    3936:	70 0d       	add	r23, r0
    3938:	81 1d       	adc	r24, r1
    393a:	11 24       	eor	r1, r1
    393c:	91 1d       	adc	r25, r1
    393e:	b2 9f       	mul	r27, r18
    3940:	70 0d       	add	r23, r0
    3942:	81 1d       	adc	r24, r1
    3944:	11 24       	eor	r1, r1
    3946:	91 1d       	adc	r25, r1
    3948:	08 95       	ret

0000394a <__prologue_saves__>:
    394a:	2f 92       	push	r2
    394c:	3f 92       	push	r3
    394e:	4f 92       	push	r4
    3950:	5f 92       	push	r5
    3952:	6f 92       	push	r6
    3954:	7f 92       	push	r7
    3956:	8f 92       	push	r8
    3958:	9f 92       	push	r9
    395a:	af 92       	push	r10
    395c:	bf 92       	push	r11
    395e:	cf 92       	push	r12
    3960:	df 92       	push	r13
    3962:	ef 92       	push	r14
    3964:	ff 92       	push	r15
    3966:	0f 93       	push	r16
    3968:	1f 93       	push	r17
    396a:	cf 93       	push	r28
    396c:	df 93       	push	r29
    396e:	cd b7       	in	r28, 0x3d	; 61
    3970:	de b7       	in	r29, 0x3e	; 62
    3972:	ca 1b       	sub	r28, r26
    3974:	db 0b       	sbc	r29, r27
    3976:	0f b6       	in	r0, 0x3f	; 63
    3978:	f8 94       	cli
    397a:	de bf       	out	0x3e, r29	; 62
    397c:	0f be       	out	0x3f, r0	; 63
    397e:	cd bf       	out	0x3d, r28	; 61
    3980:	09 94       	ijmp

00003982 <__epilogue_restores__>:
    3982:	2a 88       	ldd	r2, Y+18	; 0x12
    3984:	39 88       	ldd	r3, Y+17	; 0x11
    3986:	48 88       	ldd	r4, Y+16	; 0x10
    3988:	5f 84       	ldd	r5, Y+15	; 0x0f
    398a:	6e 84       	ldd	r6, Y+14	; 0x0e
    398c:	7d 84       	ldd	r7, Y+13	; 0x0d
    398e:	8c 84       	ldd	r8, Y+12	; 0x0c
    3990:	9b 84       	ldd	r9, Y+11	; 0x0b
    3992:	aa 84       	ldd	r10, Y+10	; 0x0a
    3994:	b9 84       	ldd	r11, Y+9	; 0x09
    3996:	c8 84       	ldd	r12, Y+8	; 0x08
    3998:	df 80       	ldd	r13, Y+7	; 0x07
    399a:	ee 80       	ldd	r14, Y+6	; 0x06
    399c:	fd 80       	ldd	r15, Y+5	; 0x05
    399e:	0c 81       	ldd	r16, Y+4	; 0x04
    39a0:	1b 81       	ldd	r17, Y+3	; 0x03
    39a2:	aa 81       	ldd	r26, Y+2	; 0x02
    39a4:	b9 81       	ldd	r27, Y+1	; 0x01
    39a6:	ce 0f       	add	r28, r30
    39a8:	d1 1d       	adc	r29, r1
    39aa:	0f b6       	in	r0, 0x3f	; 63
    39ac:	f8 94       	cli
    39ae:	de bf       	out	0x3e, r29	; 62
    39b0:	0f be       	out	0x3f, r0	; 63
    39b2:	cd bf       	out	0x3d, r28	; 61
    39b4:	ed 01       	movw	r28, r26
    39b6:	08 95       	ret

000039b8 <atof>:
    39b8:	66 27       	eor	r22, r22
    39ba:	77 27       	eor	r23, r23
    39bc:	76 c2       	rjmp	.+1260   	; 0x3eaa <strtod>

000039be <atoi>:
    39be:	fc 01       	movw	r30, r24
    39c0:	88 27       	eor	r24, r24
    39c2:	99 27       	eor	r25, r25
    39c4:	e8 94       	clt
    39c6:	21 91       	ld	r18, Z+
    39c8:	20 32       	cpi	r18, 0x20	; 32
    39ca:	e9 f3       	breq	.-6      	; 0x39c6 <atoi+0x8>
    39cc:	29 30       	cpi	r18, 0x09	; 9
    39ce:	10 f0       	brcs	.+4      	; 0x39d4 <atoi+0x16>
    39d0:	2e 30       	cpi	r18, 0x0E	; 14
    39d2:	c8 f3       	brcs	.-14     	; 0x39c6 <atoi+0x8>
    39d4:	2b 32       	cpi	r18, 0x2B	; 43
    39d6:	39 f0       	breq	.+14     	; 0x39e6 <atoi+0x28>
    39d8:	2d 32       	cpi	r18, 0x2D	; 45
    39da:	31 f4       	brne	.+12     	; 0x39e8 <atoi+0x2a>
    39dc:	68 94       	set
    39de:	03 c0       	rjmp	.+6      	; 0x39e6 <atoi+0x28>
    39e0:	14 d1       	rcall	.+552    	; 0x3c0a <__mulhi_const_10>
    39e2:	82 0f       	add	r24, r18
    39e4:	91 1d       	adc	r25, r1
    39e6:	21 91       	ld	r18, Z+
    39e8:	20 53       	subi	r18, 0x30	; 48
    39ea:	2a 30       	cpi	r18, 0x0A	; 10
    39ec:	c8 f3       	brcs	.-14     	; 0x39e0 <atoi+0x22>
    39ee:	1e f4       	brtc	.+6      	; 0x39f6 <atoi+0x38>
    39f0:	90 95       	com	r25
    39f2:	81 95       	neg	r24
    39f4:	9f 4f       	sbci	r25, 0xFF	; 255
    39f6:	08 95       	ret

000039f8 <__ftoa_engine>:
    39f8:	28 30       	cpi	r18, 0x08	; 8
    39fa:	08 f0       	brcs	.+2      	; 0x39fe <__ftoa_engine+0x6>
    39fc:	27 e0       	ldi	r18, 0x07	; 7
    39fe:	33 27       	eor	r19, r19
    3a00:	da 01       	movw	r26, r20
    3a02:	99 0f       	add	r25, r25
    3a04:	31 1d       	adc	r19, r1
    3a06:	87 fd       	sbrc	r24, 7
    3a08:	91 60       	ori	r25, 0x01	; 1
    3a0a:	00 96       	adiw	r24, 0x00	; 0
    3a0c:	61 05       	cpc	r22, r1
    3a0e:	71 05       	cpc	r23, r1
    3a10:	39 f4       	brne	.+14     	; 0x3a20 <__ftoa_engine+0x28>
    3a12:	32 60       	ori	r19, 0x02	; 2
    3a14:	2e 5f       	subi	r18, 0xFE	; 254
    3a16:	3d 93       	st	X+, r19
    3a18:	30 e3       	ldi	r19, 0x30	; 48
    3a1a:	2a 95       	dec	r18
    3a1c:	e1 f7       	brne	.-8      	; 0x3a16 <__ftoa_engine+0x1e>
    3a1e:	08 95       	ret
    3a20:	9f 3f       	cpi	r25, 0xFF	; 255
    3a22:	30 f0       	brcs	.+12     	; 0x3a30 <__ftoa_engine+0x38>
    3a24:	80 38       	cpi	r24, 0x80	; 128
    3a26:	71 05       	cpc	r23, r1
    3a28:	61 05       	cpc	r22, r1
    3a2a:	09 f0       	breq	.+2      	; 0x3a2e <__ftoa_engine+0x36>
    3a2c:	3c 5f       	subi	r19, 0xFC	; 252
    3a2e:	3c 5f       	subi	r19, 0xFC	; 252
    3a30:	3d 93       	st	X+, r19
    3a32:	91 30       	cpi	r25, 0x01	; 1
    3a34:	08 f0       	brcs	.+2      	; 0x3a38 <__ftoa_engine+0x40>
    3a36:	80 68       	ori	r24, 0x80	; 128
    3a38:	91 1d       	adc	r25, r1
    3a3a:	df 93       	push	r29
    3a3c:	cf 93       	push	r28
    3a3e:	1f 93       	push	r17
    3a40:	0f 93       	push	r16
    3a42:	ff 92       	push	r15
    3a44:	ef 92       	push	r14
    3a46:	19 2f       	mov	r17, r25
    3a48:	98 7f       	andi	r25, 0xF8	; 248
    3a4a:	96 95       	lsr	r25
    3a4c:	e9 2f       	mov	r30, r25
    3a4e:	96 95       	lsr	r25
    3a50:	96 95       	lsr	r25
    3a52:	e9 0f       	add	r30, r25
    3a54:	ff 27       	eor	r31, r31
    3a56:	e8 50       	subi	r30, 0x08	; 8
    3a58:	ff 4f       	sbci	r31, 0xFF	; 255
    3a5a:	99 27       	eor	r25, r25
    3a5c:	33 27       	eor	r19, r19
    3a5e:	ee 24       	eor	r14, r14
    3a60:	ff 24       	eor	r15, r15
    3a62:	a7 01       	movw	r20, r14
    3a64:	e7 01       	movw	r28, r14
    3a66:	05 90       	lpm	r0, Z+
    3a68:	08 94       	sec
    3a6a:	07 94       	ror	r0
    3a6c:	28 f4       	brcc	.+10     	; 0x3a78 <__ftoa_engine+0x80>
    3a6e:	36 0f       	add	r19, r22
    3a70:	e7 1e       	adc	r14, r23
    3a72:	f8 1e       	adc	r15, r24
    3a74:	49 1f       	adc	r20, r25
    3a76:	51 1d       	adc	r21, r1
    3a78:	66 0f       	add	r22, r22
    3a7a:	77 1f       	adc	r23, r23
    3a7c:	88 1f       	adc	r24, r24
    3a7e:	99 1f       	adc	r25, r25
    3a80:	06 94       	lsr	r0
    3a82:	a1 f7       	brne	.-24     	; 0x3a6c <__ftoa_engine+0x74>
    3a84:	05 90       	lpm	r0, Z+
    3a86:	07 94       	ror	r0
    3a88:	28 f4       	brcc	.+10     	; 0x3a94 <__ftoa_engine+0x9c>
    3a8a:	e7 0e       	add	r14, r23
    3a8c:	f8 1e       	adc	r15, r24
    3a8e:	49 1f       	adc	r20, r25
    3a90:	56 1f       	adc	r21, r22
    3a92:	c1 1d       	adc	r28, r1
    3a94:	77 0f       	add	r23, r23
    3a96:	88 1f       	adc	r24, r24
    3a98:	99 1f       	adc	r25, r25
    3a9a:	66 1f       	adc	r22, r22
    3a9c:	06 94       	lsr	r0
    3a9e:	a1 f7       	brne	.-24     	; 0x3a88 <__ftoa_engine+0x90>
    3aa0:	05 90       	lpm	r0, Z+
    3aa2:	07 94       	ror	r0
    3aa4:	28 f4       	brcc	.+10     	; 0x3ab0 <__ftoa_engine+0xb8>
    3aa6:	f8 0e       	add	r15, r24
    3aa8:	49 1f       	adc	r20, r25
    3aaa:	56 1f       	adc	r21, r22
    3aac:	c7 1f       	adc	r28, r23
    3aae:	d1 1d       	adc	r29, r1
    3ab0:	88 0f       	add	r24, r24
    3ab2:	99 1f       	adc	r25, r25
    3ab4:	66 1f       	adc	r22, r22
    3ab6:	77 1f       	adc	r23, r23
    3ab8:	06 94       	lsr	r0
    3aba:	a1 f7       	brne	.-24     	; 0x3aa4 <__ftoa_engine+0xac>
    3abc:	05 90       	lpm	r0, Z+
    3abe:	07 94       	ror	r0
    3ac0:	20 f4       	brcc	.+8      	; 0x3aca <__ftoa_engine+0xd2>
    3ac2:	49 0f       	add	r20, r25
    3ac4:	56 1f       	adc	r21, r22
    3ac6:	c7 1f       	adc	r28, r23
    3ac8:	d8 1f       	adc	r29, r24
    3aca:	99 0f       	add	r25, r25
    3acc:	66 1f       	adc	r22, r22
    3ace:	77 1f       	adc	r23, r23
    3ad0:	88 1f       	adc	r24, r24
    3ad2:	06 94       	lsr	r0
    3ad4:	a9 f7       	brne	.-22     	; 0x3ac0 <__ftoa_engine+0xc8>
    3ad6:	84 91       	lpm	r24, Z
    3ad8:	10 95       	com	r17
    3ada:	17 70       	andi	r17, 0x07	; 7
    3adc:	41 f0       	breq	.+16     	; 0x3aee <__ftoa_engine+0xf6>
    3ade:	d6 95       	lsr	r29
    3ae0:	c7 95       	ror	r28
    3ae2:	57 95       	ror	r21
    3ae4:	47 95       	ror	r20
    3ae6:	f7 94       	ror	r15
    3ae8:	e7 94       	ror	r14
    3aea:	1a 95       	dec	r17
    3aec:	c1 f7       	brne	.-16     	; 0x3ade <__ftoa_engine+0xe6>
    3aee:	ee e9       	ldi	r30, 0x9E	; 158
    3af0:	f0 e0       	ldi	r31, 0x00	; 0
    3af2:	68 94       	set
    3af4:	15 90       	lpm	r1, Z+
    3af6:	15 91       	lpm	r17, Z+
    3af8:	35 91       	lpm	r19, Z+
    3afa:	65 91       	lpm	r22, Z+
    3afc:	95 91       	lpm	r25, Z+
    3afe:	05 90       	lpm	r0, Z+
    3b00:	7f e2       	ldi	r23, 0x2F	; 47
    3b02:	73 95       	inc	r23
    3b04:	e1 18       	sub	r14, r1
    3b06:	f1 0a       	sbc	r15, r17
    3b08:	43 0b       	sbc	r20, r19
    3b0a:	56 0b       	sbc	r21, r22
    3b0c:	c9 0b       	sbc	r28, r25
    3b0e:	d0 09       	sbc	r29, r0
    3b10:	c0 f7       	brcc	.-16     	; 0x3b02 <__ftoa_engine+0x10a>
    3b12:	e1 0c       	add	r14, r1
    3b14:	f1 1e       	adc	r15, r17
    3b16:	43 1f       	adc	r20, r19
    3b18:	56 1f       	adc	r21, r22
    3b1a:	c9 1f       	adc	r28, r25
    3b1c:	d0 1d       	adc	r29, r0
    3b1e:	7e f4       	brtc	.+30     	; 0x3b3e <__ftoa_engine+0x146>
    3b20:	70 33       	cpi	r23, 0x30	; 48
    3b22:	11 f4       	brne	.+4      	; 0x3b28 <__ftoa_engine+0x130>
    3b24:	8a 95       	dec	r24
    3b26:	e6 cf       	rjmp	.-52     	; 0x3af4 <__ftoa_engine+0xfc>
    3b28:	e8 94       	clt
    3b2a:	01 50       	subi	r16, 0x01	; 1
    3b2c:	30 f0       	brcs	.+12     	; 0x3b3a <__ftoa_engine+0x142>
    3b2e:	08 0f       	add	r16, r24
    3b30:	0a f4       	brpl	.+2      	; 0x3b34 <__ftoa_engine+0x13c>
    3b32:	00 27       	eor	r16, r16
    3b34:	02 17       	cp	r16, r18
    3b36:	08 f4       	brcc	.+2      	; 0x3b3a <__ftoa_engine+0x142>
    3b38:	20 2f       	mov	r18, r16
    3b3a:	23 95       	inc	r18
    3b3c:	02 2f       	mov	r16, r18
    3b3e:	7a 33       	cpi	r23, 0x3A	; 58
    3b40:	28 f0       	brcs	.+10     	; 0x3b4c <__ftoa_engine+0x154>
    3b42:	79 e3       	ldi	r23, 0x39	; 57
    3b44:	7d 93       	st	X+, r23
    3b46:	2a 95       	dec	r18
    3b48:	e9 f7       	brne	.-6      	; 0x3b44 <__ftoa_engine+0x14c>
    3b4a:	10 c0       	rjmp	.+32     	; 0x3b6c <__ftoa_engine+0x174>
    3b4c:	7d 93       	st	X+, r23
    3b4e:	2a 95       	dec	r18
    3b50:	89 f6       	brne	.-94     	; 0x3af4 <__ftoa_engine+0xfc>
    3b52:	06 94       	lsr	r0
    3b54:	97 95       	ror	r25
    3b56:	67 95       	ror	r22
    3b58:	37 95       	ror	r19
    3b5a:	17 95       	ror	r17
    3b5c:	17 94       	ror	r1
    3b5e:	e1 18       	sub	r14, r1
    3b60:	f1 0a       	sbc	r15, r17
    3b62:	43 0b       	sbc	r20, r19
    3b64:	56 0b       	sbc	r21, r22
    3b66:	c9 0b       	sbc	r28, r25
    3b68:	d0 09       	sbc	r29, r0
    3b6a:	98 f0       	brcs	.+38     	; 0x3b92 <__ftoa_engine+0x19a>
    3b6c:	23 95       	inc	r18
    3b6e:	7e 91       	ld	r23, -X
    3b70:	73 95       	inc	r23
    3b72:	7a 33       	cpi	r23, 0x3A	; 58
    3b74:	08 f0       	brcs	.+2      	; 0x3b78 <__ftoa_engine+0x180>
    3b76:	70 e3       	ldi	r23, 0x30	; 48
    3b78:	7c 93       	st	X, r23
    3b7a:	20 13       	cpse	r18, r16
    3b7c:	b8 f7       	brcc	.-18     	; 0x3b6c <__ftoa_engine+0x174>
    3b7e:	7e 91       	ld	r23, -X
    3b80:	70 61       	ori	r23, 0x10	; 16
    3b82:	7d 93       	st	X+, r23
    3b84:	30 f0       	brcs	.+12     	; 0x3b92 <__ftoa_engine+0x19a>
    3b86:	83 95       	inc	r24
    3b88:	71 e3       	ldi	r23, 0x31	; 49
    3b8a:	7d 93       	st	X+, r23
    3b8c:	70 e3       	ldi	r23, 0x30	; 48
    3b8e:	2a 95       	dec	r18
    3b90:	e1 f7       	brne	.-8      	; 0x3b8a <__ftoa_engine+0x192>
    3b92:	11 24       	eor	r1, r1
    3b94:	ef 90       	pop	r14
    3b96:	ff 90       	pop	r15
    3b98:	0f 91       	pop	r16
    3b9a:	1f 91       	pop	r17
    3b9c:	cf 91       	pop	r28
    3b9e:	df 91       	pop	r29
    3ba0:	99 27       	eor	r25, r25
    3ba2:	87 fd       	sbrc	r24, 7
    3ba4:	90 95       	com	r25
    3ba6:	08 95       	ret

00003ba8 <isspace>:
    3ba8:	91 11       	cpse	r25, r1
    3baa:	d1 c2       	rjmp	.+1442   	; 0x414e <__ctype_isfalse>
    3bac:	80 32       	cpi	r24, 0x20	; 32
    3bae:	19 f0       	breq	.+6      	; 0x3bb6 <isspace+0xe>
    3bb0:	89 50       	subi	r24, 0x09	; 9
    3bb2:	85 50       	subi	r24, 0x05	; 5
    3bb4:	d0 f7       	brcc	.-12     	; 0x3baa <isspace+0x2>
    3bb6:	08 95       	ret

00003bb8 <tolower>:
    3bb8:	91 11       	cpse	r25, r1
    3bba:	08 95       	ret
    3bbc:	81 54       	subi	r24, 0x41	; 65
    3bbe:	8a 51       	subi	r24, 0x1A	; 26
    3bc0:	08 f4       	brcc	.+2      	; 0x3bc4 <tolower+0xc>
    3bc2:	80 5e       	subi	r24, 0xE0	; 224
    3bc4:	85 5a       	subi	r24, 0xA5	; 165
    3bc6:	08 95       	ret

00003bc8 <strchr_P>:
    3bc8:	fc 01       	movw	r30, r24
    3bca:	05 90       	lpm	r0, Z+
    3bcc:	06 16       	cp	r0, r22
    3bce:	21 f0       	breq	.+8      	; 0x3bd8 <strchr_P+0x10>
    3bd0:	00 20       	and	r0, r0
    3bd2:	d9 f7       	brne	.-10     	; 0x3bca <strchr_P+0x2>
    3bd4:	c0 01       	movw	r24, r0
    3bd6:	08 95       	ret
    3bd8:	31 97       	sbiw	r30, 0x01	; 1
    3bda:	cf 01       	movw	r24, r30
    3bdc:	08 95       	ret

00003bde <strnlen_P>:
    3bde:	fc 01       	movw	r30, r24
    3be0:	05 90       	lpm	r0, Z+
    3be2:	61 50       	subi	r22, 0x01	; 1
    3be4:	70 40       	sbci	r23, 0x00	; 0
    3be6:	01 10       	cpse	r0, r1
    3be8:	d8 f7       	brcc	.-10     	; 0x3be0 <strnlen_P+0x2>
    3bea:	80 95       	com	r24
    3bec:	90 95       	com	r25
    3bee:	8e 0f       	add	r24, r30
    3bf0:	9f 1f       	adc	r25, r31
    3bf2:	08 95       	ret

00003bf4 <strnlen>:
    3bf4:	fc 01       	movw	r30, r24
    3bf6:	61 50       	subi	r22, 0x01	; 1
    3bf8:	70 40       	sbci	r23, 0x00	; 0
    3bfa:	01 90       	ld	r0, Z+
    3bfc:	01 10       	cpse	r0, r1
    3bfe:	d8 f7       	brcc	.-10     	; 0x3bf6 <strnlen+0x2>
    3c00:	80 95       	com	r24
    3c02:	90 95       	com	r25
    3c04:	8e 0f       	add	r24, r30
    3c06:	9f 1f       	adc	r25, r31
    3c08:	08 95       	ret

00003c0a <__mulhi_const_10>:
    3c0a:	7a e0       	ldi	r23, 0x0A	; 10
    3c0c:	97 9f       	mul	r25, r23
    3c0e:	90 2d       	mov	r25, r0
    3c10:	87 9f       	mul	r24, r23
    3c12:	80 2d       	mov	r24, r0
    3c14:	91 0d       	add	r25, r1
    3c16:	11 24       	eor	r1, r1
    3c18:	08 95       	ret

00003c1a <fgetc>:
    3c1a:	cf 93       	push	r28
    3c1c:	df 93       	push	r29
    3c1e:	ec 01       	movw	r28, r24
    3c20:	2b 81       	ldd	r18, Y+3	; 0x03
    3c22:	20 ff       	sbrs	r18, 0
    3c24:	33 c0       	rjmp	.+102    	; 0x3c8c <fgetc+0x72>
    3c26:	26 ff       	sbrs	r18, 6
    3c28:	0a c0       	rjmp	.+20     	; 0x3c3e <fgetc+0x24>
    3c2a:	2f 7b       	andi	r18, 0xBF	; 191
    3c2c:	2b 83       	std	Y+3, r18	; 0x03
    3c2e:	8e 81       	ldd	r24, Y+6	; 0x06
    3c30:	9f 81       	ldd	r25, Y+7	; 0x07
    3c32:	01 96       	adiw	r24, 0x01	; 1
    3c34:	9f 83       	std	Y+7, r25	; 0x07
    3c36:	8e 83       	std	Y+6, r24	; 0x06
    3c38:	8a 81       	ldd	r24, Y+2	; 0x02
    3c3a:	90 e0       	ldi	r25, 0x00	; 0
    3c3c:	29 c0       	rjmp	.+82     	; 0x3c90 <fgetc+0x76>
    3c3e:	22 ff       	sbrs	r18, 2
    3c40:	0f c0       	rjmp	.+30     	; 0x3c60 <fgetc+0x46>
    3c42:	e8 81       	ld	r30, Y
    3c44:	f9 81       	ldd	r31, Y+1	; 0x01
    3c46:	80 81       	ld	r24, Z
    3c48:	08 2e       	mov	r0, r24
    3c4a:	00 0c       	add	r0, r0
    3c4c:	99 0b       	sbc	r25, r25
    3c4e:	00 97       	sbiw	r24, 0x00	; 0
    3c50:	19 f4       	brne	.+6      	; 0x3c58 <fgetc+0x3e>
    3c52:	20 62       	ori	r18, 0x20	; 32
    3c54:	2b 83       	std	Y+3, r18	; 0x03
    3c56:	1a c0       	rjmp	.+52     	; 0x3c8c <fgetc+0x72>
    3c58:	31 96       	adiw	r30, 0x01	; 1
    3c5a:	f9 83       	std	Y+1, r31	; 0x01
    3c5c:	e8 83       	st	Y, r30
    3c5e:	0e c0       	rjmp	.+28     	; 0x3c7c <fgetc+0x62>
    3c60:	ea 85       	ldd	r30, Y+10	; 0x0a
    3c62:	fb 85       	ldd	r31, Y+11	; 0x0b
    3c64:	09 95       	icall
    3c66:	97 ff       	sbrs	r25, 7
    3c68:	09 c0       	rjmp	.+18     	; 0x3c7c <fgetc+0x62>
    3c6a:	2b 81       	ldd	r18, Y+3	; 0x03
    3c6c:	01 96       	adiw	r24, 0x01	; 1
    3c6e:	11 f0       	breq	.+4      	; 0x3c74 <fgetc+0x5a>
    3c70:	80 e2       	ldi	r24, 0x20	; 32
    3c72:	01 c0       	rjmp	.+2      	; 0x3c76 <fgetc+0x5c>
    3c74:	80 e1       	ldi	r24, 0x10	; 16
    3c76:	82 2b       	or	r24, r18
    3c78:	8b 83       	std	Y+3, r24	; 0x03
    3c7a:	08 c0       	rjmp	.+16     	; 0x3c8c <fgetc+0x72>
    3c7c:	2e 81       	ldd	r18, Y+6	; 0x06
    3c7e:	3f 81       	ldd	r19, Y+7	; 0x07
    3c80:	2f 5f       	subi	r18, 0xFF	; 255
    3c82:	3f 4f       	sbci	r19, 0xFF	; 255
    3c84:	3f 83       	std	Y+7, r19	; 0x07
    3c86:	2e 83       	std	Y+6, r18	; 0x06
    3c88:	99 27       	eor	r25, r25
    3c8a:	02 c0       	rjmp	.+4      	; 0x3c90 <fgetc+0x76>
    3c8c:	8f ef       	ldi	r24, 0xFF	; 255
    3c8e:	9f ef       	ldi	r25, 0xFF	; 255
    3c90:	df 91       	pop	r29
    3c92:	cf 91       	pop	r28
    3c94:	08 95       	ret

00003c96 <fprintf>:
    3c96:	a0 e0       	ldi	r26, 0x00	; 0
    3c98:	b0 e0       	ldi	r27, 0x00	; 0
    3c9a:	e0 e5       	ldi	r30, 0x50	; 80
    3c9c:	fe e1       	ldi	r31, 0x1E	; 30
    3c9e:	65 ce       	rjmp	.-822    	; 0x396a <__prologue_saves__+0x20>
    3ca0:	ae 01       	movw	r20, r28
    3ca2:	47 5f       	subi	r20, 0xF7	; 247
    3ca4:	5f 4f       	sbci	r21, 0xFF	; 255
    3ca6:	6f 81       	ldd	r22, Y+7	; 0x07
    3ca8:	78 85       	ldd	r23, Y+8	; 0x08
    3caa:	8d 81       	ldd	r24, Y+5	; 0x05
    3cac:	9e 81       	ldd	r25, Y+6	; 0x06
    3cae:	0e 94 6f 12 	call	0x24de	; 0x24de <vfprintf>
    3cb2:	e2 e0       	ldi	r30, 0x02	; 2
    3cb4:	76 ce       	rjmp	.-788    	; 0x39a2 <__epilogue_restores__+0x20>

00003cb6 <fputc>:
    3cb6:	0f 93       	push	r16
    3cb8:	1f 93       	push	r17
    3cba:	cf 93       	push	r28
    3cbc:	df 93       	push	r29
    3cbe:	fb 01       	movw	r30, r22
    3cc0:	23 81       	ldd	r18, Z+3	; 0x03
    3cc2:	21 fd       	sbrc	r18, 1
    3cc4:	03 c0       	rjmp	.+6      	; 0x3ccc <fputc+0x16>
    3cc6:	8f ef       	ldi	r24, 0xFF	; 255
    3cc8:	9f ef       	ldi	r25, 0xFF	; 255
    3cca:	28 c0       	rjmp	.+80     	; 0x3d1c <fputc+0x66>
    3ccc:	22 ff       	sbrs	r18, 2
    3cce:	16 c0       	rjmp	.+44     	; 0x3cfc <fputc+0x46>
    3cd0:	46 81       	ldd	r20, Z+6	; 0x06
    3cd2:	57 81       	ldd	r21, Z+7	; 0x07
    3cd4:	24 81       	ldd	r18, Z+4	; 0x04
    3cd6:	35 81       	ldd	r19, Z+5	; 0x05
    3cd8:	42 17       	cp	r20, r18
    3cda:	53 07       	cpc	r21, r19
    3cdc:	44 f4       	brge	.+16     	; 0x3cee <fputc+0x38>
    3cde:	a0 81       	ld	r26, Z
    3ce0:	b1 81       	ldd	r27, Z+1	; 0x01
    3ce2:	9d 01       	movw	r18, r26
    3ce4:	2f 5f       	subi	r18, 0xFF	; 255
    3ce6:	3f 4f       	sbci	r19, 0xFF	; 255
    3ce8:	31 83       	std	Z+1, r19	; 0x01
    3cea:	20 83       	st	Z, r18
    3cec:	8c 93       	st	X, r24
    3cee:	26 81       	ldd	r18, Z+6	; 0x06
    3cf0:	37 81       	ldd	r19, Z+7	; 0x07
    3cf2:	2f 5f       	subi	r18, 0xFF	; 255
    3cf4:	3f 4f       	sbci	r19, 0xFF	; 255
    3cf6:	37 83       	std	Z+7, r19	; 0x07
    3cf8:	26 83       	std	Z+6, r18	; 0x06
    3cfa:	10 c0       	rjmp	.+32     	; 0x3d1c <fputc+0x66>
    3cfc:	eb 01       	movw	r28, r22
    3cfe:	09 2f       	mov	r16, r25
    3d00:	18 2f       	mov	r17, r24
    3d02:	00 84       	ldd	r0, Z+8	; 0x08
    3d04:	f1 85       	ldd	r31, Z+9	; 0x09
    3d06:	e0 2d       	mov	r30, r0
    3d08:	09 95       	icall
    3d0a:	89 2b       	or	r24, r25
    3d0c:	e1 f6       	brne	.-72     	; 0x3cc6 <fputc+0x10>
    3d0e:	8e 81       	ldd	r24, Y+6	; 0x06
    3d10:	9f 81       	ldd	r25, Y+7	; 0x07
    3d12:	01 96       	adiw	r24, 0x01	; 1
    3d14:	9f 83       	std	Y+7, r25	; 0x07
    3d16:	8e 83       	std	Y+6, r24	; 0x06
    3d18:	81 2f       	mov	r24, r17
    3d1a:	90 2f       	mov	r25, r16
    3d1c:	df 91       	pop	r29
    3d1e:	cf 91       	pop	r28
    3d20:	1f 91       	pop	r17
    3d22:	0f 91       	pop	r16
    3d24:	08 95       	ret

00003d26 <fwrite>:
    3d26:	a0 e0       	ldi	r26, 0x00	; 0
    3d28:	b0 e0       	ldi	r27, 0x00	; 0
    3d2a:	e8 e9       	ldi	r30, 0x98	; 152
    3d2c:	fe e1       	ldi	r31, 0x1E	; 30
    3d2e:	13 ce       	rjmp	.-986    	; 0x3956 <__prologue_saves__+0xc>
    3d30:	5b 01       	movw	r10, r22
    3d32:	4a 01       	movw	r8, r20
    3d34:	79 01       	movw	r14, r18
    3d36:	d9 01       	movw	r26, r18
    3d38:	13 96       	adiw	r26, 0x03	; 3
    3d3a:	2c 91       	ld	r18, X
    3d3c:	21 ff       	sbrs	r18, 1
    3d3e:	1d c0       	rjmp	.+58     	; 0x3d7a <fwrite+0x54>
    3d40:	c0 e0       	ldi	r28, 0x00	; 0
    3d42:	d0 e0       	ldi	r29, 0x00	; 0
    3d44:	c8 15       	cp	r28, r8
    3d46:	d9 05       	cpc	r29, r9
    3d48:	d9 f0       	breq	.+54     	; 0x3d80 <fwrite+0x5a>
    3d4a:	8c 01       	movw	r16, r24
    3d4c:	6c 01       	movw	r12, r24
    3d4e:	ca 0c       	add	r12, r10
    3d50:	db 1c       	adc	r13, r11
    3d52:	c8 01       	movw	r24, r16
    3d54:	0c 15       	cp	r16, r12
    3d56:	1d 05       	cpc	r17, r13
    3d58:	71 f0       	breq	.+28     	; 0x3d76 <fwrite+0x50>
    3d5a:	0f 5f       	subi	r16, 0xFF	; 255
    3d5c:	1f 4f       	sbci	r17, 0xFF	; 255
    3d5e:	d7 01       	movw	r26, r14
    3d60:	18 96       	adiw	r26, 0x08	; 8
    3d62:	ed 91       	ld	r30, X+
    3d64:	fc 91       	ld	r31, X
    3d66:	19 97       	sbiw	r26, 0x09	; 9
    3d68:	b7 01       	movw	r22, r14
    3d6a:	dc 01       	movw	r26, r24
    3d6c:	8c 91       	ld	r24, X
    3d6e:	09 95       	icall
    3d70:	89 2b       	or	r24, r25
    3d72:	79 f3       	breq	.-34     	; 0x3d52 <fwrite+0x2c>
    3d74:	05 c0       	rjmp	.+10     	; 0x3d80 <fwrite+0x5a>
    3d76:	21 96       	adiw	r28, 0x01	; 1
    3d78:	e5 cf       	rjmp	.-54     	; 0x3d44 <fwrite+0x1e>
    3d7a:	80 e0       	ldi	r24, 0x00	; 0
    3d7c:	90 e0       	ldi	r25, 0x00	; 0
    3d7e:	01 c0       	rjmp	.+2      	; 0x3d82 <fwrite+0x5c>
    3d80:	ce 01       	movw	r24, r28
    3d82:	cd b7       	in	r28, 0x3d	; 61
    3d84:	de b7       	in	r29, 0x3e	; 62
    3d86:	ec e0       	ldi	r30, 0x0C	; 12
    3d88:	02 ce       	rjmp	.-1020   	; 0x398e <__epilogue_restores__+0xc>

00003d8a <printf>:
    3d8a:	a0 e0       	ldi	r26, 0x00	; 0
    3d8c:	b0 e0       	ldi	r27, 0x00	; 0
    3d8e:	ea ec       	ldi	r30, 0xCA	; 202
    3d90:	fe e1       	ldi	r31, 0x1E	; 30
    3d92:	eb cd       	rjmp	.-1066   	; 0x396a <__prologue_saves__+0x20>
    3d94:	ae 01       	movw	r20, r28
    3d96:	4b 5f       	subi	r20, 0xFB	; 251
    3d98:	5f 4f       	sbci	r21, 0xFF	; 255
    3d9a:	fa 01       	movw	r30, r20
    3d9c:	61 91       	ld	r22, Z+
    3d9e:	71 91       	ld	r23, Z+
    3da0:	af 01       	movw	r20, r30
    3da2:	80 91 ec 03 	lds	r24, 0x03EC	; 0x8003ec <__iob+0x2>
    3da6:	90 91 ed 03 	lds	r25, 0x03ED	; 0x8003ed <__iob+0x3>
    3daa:	0e 94 6f 12 	call	0x24de	; 0x24de <vfprintf>
    3dae:	e2 e0       	ldi	r30, 0x02	; 2
    3db0:	f8 cd       	rjmp	.-1040   	; 0x39a2 <__epilogue_restores__+0x20>

00003db2 <putchar>:
    3db2:	60 91 ec 03 	lds	r22, 0x03EC	; 0x8003ec <__iob+0x2>
    3db6:	70 91 ed 03 	lds	r23, 0x03ED	; 0x8003ed <__iob+0x3>
    3dba:	7d cf       	rjmp	.-262    	; 0x3cb6 <fputc>

00003dbc <ungetc>:
    3dbc:	fb 01       	movw	r30, r22
    3dbe:	23 81       	ldd	r18, Z+3	; 0x03
    3dc0:	20 ff       	sbrs	r18, 0
    3dc2:	12 c0       	rjmp	.+36     	; 0x3de8 <ungetc+0x2c>
    3dc4:	26 fd       	sbrc	r18, 6
    3dc6:	10 c0       	rjmp	.+32     	; 0x3de8 <ungetc+0x2c>
    3dc8:	8f 3f       	cpi	r24, 0xFF	; 255
    3dca:	3f ef       	ldi	r19, 0xFF	; 255
    3dcc:	93 07       	cpc	r25, r19
    3dce:	61 f0       	breq	.+24     	; 0x3de8 <ungetc+0x2c>
    3dd0:	82 83       	std	Z+2, r24	; 0x02
    3dd2:	2f 7d       	andi	r18, 0xDF	; 223
    3dd4:	20 64       	ori	r18, 0x40	; 64
    3dd6:	23 83       	std	Z+3, r18	; 0x03
    3dd8:	26 81       	ldd	r18, Z+6	; 0x06
    3dda:	37 81       	ldd	r19, Z+7	; 0x07
    3ddc:	21 50       	subi	r18, 0x01	; 1
    3dde:	31 09       	sbc	r19, r1
    3de0:	37 83       	std	Z+7, r19	; 0x07
    3de2:	26 83       	std	Z+6, r18	; 0x06
    3de4:	99 27       	eor	r25, r25
    3de6:	08 95       	ret
    3de8:	8f ef       	ldi	r24, 0xFF	; 255
    3dea:	9f ef       	ldi	r25, 0xFF	; 255
    3dec:	08 95       	ret

00003dee <__ultoa_invert>:
    3dee:	fa 01       	movw	r30, r20
    3df0:	aa 27       	eor	r26, r26
    3df2:	28 30       	cpi	r18, 0x08	; 8
    3df4:	51 f1       	breq	.+84     	; 0x3e4a <__ultoa_invert+0x5c>
    3df6:	20 31       	cpi	r18, 0x10	; 16
    3df8:	81 f1       	breq	.+96     	; 0x3e5a <__ultoa_invert+0x6c>
    3dfa:	e8 94       	clt
    3dfc:	6f 93       	push	r22
    3dfe:	6e 7f       	andi	r22, 0xFE	; 254
    3e00:	6e 5f       	subi	r22, 0xFE	; 254
    3e02:	7f 4f       	sbci	r23, 0xFF	; 255
    3e04:	8f 4f       	sbci	r24, 0xFF	; 255
    3e06:	9f 4f       	sbci	r25, 0xFF	; 255
    3e08:	af 4f       	sbci	r26, 0xFF	; 255
    3e0a:	b1 e0       	ldi	r27, 0x01	; 1
    3e0c:	3e d0       	rcall	.+124    	; 0x3e8a <__ultoa_invert+0x9c>
    3e0e:	b4 e0       	ldi	r27, 0x04	; 4
    3e10:	3c d0       	rcall	.+120    	; 0x3e8a <__ultoa_invert+0x9c>
    3e12:	67 0f       	add	r22, r23
    3e14:	78 1f       	adc	r23, r24
    3e16:	89 1f       	adc	r24, r25
    3e18:	9a 1f       	adc	r25, r26
    3e1a:	a1 1d       	adc	r26, r1
    3e1c:	68 0f       	add	r22, r24
    3e1e:	79 1f       	adc	r23, r25
    3e20:	8a 1f       	adc	r24, r26
    3e22:	91 1d       	adc	r25, r1
    3e24:	a1 1d       	adc	r26, r1
    3e26:	6a 0f       	add	r22, r26
    3e28:	71 1d       	adc	r23, r1
    3e2a:	81 1d       	adc	r24, r1
    3e2c:	91 1d       	adc	r25, r1
    3e2e:	a1 1d       	adc	r26, r1
    3e30:	20 d0       	rcall	.+64     	; 0x3e72 <__ultoa_invert+0x84>
    3e32:	09 f4       	brne	.+2      	; 0x3e36 <__ultoa_invert+0x48>
    3e34:	68 94       	set
    3e36:	3f 91       	pop	r19
    3e38:	2a e0       	ldi	r18, 0x0A	; 10
    3e3a:	26 9f       	mul	r18, r22
    3e3c:	11 24       	eor	r1, r1
    3e3e:	30 19       	sub	r19, r0
    3e40:	30 5d       	subi	r19, 0xD0	; 208
    3e42:	31 93       	st	Z+, r19
    3e44:	de f6       	brtc	.-74     	; 0x3dfc <__ultoa_invert+0xe>
    3e46:	cf 01       	movw	r24, r30
    3e48:	08 95       	ret
    3e4a:	46 2f       	mov	r20, r22
    3e4c:	47 70       	andi	r20, 0x07	; 7
    3e4e:	40 5d       	subi	r20, 0xD0	; 208
    3e50:	41 93       	st	Z+, r20
    3e52:	b3 e0       	ldi	r27, 0x03	; 3
    3e54:	0f d0       	rcall	.+30     	; 0x3e74 <__ultoa_invert+0x86>
    3e56:	c9 f7       	brne	.-14     	; 0x3e4a <__ultoa_invert+0x5c>
    3e58:	f6 cf       	rjmp	.-20     	; 0x3e46 <__ultoa_invert+0x58>
    3e5a:	46 2f       	mov	r20, r22
    3e5c:	4f 70       	andi	r20, 0x0F	; 15
    3e5e:	40 5d       	subi	r20, 0xD0	; 208
    3e60:	4a 33       	cpi	r20, 0x3A	; 58
    3e62:	18 f0       	brcs	.+6      	; 0x3e6a <__ultoa_invert+0x7c>
    3e64:	49 5d       	subi	r20, 0xD9	; 217
    3e66:	31 fd       	sbrc	r19, 1
    3e68:	40 52       	subi	r20, 0x20	; 32
    3e6a:	41 93       	st	Z+, r20
    3e6c:	02 d0       	rcall	.+4      	; 0x3e72 <__ultoa_invert+0x84>
    3e6e:	a9 f7       	brne	.-22     	; 0x3e5a <__ultoa_invert+0x6c>
    3e70:	ea cf       	rjmp	.-44     	; 0x3e46 <__ultoa_invert+0x58>
    3e72:	b4 e0       	ldi	r27, 0x04	; 4
    3e74:	a6 95       	lsr	r26
    3e76:	97 95       	ror	r25
    3e78:	87 95       	ror	r24
    3e7a:	77 95       	ror	r23
    3e7c:	67 95       	ror	r22
    3e7e:	ba 95       	dec	r27
    3e80:	c9 f7       	brne	.-14     	; 0x3e74 <__ultoa_invert+0x86>
    3e82:	00 97       	sbiw	r24, 0x00	; 0
    3e84:	61 05       	cpc	r22, r1
    3e86:	71 05       	cpc	r23, r1
    3e88:	08 95       	ret
    3e8a:	9b 01       	movw	r18, r22
    3e8c:	ac 01       	movw	r20, r24
    3e8e:	0a 2e       	mov	r0, r26
    3e90:	06 94       	lsr	r0
    3e92:	57 95       	ror	r21
    3e94:	47 95       	ror	r20
    3e96:	37 95       	ror	r19
    3e98:	27 95       	ror	r18
    3e9a:	ba 95       	dec	r27
    3e9c:	c9 f7       	brne	.-14     	; 0x3e90 <__ultoa_invert+0xa2>
    3e9e:	62 0f       	add	r22, r18
    3ea0:	73 1f       	adc	r23, r19
    3ea2:	84 1f       	adc	r24, r20
    3ea4:	95 1f       	adc	r25, r21
    3ea6:	a0 1d       	adc	r26, r0
    3ea8:	08 95       	ret

00003eaa <strtod>:
    3eaa:	a0 e0       	ldi	r26, 0x00	; 0
    3eac:	b0 e0       	ldi	r27, 0x00	; 0
    3eae:	ea e5       	ldi	r30, 0x5A	; 90
    3eb0:	ff e1       	ldi	r31, 0x1F	; 31
    3eb2:	4f cd       	rjmp	.-1378   	; 0x3952 <__prologue_saves__+0x8>
    3eb4:	ec 01       	movw	r28, r24
    3eb6:	7b 01       	movw	r14, r22
    3eb8:	61 15       	cp	r22, r1
    3eba:	71 05       	cpc	r23, r1
    3ebc:	19 f0       	breq	.+6      	; 0x3ec4 <strtod+0x1a>
    3ebe:	db 01       	movw	r26, r22
    3ec0:	8d 93       	st	X+, r24
    3ec2:	9c 93       	st	X, r25
    3ec4:	8e 01       	movw	r16, r28
    3ec6:	0f 5f       	subi	r16, 0xFF	; 255
    3ec8:	1f 4f       	sbci	r17, 0xFF	; 255
    3eca:	78 80       	ld	r7, Y
    3ecc:	87 2d       	mov	r24, r7
    3ece:	90 e0       	ldi	r25, 0x00	; 0
    3ed0:	6b de       	rcall	.-810    	; 0x3ba8 <isspace>
    3ed2:	89 2b       	or	r24, r25
    3ed4:	11 f0       	breq	.+4      	; 0x3eda <strtod+0x30>
    3ed6:	e8 01       	movw	r28, r16
    3ed8:	f5 cf       	rjmp	.-22     	; 0x3ec4 <strtod+0x1a>
    3eda:	bd e2       	ldi	r27, 0x2D	; 45
    3edc:	7b 12       	cpse	r7, r27
    3ede:	05 c0       	rjmp	.+10     	; 0x3eea <strtod+0x40>
    3ee0:	0f 5f       	subi	r16, 0xFF	; 255
    3ee2:	1f 4f       	sbci	r17, 0xFF	; 255
    3ee4:	79 80       	ldd	r7, Y+1	; 0x01
    3ee6:	c1 e0       	ldi	r28, 0x01	; 1
    3ee8:	08 c0       	rjmp	.+16     	; 0x3efa <strtod+0x50>
    3eea:	eb e2       	ldi	r30, 0x2B	; 43
    3eec:	7e 12       	cpse	r7, r30
    3eee:	04 c0       	rjmp	.+8      	; 0x3ef8 <strtod+0x4e>
    3ef0:	8e 01       	movw	r16, r28
    3ef2:	0e 5f       	subi	r16, 0xFE	; 254
    3ef4:	1f 4f       	sbci	r17, 0xFF	; 255
    3ef6:	79 80       	ldd	r7, Y+1	; 0x01
    3ef8:	c0 e0       	ldi	r28, 0x00	; 0
    3efa:	68 01       	movw	r12, r16
    3efc:	f1 e0       	ldi	r31, 0x01	; 1
    3efe:	cf 1a       	sub	r12, r31
    3f00:	d1 08       	sbc	r13, r1
    3f02:	43 e0       	ldi	r20, 0x03	; 3
    3f04:	50 e0       	ldi	r21, 0x00	; 0
    3f06:	60 ea       	ldi	r22, 0xA0	; 160
    3f08:	71 e0       	ldi	r23, 0x01	; 1
    3f0a:	c6 01       	movw	r24, r12
    3f0c:	23 d1       	rcall	.+582    	; 0x4154 <strncasecmp_P>
    3f0e:	89 2b       	or	r24, r25
    3f10:	e9 f4       	brne	.+58     	; 0x3f4c <strtod+0xa2>
    3f12:	68 01       	movw	r12, r16
    3f14:	22 e0       	ldi	r18, 0x02	; 2
    3f16:	c2 0e       	add	r12, r18
    3f18:	d1 1c       	adc	r13, r1
    3f1a:	45 e0       	ldi	r20, 0x05	; 5
    3f1c:	50 e0       	ldi	r21, 0x00	; 0
    3f1e:	6b e9       	ldi	r22, 0x9B	; 155
    3f20:	71 e0       	ldi	r23, 0x01	; 1
    3f22:	c6 01       	movw	r24, r12
    3f24:	17 d1       	rcall	.+558    	; 0x4154 <strncasecmp_P>
    3f26:	89 2b       	or	r24, r25
    3f28:	21 f4       	brne	.+8      	; 0x3f32 <strtod+0x88>
    3f2a:	68 01       	movw	r12, r16
    3f2c:	87 e0       	ldi	r24, 0x07	; 7
    3f2e:	c8 0e       	add	r12, r24
    3f30:	d1 1c       	adc	r13, r1
    3f32:	e1 14       	cp	r14, r1
    3f34:	f1 04       	cpc	r15, r1
    3f36:	19 f0       	breq	.+6      	; 0x3f3e <strtod+0x94>
    3f38:	d7 01       	movw	r26, r14
    3f3a:	cd 92       	st	X+, r12
    3f3c:	dc 92       	st	X, r13
    3f3e:	c1 11       	cpse	r28, r1
    3f40:	f9 c0       	rjmp	.+498    	; 0x4134 <strtod+0x28a>
    3f42:	60 e0       	ldi	r22, 0x00	; 0
    3f44:	70 e0       	ldi	r23, 0x00	; 0
    3f46:	80 e8       	ldi	r24, 0x80	; 128
    3f48:	9f e7       	ldi	r25, 0x7F	; 127
    3f4a:	fd c0       	rjmp	.+506    	; 0x4146 <strtod+0x29c>
    3f4c:	43 e0       	ldi	r20, 0x03	; 3
    3f4e:	50 e0       	ldi	r21, 0x00	; 0
    3f50:	68 e9       	ldi	r22, 0x98	; 152
    3f52:	71 e0       	ldi	r23, 0x01	; 1
    3f54:	c6 01       	movw	r24, r12
    3f56:	fe d0       	rcall	.+508    	; 0x4154 <strncasecmp_P>
    3f58:	89 2b       	or	r24, r25
    3f5a:	51 f4       	brne	.+20     	; 0x3f70 <strtod+0xc6>
    3f5c:	e1 14       	cp	r14, r1
    3f5e:	f1 04       	cpc	r15, r1
    3f60:	09 f4       	brne	.+2      	; 0x3f64 <strtod+0xba>
    3f62:	ed c0       	rjmp	.+474    	; 0x413e <strtod+0x294>
    3f64:	0e 5f       	subi	r16, 0xFE	; 254
    3f66:	1f 4f       	sbci	r17, 0xFF	; 255
    3f68:	f7 01       	movw	r30, r14
    3f6a:	11 83       	std	Z+1, r17	; 0x01
    3f6c:	00 83       	st	Z, r16
    3f6e:	e7 c0       	rjmp	.+462    	; 0x413e <strtod+0x294>
    3f70:	68 01       	movw	r12, r16
    3f72:	60 e0       	ldi	r22, 0x00	; 0
    3f74:	70 e0       	ldi	r23, 0x00	; 0
    3f76:	cb 01       	movw	r24, r22
    3f78:	00 e0       	ldi	r16, 0x00	; 0
    3f7a:	10 e0       	ldi	r17, 0x00	; 0
    3f7c:	f6 01       	movw	r30, r12
    3f7e:	d0 ed       	ldi	r29, 0xD0	; 208
    3f80:	d7 0d       	add	r29, r7
    3f82:	da 30       	cpi	r29, 0x0A	; 10
    3f84:	50 f5       	brcc	.+84     	; 0x3fda <strtod+0x130>
    3f86:	2c 2f       	mov	r18, r28
    3f88:	22 60       	ori	r18, 0x02	; 2
    3f8a:	62 2e       	mov	r6, r18
    3f8c:	2c 2f       	mov	r18, r28
    3f8e:	28 70       	andi	r18, 0x08	; 8
    3f90:	c2 ff       	sbrs	r28, 2
    3f92:	05 c0       	rjmp	.+10     	; 0x3f9e <strtod+0xf4>
    3f94:	21 11       	cpse	r18, r1
    3f96:	27 c0       	rjmp	.+78     	; 0x3fe6 <strtod+0x13c>
    3f98:	0f 5f       	subi	r16, 0xFF	; 255
    3f9a:	1f 4f       	sbci	r17, 0xFF	; 255
    3f9c:	24 c0       	rjmp	.+72     	; 0x3fe6 <strtod+0x13c>
    3f9e:	22 23       	and	r18, r18
    3fa0:	11 f0       	breq	.+4      	; 0x3fa6 <strtod+0xfc>
    3fa2:	01 50       	subi	r16, 0x01	; 1
    3fa4:	11 09       	sbc	r17, r1
    3fa6:	a5 e0       	ldi	r26, 0x05	; 5
    3fa8:	b0 e0       	ldi	r27, 0x00	; 0
    3faa:	9b 01       	movw	r18, r22
    3fac:	ac 01       	movw	r20, r24
    3fae:	ea d0       	rcall	.+468    	; 0x4184 <__muluhisi3>
    3fb0:	4b 01       	movw	r8, r22
    3fb2:	5c 01       	movw	r10, r24
    3fb4:	88 0c       	add	r8, r8
    3fb6:	99 1c       	adc	r9, r9
    3fb8:	aa 1c       	adc	r10, r10
    3fba:	bb 1c       	adc	r11, r11
    3fbc:	c5 01       	movw	r24, r10
    3fbe:	b4 01       	movw	r22, r8
    3fc0:	6d 0f       	add	r22, r29
    3fc2:	71 1d       	adc	r23, r1
    3fc4:	81 1d       	adc	r24, r1
    3fc6:	91 1d       	adc	r25, r1
    3fc8:	68 39       	cpi	r22, 0x98	; 152
    3fca:	a9 e9       	ldi	r26, 0x99	; 153
    3fcc:	7a 07       	cpc	r23, r26
    3fce:	8a 07       	cpc	r24, r26
    3fd0:	a9 e1       	ldi	r26, 0x19	; 25
    3fd2:	9a 07       	cpc	r25, r26
    3fd4:	40 f0       	brcs	.+16     	; 0x3fe6 <strtod+0x13c>
    3fd6:	c6 60       	ori	r28, 0x06	; 6
    3fd8:	05 c0       	rjmp	.+10     	; 0x3fe4 <strtod+0x13a>
    3fda:	de 3f       	cpi	r29, 0xFE	; 254
    3fdc:	51 f4       	brne	.+20     	; 0x3ff2 <strtod+0x148>
    3fde:	c3 fd       	sbrc	r28, 3
    3fe0:	44 c0       	rjmp	.+136    	; 0x406a <strtod+0x1c0>
    3fe2:	c8 60       	ori	r28, 0x08	; 8
    3fe4:	6c 2e       	mov	r6, r28
    3fe6:	bf ef       	ldi	r27, 0xFF	; 255
    3fe8:	cb 1a       	sub	r12, r27
    3fea:	db 0a       	sbc	r13, r27
    3fec:	70 80       	ld	r7, Z
    3fee:	c6 2d       	mov	r28, r6
    3ff0:	c5 cf       	rjmp	.-118    	; 0x3f7c <strtod+0xd2>
    3ff2:	2d 2f       	mov	r18, r29
    3ff4:	2f 7d       	andi	r18, 0xDF	; 223
    3ff6:	25 31       	cpi	r18, 0x15	; 21
    3ff8:	c1 f5       	brne	.+112    	; 0x406a <strtod+0x1c0>
    3ffa:	40 81       	ld	r20, Z
    3ffc:	4d 32       	cpi	r20, 0x2D	; 45
    3ffe:	11 f4       	brne	.+4      	; 0x4004 <strtod+0x15a>
    4000:	c0 61       	ori	r28, 0x10	; 16
    4002:	06 c0       	rjmp	.+12     	; 0x4010 <strtod+0x166>
    4004:	4b 32       	cpi	r20, 0x2B	; 43
    4006:	21 f0       	breq	.+8      	; 0x4010 <strtod+0x166>
    4008:	31 96       	adiw	r30, 0x01	; 1
    400a:	21 e0       	ldi	r18, 0x01	; 1
    400c:	30 e0       	ldi	r19, 0x00	; 0
    400e:	06 c0       	rjmp	.+12     	; 0x401c <strtod+0x172>
    4010:	32 96       	adiw	r30, 0x02	; 2
    4012:	d6 01       	movw	r26, r12
    4014:	11 96       	adiw	r26, 0x01	; 1
    4016:	4c 91       	ld	r20, X
    4018:	22 e0       	ldi	r18, 0x02	; 2
    401a:	30 e0       	ldi	r19, 0x00	; 0
    401c:	a0 ed       	ldi	r26, 0xD0	; 208
    401e:	a4 0f       	add	r26, r20
    4020:	aa 30       	cpi	r26, 0x0A	; 10
    4022:	18 f0       	brcs	.+6      	; 0x402a <strtod+0x180>
    4024:	e2 1b       	sub	r30, r18
    4026:	f3 0b       	sbc	r31, r19
    4028:	20 c0       	rjmp	.+64     	; 0x406a <strtod+0x1c0>
    402a:	40 e0       	ldi	r20, 0x00	; 0
    402c:	50 e0       	ldi	r21, 0x00	; 0
    402e:	40 38       	cpi	r20, 0x80	; 128
    4030:	bc e0       	ldi	r27, 0x0C	; 12
    4032:	5b 07       	cpc	r21, r27
    4034:	5c f4       	brge	.+22     	; 0x404c <strtod+0x1a2>
    4036:	9a 01       	movw	r18, r20
    4038:	22 0f       	add	r18, r18
    403a:	33 1f       	adc	r19, r19
    403c:	22 0f       	add	r18, r18
    403e:	33 1f       	adc	r19, r19
    4040:	42 0f       	add	r20, r18
    4042:	53 1f       	adc	r21, r19
    4044:	44 0f       	add	r20, r20
    4046:	55 1f       	adc	r21, r21
    4048:	4a 0f       	add	r20, r26
    404a:	51 1d       	adc	r21, r1
    404c:	31 96       	adiw	r30, 0x01	; 1
    404e:	df 01       	movw	r26, r30
    4050:	11 97       	sbiw	r26, 0x01	; 1
    4052:	2c 91       	ld	r18, X
    4054:	a0 ed       	ldi	r26, 0xD0	; 208
    4056:	a2 0f       	add	r26, r18
    4058:	aa 30       	cpi	r26, 0x0A	; 10
    405a:	48 f3       	brcs	.-46     	; 0x402e <strtod+0x184>
    405c:	c4 ff       	sbrs	r28, 4
    405e:	03 c0       	rjmp	.+6      	; 0x4066 <strtod+0x1bc>
    4060:	51 95       	neg	r21
    4062:	41 95       	neg	r20
    4064:	51 09       	sbc	r21, r1
    4066:	04 0f       	add	r16, r20
    4068:	15 1f       	adc	r17, r21
    406a:	c1 ff       	sbrs	r28, 1
    406c:	07 c0       	rjmp	.+14     	; 0x407c <strtod+0x1d2>
    406e:	e1 14       	cp	r14, r1
    4070:	f1 04       	cpc	r15, r1
    4072:	21 f0       	breq	.+8      	; 0x407c <strtod+0x1d2>
    4074:	31 97       	sbiw	r30, 0x01	; 1
    4076:	d7 01       	movw	r26, r14
    4078:	ed 93       	st	X+, r30
    407a:	fc 93       	st	X, r31
    407c:	96 da       	rcall	.-2772   	; 0x35aa <__floatunsisf>
    407e:	c3 70       	andi	r28, 0x03	; 3
    4080:	c3 30       	cpi	r28, 0x03	; 3
    4082:	19 f0       	breq	.+6      	; 0x408a <strtod+0x1e0>
    4084:	6b 01       	movw	r12, r22
    4086:	7c 01       	movw	r14, r24
    4088:	06 c0       	rjmp	.+12     	; 0x4096 <strtod+0x1ec>
    408a:	6b 01       	movw	r12, r22
    408c:	7c 01       	movw	r14, r24
    408e:	f7 fa       	bst	r15, 7
    4090:	f0 94       	com	r15
    4092:	f7 f8       	bld	r15, 7
    4094:	f0 94       	com	r15
    4096:	20 e0       	ldi	r18, 0x00	; 0
    4098:	30 e0       	ldi	r19, 0x00	; 0
    409a:	a9 01       	movw	r20, r18
    409c:	c7 01       	movw	r24, r14
    409e:	b6 01       	movw	r22, r12
    40a0:	ec d9       	rcall	.-3112   	; 0x347a <__cmpsf2>
    40a2:	88 23       	and	r24, r24
    40a4:	09 f4       	brne	.+2      	; 0x40a8 <strtod+0x1fe>
    40a6:	43 c0       	rjmp	.+134    	; 0x412e <strtod+0x284>
    40a8:	17 ff       	sbrs	r17, 7
    40aa:	06 c0       	rjmp	.+12     	; 0x40b8 <strtod+0x20e>
    40ac:	11 95       	neg	r17
    40ae:	01 95       	neg	r16
    40b0:	11 09       	sbc	r17, r1
    40b2:	c7 eb       	ldi	r28, 0xB7	; 183
    40b4:	d1 e0       	ldi	r29, 0x01	; 1
    40b6:	02 c0       	rjmp	.+4      	; 0x40bc <strtod+0x212>
    40b8:	cf ec       	ldi	r28, 0xCF	; 207
    40ba:	d1 e0       	ldi	r29, 0x01	; 1
    40bc:	5e 01       	movw	r10, r28
    40be:	b8 e1       	ldi	r27, 0x18	; 24
    40c0:	ab 1a       	sub	r10, r27
    40c2:	b1 08       	sbc	r11, r1
    40c4:	46 01       	movw	r8, r12
    40c6:	be 2d       	mov	r27, r14
    40c8:	af 2d       	mov	r26, r15
    40ca:	90 e2       	ldi	r25, 0x20	; 32
    40cc:	e9 2e       	mov	r14, r25
    40ce:	f1 2c       	mov	r15, r1
    40d0:	0e 15       	cp	r16, r14
    40d2:	1f 05       	cpc	r17, r15
    40d4:	7c f0       	brlt	.+30     	; 0x40f4 <strtod+0x24a>
    40d6:	fe 01       	movw	r30, r28
    40d8:	25 91       	lpm	r18, Z+
    40da:	35 91       	lpm	r19, Z+
    40dc:	45 91       	lpm	r20, Z+
    40de:	54 91       	lpm	r21, Z
    40e0:	b4 01       	movw	r22, r8
    40e2:	8b 2f       	mov	r24, r27
    40e4:	9a 2f       	mov	r25, r26
    40e6:	43 db       	rcall	.-2426   	; 0x376e <__mulsf3>
    40e8:	4b 01       	movw	r8, r22
    40ea:	b8 2f       	mov	r27, r24
    40ec:	a9 2f       	mov	r26, r25
    40ee:	0e 19       	sub	r16, r14
    40f0:	1f 09       	sbc	r17, r15
    40f2:	ee cf       	rjmp	.-36     	; 0x40d0 <strtod+0x226>
    40f4:	24 97       	sbiw	r28, 0x04	; 4
    40f6:	f5 94       	asr	r15
    40f8:	e7 94       	ror	r14
    40fa:	ca 15       	cp	r28, r10
    40fc:	db 05       	cpc	r29, r11
    40fe:	41 f7       	brne	.-48     	; 0x40d0 <strtod+0x226>
    4100:	64 01       	movw	r12, r8
    4102:	eb 2e       	mov	r14, r27
    4104:	fa 2e       	mov	r15, r26
    4106:	8e 2d       	mov	r24, r14
    4108:	88 0f       	add	r24, r24
    410a:	8f 2d       	mov	r24, r15
    410c:	88 1f       	adc	r24, r24
    410e:	8f 3f       	cpi	r24, 0xFF	; 255
    4110:	41 f0       	breq	.+16     	; 0x4122 <strtod+0x278>
    4112:	20 e0       	ldi	r18, 0x00	; 0
    4114:	30 e0       	ldi	r19, 0x00	; 0
    4116:	a9 01       	movw	r20, r18
    4118:	c7 01       	movw	r24, r14
    411a:	b6 01       	movw	r22, r12
    411c:	ae d9       	rcall	.-3236   	; 0x347a <__cmpsf2>
    411e:	81 11       	cpse	r24, r1
    4120:	06 c0       	rjmp	.+12     	; 0x412e <strtod+0x284>
    4122:	82 e2       	ldi	r24, 0x22	; 34
    4124:	90 e0       	ldi	r25, 0x00	; 0
    4126:	90 93 f1 03 	sts	0x03F1, r25	; 0x8003f1 <errno+0x1>
    412a:	80 93 f0 03 	sts	0x03F0, r24	; 0x8003f0 <errno>
    412e:	c7 01       	movw	r24, r14
    4130:	b6 01       	movw	r22, r12
    4132:	09 c0       	rjmp	.+18     	; 0x4146 <strtod+0x29c>
    4134:	60 e0       	ldi	r22, 0x00	; 0
    4136:	70 e0       	ldi	r23, 0x00	; 0
    4138:	80 e8       	ldi	r24, 0x80	; 128
    413a:	9f ef       	ldi	r25, 0xFF	; 255
    413c:	04 c0       	rjmp	.+8      	; 0x4146 <strtod+0x29c>
    413e:	60 e0       	ldi	r22, 0x00	; 0
    4140:	70 e0       	ldi	r23, 0x00	; 0
    4142:	80 ec       	ldi	r24, 0xC0	; 192
    4144:	9f e7       	ldi	r25, 0x7F	; 127
    4146:	cd b7       	in	r28, 0x3d	; 61
    4148:	de b7       	in	r29, 0x3e	; 62
    414a:	ee e0       	ldi	r30, 0x0E	; 14
    414c:	1e cc       	rjmp	.-1988   	; 0x398a <__epilogue_restores__+0x8>

0000414e <__ctype_isfalse>:
    414e:	99 27       	eor	r25, r25
    4150:	88 27       	eor	r24, r24

00004152 <__ctype_istrue>:
    4152:	08 95       	ret

00004154 <strncasecmp_P>:
    4154:	fb 01       	movw	r30, r22
    4156:	dc 01       	movw	r26, r24
    4158:	41 50       	subi	r20, 0x01	; 1
    415a:	50 40       	sbci	r21, 0x00	; 0
    415c:	88 f0       	brcs	.+34     	; 0x4180 <strncasecmp_P+0x2c>
    415e:	8d 91       	ld	r24, X+
    4160:	81 34       	cpi	r24, 0x41	; 65
    4162:	1c f0       	brlt	.+6      	; 0x416a <strncasecmp_P+0x16>
    4164:	8b 35       	cpi	r24, 0x5B	; 91
    4166:	0c f4       	brge	.+2      	; 0x416a <strncasecmp_P+0x16>
    4168:	80 5e       	subi	r24, 0xE0	; 224
    416a:	65 91       	lpm	r22, Z+
    416c:	61 34       	cpi	r22, 0x41	; 65
    416e:	1c f0       	brlt	.+6      	; 0x4176 <strncasecmp_P+0x22>
    4170:	6b 35       	cpi	r22, 0x5B	; 91
    4172:	0c f4       	brge	.+2      	; 0x4176 <strncasecmp_P+0x22>
    4174:	60 5e       	subi	r22, 0xE0	; 224
    4176:	86 1b       	sub	r24, r22
    4178:	61 11       	cpse	r22, r1
    417a:	71 f3       	breq	.-36     	; 0x4158 <strncasecmp_P+0x4>
    417c:	99 0b       	sbc	r25, r25
    417e:	08 95       	ret
    4180:	88 1b       	sub	r24, r24
    4182:	fc cf       	rjmp	.-8      	; 0x417c <strncasecmp_P+0x28>

00004184 <__muluhisi3>:
    4184:	d3 db       	rcall	.-2138   	; 0x392c <__umulhisi3>
    4186:	a5 9f       	mul	r26, r21
    4188:	90 0d       	add	r25, r0
    418a:	b4 9f       	mul	r27, r20
    418c:	90 0d       	add	r25, r0
    418e:	a4 9f       	mul	r26, r20
    4190:	80 0d       	add	r24, r0
    4192:	91 1d       	adc	r25, r1
    4194:	11 24       	eor	r1, r1
    4196:	08 95       	ret

00004198 <_exit>:
    4198:	f8 94       	cli

0000419a <__stop_program>:
    419a:	ff cf       	rjmp	.-2      	; 0x419a <__stop_program>
