   1               		.file	"test.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 127               	.global	initLED
 129               	initLED:
   1:test.c        **** #include <avr/io.h>	/* Device specific declarations */
   2:test.c        **** #include <util/delay.h>
   3:test.c        **** #include <avr/pgmspace.h>
   4:test.c        **** #include <avr/interrupt.h>
   5:test.c        **** #include <stdio.h>
   6:test.c        **** #include <stdlib.h>
   7:test.c        **** #include "USART.h"
   8:test.c        **** #include "ADC.h"
   9:test.c        **** #include "motorctrl.h"
  10:test.c        **** #include "serialparser.h"
  11:test.c        **** #include "buttons.h"
  12:test.c        **** 
  13:test.c        **** FILE port;
  14:test.c        **** //motor motors[NUM_OF_MOTORS];
  15:test.c        **** 
  16:test.c        **** //Debug led control for seeing that main loop is running
  17:test.c        **** #define LED_DDR DDRB
  18:test.c        **** #define LED_PORT PORTB
  19:test.c        **** #define LED_PIN PINB
  20:test.c        **** #define LED_PIN_NUM 5
  21:test.c        **** #define DISABLE_LED LED_PORT &= ~(1<<LED_PIN_NUM);
  22:test.c        **** #define ENABLE_LED LED_PORT |= (1<<LED_PIN_NUM);
  23:test.c        **** #define TOGGLE_LED LED_PORT ^= (1<<LED_PIN_NUM);
  24:test.c        **** 
  25:test.c        **** void initLED(void){
 131               	.LM0:
 132               	.LFBB1:
 133               	/* prologue: function */
 134               	/* frame size = 0 */
 135               	/* stack size = 0 */
 136               	.L__stack_usage = 0
  26:test.c        ****     LED_DDR |= (1<<LED_PIN_NUM); 
 138               	.LM1:
 139 0000 259A      		sbi 0x4,5
 140 0002 0895      		ret
 142               	.Lscope1:
 143               		.section	.rodata.str1.1,"aMS",@progbits,1
 144               	.LC0:
 145 0000 4736 3A25 		.string	"G6:%d:%d:%d\n"
 145      643A 2564 
 145      3A25 640A 
 145      00
 146               		.section	.text.startup,"ax",@progbits
 150               	.global	main
 152               	main:
  27:test.c        **** }
  28:test.c        **** int main (int argc, char *argv[])
  29:test.c        **** {
 154               	.LM2:
 155               	.LFBB2:
 156 0000 A0E0      		ldi r26,0
 157 0002 B0E0      		ldi r27,0
 158 0004 E0E0      		ldi r30,lo8(gs(1f))
 159 0006 F0E0      		ldi r31,hi8(gs(1f))
 160 0008 0C94 0000 		jmp __prologue_saves__+((18 - 8) * 2)
 161               	1:
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 8 */
 165               	.L__stack_usage = 8
 166               	.LBB6:
 167               	.LBB7:
 169               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 171               	.LM3:
 172 000c 2FEF      		ldi r18,lo8(1599999)
 173 000e 39E6      		ldi r19,hi8(1599999)
 174 0010 88E1      		ldi r24,hlo8(1599999)
 175 0012 2150      	1:	subi r18,1
 176 0014 3040      		sbci r19,0
 177 0016 8040      		sbci r24,0
 178 0018 01F4      		brne 1b
 179 001a 00C0      		rjmp .
 180 001c 0000      		nop
 181               	.LBE7:
 182               	.LBE6:
 184               	.Ltext2:
  30:test.c        ****     _delay_ms(500);
  31:test.c        **** 	USART_Init(&port, 115200);
 186               	.LM4:
 187 001e 40E0      		ldi r20,0
 188 0020 52EC      		ldi r21,lo8(-62)
 189 0022 61E0      		ldi r22,lo8(1)
 190 0024 70E0      		ldi r23,0
 191 0026 80E0      		ldi r24,lo8(port)
 192 0028 90E0      		ldi r25,hi8(port)
 193 002a 0E94 0000 		call USART_Init
  32:test.c        **** 	USART0_Flush();
 195               	.LM5:
 196 002e 0E94 0000 		call USART0_Flush
 197               	.LBB8:
 198               	.LBB9:
  26:test.c        **** }
 200               	.LM6:
 201 0032 259A      		sbi 0x4,5
 202               	.LBE9:
 203               	.LBE8:
  33:test.c        ****     initLED();
  34:test.c        ****     initADC();
 205               	.LM7:
 206 0034 0E94 0000 		call initADC
  35:test.c        ****     initMotor(&port);
 208               	.LM8:
 209 0038 80E0      		ldi r24,lo8(port)
 210 003a 90E0      		ldi r25,hi8(port)
 211 003c 0E94 0000 		call initMotor
  36:test.c        **** 	initSerialParser(&port);
 213               	.LM9:
 214 0040 80E0      		ldi r24,lo8(port)
 215 0042 90E0      		ldi r25,hi8(port)
 216 0044 0E94 0000 		call initSerialParser
  37:test.c        ****     initButtons();    
 218               	.LM10:
 219 0048 0E94 0000 		call initButtons
  38:test.c        **** 
  39:test.c        ****     //for (float i=0; i<90; i+=1){
  40:test.c        ****     //    uint16_t len = 
  41:test.c        ****     //    fprintf(&port, "Len:%d, angle:%f\n",tiltDegToLength(i),i);
  42:test.c        ****     //}
  43:test.c        ****     //while(1){}
  44:test.c        ****     
  45:test.c        ****     GTCCR = 0x00;
 221               	.LM11:
 222 004c 13BC      		out 0x23,__zero_reg__
  46:test.c        ****     sei();
 224               	.LM12:
 225               	/* #APP */
 226               	 ;  46 "test.c" 1
 227 004e 7894      		sei
 228               	 ;  0 "" 2
  47:test.c        **** 
  48:test.c        ****     uint8_t current_mode = readAutoManualState();
 230               	.LM13:
 231               	/* #NOAPP */
 232 0050 0E94 0000 		call readAutoManualState
 233 0054 C82F      		mov r28,r24
  49:test.c        ****     fprintf(&port, "G6:%d:%d:%d\n",readAutoManualState(), readTiltButtonState(), readTurnButtonStat
 235               	.LM14:
 236 0056 0E94 0000 		call readTurnButtonState
 237 005a 182F      		mov r17,r24
 238 005c 0E94 0000 		call readTiltButtonState
 239 0060 D82F      		mov r29,r24
 240 0062 0E94 0000 		call readAutoManualState
 241 0066 1F92      		push __zero_reg__
 242 0068 1F93      		push r17
 243 006a 1F92      		push __zero_reg__
 244 006c DF93      		push r29
 245 006e 1F92      		push __zero_reg__
 246 0070 8F93      		push r24
 247 0072 80E0      		ldi r24,lo8(.LC0)
 248 0074 90E0      		ldi r25,hi8(.LC0)
 249 0076 9F93      		push r25
 250 0078 8F93      		push r24
 251 007a 80E0      		ldi r24,lo8(port)
 252 007c 90E0      		ldi r25,hi8(port)
 253 007e 9F93      		push r25
 254 0080 8F93      		push r24
 255 0082 0E94 0000 		call fprintf
 256 0086 2DB7      		in r18,__SP_L__
 257 0088 3EB7      		in r19,__SP_H__
 258 008a 265F      		subi r18,-10
 259 008c 3F4F      		sbci r19,-1
 260 008e 0FB6      		in __tmp_reg__,__SREG__
 261 0090 F894      		cli
 262 0092 3EBF      		out __SP_H__,r19
 263 0094 0FBE      		out __SREG__,__tmp_reg__
 264 0096 2DBF      		out __SP_L__,r18
  50:test.c        ****     while(1){
  51:test.c        ****         setLengthLoop();
  52:test.c        ****         
  53:test.c        ****         if (readAutoManualState() == MANUAL){ 
  54:test.c        ****             switch(readTiltButtonState()){
  55:test.c        ****                 case 1:{
  56:test.c        ****                     fprintf(&port, "G6:%d:%d:%d\n",readAutoManualState(), readTiltButtonState(), re
  57:test.c        ****                     setAngleMotorLength(getAngleActuatorSetLength()+5);
  58:test.c        ****                     while(readTiltButtonState() != 0){setLengthLoop();} //Wait until button is rele
  59:test.c        ****                     break;
  60:test.c        ****                 }
  61:test.c        ****                 case 2:{
  62:test.c        ****                     fprintf(&port, "G6:%d:%d:%d\n",readAutoManualState(), readTiltButtonState(), re
  63:test.c        ****                     setAngleMotorLength(getAngleActuatorSetLength()-5);
  64:test.c        ****                     while(readTiltButtonState() != 0){setLengthLoop();} //Wait until button is rele
  65:test.c        ****                     break;
  66:test.c        ****                 }
  67:test.c        ****             }
  68:test.c        ****             switch(readTurnButtonState()){
  69:test.c        ****                 case 1:{
  70:test.c        ****                     fprintf(&port, "G6:%d:%d:%d\n",readAutoManualState(), readTiltButtonState(), re
  71:test.c        ****                     setTiltMotorLength(getTiltActuatorSetLength()+5);
  72:test.c        ****                     while(readTurnButtonState() != 0){setLengthLoop();} //Wait until button is rele
  73:test.c        ****                     break;
  74:test.c        ****                 }
  75:test.c        ****                 case 2:{
  76:test.c        ****                     fprintf(&port, "G6:%d:%d:%d\n",readAutoManualState(), readTiltButtonState(), re
  77:test.c        ****                     setTiltMotorLength(getTiltActuatorSetLength()-5);
  78:test.c        ****                     while(readTurnButtonState() != 0){setLengthLoop();} //Wait until button is rele
  79:test.c        ****                     break;
  80:test.c        ****                 }
  81:test.c        ****             }
  82:test.c        ****         }
  83:test.c        ****         else{
  84:test.c        ****              TOGGLE_LED
 266               	.LM15:
 267 0098 D0E2      		ldi r29,lo8(32)
  70:test.c        ****                     setTiltMotorLength(getTiltActuatorSetLength()+5);
 269               	.LM16:
 270 009a 80E0      		ldi r24,lo8(.LC0)
 271 009c E82E      		mov r14,r24
 272 009e 80E0      		ldi r24,hi8(.LC0)
 273 00a0 F82E      		mov r15,r24
 274 00a2 00E0      		ldi r16,lo8(port)
 275 00a4 10E0      		ldi r17,hi8(port)
 276 00a6 00C0      		rjmp .L20
 277               	.L3:
 279               	.LM17:
 280 00a8 95B1      		in r25,0x5
 281 00aa 9D27      		eor r25,r29
 282 00ac 95B9      		out 0x5,r25
 283               	.L12:
  85:test.c        ****         }
  86:test.c        **** 
  87:test.c        ****         if (current_mode != readAutoManualState()){
 285               	.LM18:
 286 00ae 0E94 0000 		call readAutoManualState
 287 00b2 8C13      		cpse r24,r28
 288 00b4 00C0      		rjmp .L27
 289               	.L20:
  51:test.c        ****         
 291               	.LM19:
 292 00b6 0E94 0000 		call setLengthLoop
  53:test.c        ****             switch(readTiltButtonState()){
 294               	.LM20:
 295 00ba 0E94 0000 		call readAutoManualState
 296 00be 8111      		cpse r24,__zero_reg__
 297 00c0 00C0      		rjmp .L3
  54:test.c        ****                 case 1:{
 299               	.LM21:
 300 00c2 0E94 0000 		call readTiltButtonState
 301 00c6 8130      		cpi r24,lo8(1)
 302 00c8 01F4      		brne .+2
 303 00ca 00C0      		rjmp .L5
 304 00cc 8230      		cpi r24,lo8(2)
 305 00ce 01F4      		brne .L4
  62:test.c        ****                     setAngleMotorLength(getAngleActuatorSetLength()-5);
 307               	.LM22:
 308 00d0 0E94 0000 		call readTurnButtonState
 309 00d4 C82E      		mov r12,r24
 310 00d6 0E94 0000 		call readTiltButtonState
 311 00da D82E      		mov r13,r24
 312 00dc 0E94 0000 		call readAutoManualState
 313 00e0 1F92      		push __zero_reg__
 314 00e2 CF92      		push r12
 315 00e4 1F92      		push __zero_reg__
 316 00e6 DF92      		push r13
 317 00e8 1F92      		push __zero_reg__
 318 00ea 8F93      		push r24
 319 00ec FF92      		push r15
 320 00ee EF92      		push r14
 321 00f0 1F93      		push r17
 322 00f2 0F93      		push r16
 323 00f4 0E94 0000 		call fprintf
  63:test.c        ****                     while(readTiltButtonState() != 0){setLengthLoop();} //Wait until button is rele
 325               	.LM23:
 326 00f8 0E94 0000 		call getAngleActuatorSetLength
 327 00fc 0597      		sbiw r24,5
 328 00fe 0E94 0000 		call setAngleMotorLength
  64:test.c        ****                     break;
 330               	.LM24:
 331 0102 2DB7      		in r18,__SP_L__
 332 0104 3EB7      		in r19,__SP_H__
 333 0106 265F      		subi r18,-10
 334 0108 3F4F      		sbci r19,-1
 335 010a 0FB6      		in __tmp_reg__,__SREG__
 336 010c F894      		cli
 337 010e 3EBF      		out __SP_H__,r19
 338 0110 0FBE      		out __SREG__,__tmp_reg__
 339 0112 2DBF      		out __SP_L__,r18
 340 0114 00C0      		rjmp .L9
 341               	.L10:
  64:test.c        ****                     break;
 343               	.LM25:
 344 0116 0E94 0000 		call setLengthLoop
 345               	.L9:
  64:test.c        ****                     break;
 347               	.LM26:
 348 011a 0E94 0000 		call readTiltButtonState
 349 011e 8111      		cpse r24,__zero_reg__
 350 0120 00C0      		rjmp .L10
 351               	.L4:
  68:test.c        ****                 case 1:{
 353               	.LM27:
 354 0122 0E94 0000 		call readTurnButtonState
 355 0126 8130      		cpi r24,lo8(1)
 356 0128 01F4      		brne .+2
 357 012a 00C0      		rjmp .L13
 358               	.L28:
 359 012c 8230      		cpi r24,lo8(2)
 360 012e 01F0      		breq .+2
 361 0130 00C0      		rjmp .L12
  76:test.c        ****                     setTiltMotorLength(getTiltActuatorSetLength()-5);
 363               	.LM28:
 364 0132 0E94 0000 		call readTurnButtonState
 365 0136 C82E      		mov r12,r24
 366 0138 0E94 0000 		call readTiltButtonState
 367 013c D82E      		mov r13,r24
 368 013e 0E94 0000 		call readAutoManualState
 369 0142 1F92      		push __zero_reg__
 370 0144 CF92      		push r12
 371 0146 1F92      		push __zero_reg__
 372 0148 DF92      		push r13
 373 014a 1F92      		push __zero_reg__
 374 014c 8F93      		push r24
 375 014e FF92      		push r15
 376 0150 EF92      		push r14
 377 0152 1F93      		push r17
 378 0154 0F93      		push r16
 379 0156 0E94 0000 		call fprintf
  77:test.c        ****                     while(readTurnButtonState() != 0){setLengthLoop();} //Wait until button is rele
 381               	.LM29:
 382 015a 0E94 0000 		call getTiltActuatorSetLength
 383 015e 0597      		sbiw r24,5
 384 0160 0E94 0000 		call setTiltMotorLength
  78:test.c        ****                     break;
 386               	.LM30:
 387 0164 2DB7      		in r18,__SP_L__
 388 0166 3EB7      		in r19,__SP_H__
 389 0168 265F      		subi r18,-10
 390 016a 3F4F      		sbci r19,-1
 391 016c 0FB6      		in __tmp_reg__,__SREG__
 392 016e F894      		cli
 393 0170 3EBF      		out __SP_H__,r19
 394 0172 0FBE      		out __SREG__,__tmp_reg__
 395 0174 2DBF      		out __SP_L__,r18
 396 0176 00C0      		rjmp .L17
 397               	.L18:
  78:test.c        ****                     break;
 399               	.LM31:
 400 0178 0E94 0000 		call setLengthLoop
 401               	.L17:
  78:test.c        ****                     break;
 403               	.LM32:
 404 017c 0E94 0000 		call readTurnButtonState
 405 0180 8111      		cpse r24,__zero_reg__
 406 0182 00C0      		rjmp .L18
 408               	.LM33:
 409 0184 0E94 0000 		call readAutoManualState
 410 0188 8C17      		cp r24,r28
 411 018a 01F4      		brne .+2
 412 018c 00C0      		rjmp .L20
 413               	.L27:
  88:test.c        ****             fprintf(&port, "G6:%d:%d:%d\n",readAutoManualState(), readTiltButtonState(), readTurnBu
 415               	.LM34:
 416 018e 0E94 0000 		call readTurnButtonState
 417 0192 D82E      		mov r13,r24
 418 0194 0E94 0000 		call readTiltButtonState
 419 0198 C82F      		mov r28,r24
 420 019a 0E94 0000 		call readAutoManualState
 421 019e 1F92      		push __zero_reg__
 422 01a0 DF92      		push r13
 423 01a2 1F92      		push __zero_reg__
 424 01a4 CF93      		push r28
 425 01a6 1F92      		push __zero_reg__
 426 01a8 8F93      		push r24
 427 01aa FF92      		push r15
 428 01ac EF92      		push r14
 429 01ae 1F93      		push r17
 430 01b0 0F93      		push r16
 431 01b2 0E94 0000 		call fprintf
  89:test.c        ****             if (readAutoManualState() == 1){
 433               	.LM35:
 434 01b6 0E94 0000 		call readAutoManualState
  90:test.c        ****                // fprintf(&port, "Automatic mode turned ON\n");
  91:test.c        ****                 current_mode = 1;
 436               	.LM36:
 437 01ba C1E0      		ldi r28,lo8(1)
  89:test.c        ****             if (readAutoManualState() == 1){
 439               	.LM37:
 440 01bc 2DB7      		in r18,__SP_L__
 441 01be 3EB7      		in r19,__SP_H__
 442 01c0 265F      		subi r18,-10
 443 01c2 3F4F      		sbci r19,-1
 444 01c4 0FB6      		in __tmp_reg__,__SREG__
 445 01c6 F894      		cli
 446 01c8 3EBF      		out __SP_H__,r19
 447 01ca 0FBE      		out __SREG__,__tmp_reg__
 448 01cc 2DBF      		out __SP_L__,r18
 449 01ce 8130      		cpi r24,lo8(1)
 450 01d0 01F4      		brne .+2
 451 01d2 00C0      		rjmp .L20
  92:test.c        ****             }
  93:test.c        ****             else{
  94:test.c        ****                // fprintf(&port, "Manual mode Activated\n");
  95:test.c        ****                 current_mode = 0;
  96:test.c        ****                 shutdownMotors();
 453               	.LM38:
 454 01d4 0E94 0000 		call shutdownMotors
  95:test.c        ****                 shutdownMotors();
 456               	.LM39:
 457 01d8 C0E0      		ldi r28,0
 458 01da 00C0      		rjmp .L20
 459               	.L5:
  56:test.c        ****                     setAngleMotorLength(getAngleActuatorSetLength()+5);
 461               	.LM40:
 462 01dc 0E94 0000 		call readTurnButtonState
 463 01e0 C82E      		mov r12,r24
 464 01e2 0E94 0000 		call readTiltButtonState
 465 01e6 D82E      		mov r13,r24
 466 01e8 0E94 0000 		call readAutoManualState
 467 01ec 1F92      		push __zero_reg__
 468 01ee CF92      		push r12
 469 01f0 1F92      		push __zero_reg__
 470 01f2 DF92      		push r13
 471 01f4 1F92      		push __zero_reg__
 472 01f6 8F93      		push r24
 473 01f8 FF92      		push r15
 474 01fa EF92      		push r14
 475 01fc 1F93      		push r17
 476 01fe 0F93      		push r16
 477 0200 0E94 0000 		call fprintf
  57:test.c        ****                     while(readTiltButtonState() != 0){setLengthLoop();} //Wait until button is rele
 479               	.LM41:
 480 0204 0E94 0000 		call getAngleActuatorSetLength
 481 0208 0596      		adiw r24,5
 482 020a 0E94 0000 		call setAngleMotorLength
  58:test.c        ****                     break;
 484               	.LM42:
 485 020e 8DB7      		in r24,__SP_L__
 486 0210 9EB7      		in r25,__SP_H__
 487 0212 0A96      		adiw r24,10
 488 0214 0FB6      		in __tmp_reg__,__SREG__
 489 0216 F894      		cli
 490 0218 9EBF      		out __SP_H__,r25
 491 021a 0FBE      		out __SREG__,__tmp_reg__
 492 021c 8DBF      		out __SP_L__,r24
 493 021e 00C0      		rjmp .L7
 494               	.L8:
  58:test.c        ****                     break;
 496               	.LM43:
 497 0220 0E94 0000 		call setLengthLoop
 498               	.L7:
  58:test.c        ****                     break;
 500               	.LM44:
 501 0224 0E94 0000 		call readTiltButtonState
 502 0228 8111      		cpse r24,__zero_reg__
 503 022a 00C0      		rjmp .L8
  68:test.c        ****                 case 1:{
 505               	.LM45:
 506 022c 0E94 0000 		call readTurnButtonState
 507 0230 8130      		cpi r24,lo8(1)
 508 0232 01F0      		breq .+2
 509 0234 00C0      		rjmp .L28
 510               	.L13:
  70:test.c        ****                     setTiltMotorLength(getTiltActuatorSetLength()+5);
 512               	.LM46:
 513 0236 0E94 0000 		call readTurnButtonState
 514 023a C82E      		mov r12,r24
 515 023c 0E94 0000 		call readTiltButtonState
 516 0240 D82E      		mov r13,r24
 517 0242 0E94 0000 		call readAutoManualState
 518 0246 1F92      		push __zero_reg__
 519 0248 CF92      		push r12
 520 024a 1F92      		push __zero_reg__
 521 024c DF92      		push r13
 522 024e 1F92      		push __zero_reg__
 523 0250 8F93      		push r24
 524 0252 FF92      		push r15
 525 0254 EF92      		push r14
 526 0256 1F93      		push r17
 527 0258 0F93      		push r16
 528 025a 0E94 0000 		call fprintf
  71:test.c        ****                     while(readTurnButtonState() != 0){setLengthLoop();} //Wait until button is rele
 530               	.LM47:
 531 025e 0E94 0000 		call getTiltActuatorSetLength
 532 0262 0596      		adiw r24,5
 533 0264 0E94 0000 		call setTiltMotorLength
  72:test.c        ****                     break;
 535               	.LM48:
 536 0268 8DB7      		in r24,__SP_L__
 537 026a 9EB7      		in r25,__SP_H__
 538 026c 0A96      		adiw r24,10
 539 026e 0FB6      		in __tmp_reg__,__SREG__
 540 0270 F894      		cli
 541 0272 9EBF      		out __SP_H__,r25
 542 0274 0FBE      		out __SREG__,__tmp_reg__
 543 0276 8DBF      		out __SP_L__,r24
 544 0278 00C0      		rjmp .L15
 545               	.L16:
  72:test.c        ****                     break;
 547               	.LM49:
 548 027a 0E94 0000 		call setLengthLoop
 549               	.L15:
  72:test.c        ****                     break;
 551               	.LM50:
 552 027e 0E94 0000 		call readTurnButtonState
 553 0282 8111      		cpse r24,__zero_reg__
 554 0284 00C0      		rjmp .L16
 555 0286 00C0      		rjmp .L12
 560               	.Lscope2:
 561               		.comm	port,14,1
 563               		.text
 565               	.Letext0:
 566               		.ident	"GCC: (GNU) 4.9.2"
 567               	.global __do_copy_data
 568               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 test.c
     /tmp/ccK4wXtw.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccK4wXtw.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccK4wXtw.s:4      *ABS*:0000003f __SREG__
     /tmp/ccK4wXtw.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccK4wXtw.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccK4wXtw.s:129    .text:00000000 initLED
     /tmp/ccK4wXtw.s:152    .text.startup:00000000 main
                            *COM*:0000000e port

UNDEFINED SYMBOLS
__prologue_saves__
USART_Init
USART0_Flush
initADC
initMotor
initSerialParser
initButtons
readAutoManualState
readTurnButtonState
readTiltButtonState
fprintf
setLengthLoop
getAngleActuatorSetLength
setAngleMotorLength
getTiltActuatorSetLength
setTiltMotorLength
shutdownMotors
__do_copy_data
__do_clear_bss
