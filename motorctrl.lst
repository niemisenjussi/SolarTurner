   1               		.file	"motorctrl.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 118               	.global	__floatunsisf
 119               	.global	__mulsf3
 120               	.global	__floatsisf
 121               	.global	__subsf3
 122               	.global	__addsf3
 123               	.global	__divsf3
 126               	.global	angleConversion
 128               	angleConversion:
   1:motorctrl.c   **** #include "motorctrl.h"
   2:motorctrl.c   **** #include "ADC.h"
   3:motorctrl.c   **** 
   4:motorctrl.c   **** // Forward and backward definition, can be changed
   5:motorctrl.c   **** #define FORWARD 1
   6:motorctrl.c   **** #define BACKWARD 0
   7:motorctrl.c   **** 
   8:motorctrl.c   **** #define FAST_PWM 0x03
   9:motorctrl.c   **** #define OC0A 0x80
  10:motorctrl.c   **** #define OC0B 0x20
  11:motorctrl.c   **** #define OC2A 0x80
  12:motorctrl.c   **** #define OC2B 0x20
  13:motorctrl.c   **** 
  14:motorctrl.c   **** #define SHUTDOWN 0 //shutdown motor
  15:motorctrl.c   **** #define ANGLE_MAX_PWM 0xEE //Angle motor
  16:motorctrl.c   **** #define TILT_MAX_PWM 0xEE //Tilt MOTOR
  17:motorctrl.c   **** #define PRESCALER 0x02 //PWM frequency divider
  18:motorctrl.c   **** #define NUMOFSAMPLES 4 //ADC averaging sample count
  19:motorctrl.c   **** 
  20:motorctrl.c   **** #define MOTOR_HYSTERESIS 1.5  //IN Degrees
  21:motorctrl.c   **** #define MOTOR_ACCELERATION 500 //wait time in micro seconds between speed increase
  22:motorctrl.c   **** #define MOTOR_ACC_STEP 1 //8bit PWM step per acceleration.
  23:motorctrl.c   **** 
  24:motorctrl.c   **** //SET limits for the API
  25:motorctrl.c   **** #define MIN_ANGLE 100.0
  26:motorctrl.c   **** #define ANGLE_RANGE 150.0
  27:motorctrl.c   **** #define MIN_TILT 10.0
  28:motorctrl.c   **** #define TILT_RANGE 80.0
  29:motorctrl.c   **** 
  30:motorctrl.c   **** #define ANGLE_REFERENCE 180.0 //heading by default South
  31:motorctrl.c   **** #define TILT_REFERENCE 5.0   //Tilted 5 degrees upward frow vertical angle
  32:motorctrl.c   **** 
  33:motorctrl.c   **** #define ANGLE_MOTOR_TIMEOUT 10000 // in milliseconds
  34:motorctrl.c   **** #define TILT_MOTOR_TIMEOUT 10000  // in milliseconds
  35:motorctrl.c   **** 
  36:motorctrl.c   **** //Angle correction factors, all values are millimeters
  37:motorctrl.c   **** #define ANGLE_X 700L //Distance from center to actuator lower point
  38:motorctrl.c   **** #define ANGLE_C 190L //Distance from center to actuator far end
  39:motorctrl.c   **** #define ANGLE_Y 5L  //Offset distance from X to outside
  40:motorctrl.c   **** 
  41:motorctrl.c   **** #define TILT_X 510L //Distance from center to actuator lower point
  42:motorctrl.c   **** #define TILT_C 170L //Distance from center to actuator far end
  43:motorctrl.c   **** #define TILT_Y 0L  //Offset distance from X to outside
  44:motorctrl.c   **** 
  45:motorctrl.c   **** //Define Actuator physical measurements
  46:motorctrl.c   **** #define ACTUATOR_A_MIN_LENGTH 515L //absolute value
  47:motorctrl.c   **** #define ACTUATOR_A_MAX_LENGTH 890L //absolute value
  48:motorctrl.c   **** #define ACTUATOR_A_MIN_LIMIT  520L //Minimum limit where actuator can go
  49:motorctrl.c   **** #define ACTUATOR_A_MAX_LIMIT  880L //Maximum limit where actuator can go
  50:motorctrl.c   **** 
  51:motorctrl.c   **** #define ACTUATOR_B_MIN_LENGTH 340L  //375 515-890               //pidempi
  52:motorctrl.c   **** #define ACTUATOR_B_MAX_LENGTH 540L  //200 340-540 pisimmällään  //lyhyempi
  53:motorctrl.c   **** #define ACTUATOR_B_MIN_LIMIT  350L
  54:motorctrl.c   **** #define ACTUATOR_B_MAX_LIMIT  530L
  55:motorctrl.c   **** 
  56:motorctrl.c   **** #define VREF 4.7 //Reference voltage which is used for actuators
  57:motorctrl.c   **** #define ACTUATOR_A_LOW_OFFSET 0.96
  58:motorctrl.c   **** #define ACTUATOR_A_HIGH_OFFSET 3.65
  59:motorctrl.c   **** #define ACTUATOR_B_LOW_OFFSET 1.63
  60:motorctrl.c   **** #define ACTUATOR_B_HIGH_OFFSET 3.02
  61:motorctrl.c   **** 
  62:motorctrl.c   **** #define MOTOR_A 0
  63:motorctrl.c   **** #define MOTOR_B 1
  64:motorctrl.c   **** //Define Actuator ADC Channels for Motor_A and Motor_b
  65:motorctrl.c   **** 
  66:motorctrl.c   **** #define ACTUATOR_ADC_A 0
  67:motorctrl.c   **** #define ACTUATOR_ADC_B 1
  68:motorctrl.c   **** #define ACTUATOR_CURRENT_ADC_A 6 
  69:motorctrl.c   **** #define ACTUATOR_CURRENT_ADC_B 7
  70:motorctrl.c   **** //Defines which actuator is controlling tilt and which controls angular movements
  71:motorctrl.c   **** 
  72:motorctrl.c   **** #define ANGLE_MOTOR MOTOR_A
  73:motorctrl.c   **** #define TILT_MOTOR MOTOR_B 
  74:motorctrl.c   **** 
  75:motorctrl.c   **** #define ANGLE_ACTUATOR_ADC ACTUATOR_ADC_A
  76:motorctrl.c   **** #define TILT_ACTUATOR_ADC  ACTUATOR_ADC_B
  77:motorctrl.c   **** #define ANGLE_ACTUATOR_CURRENT_ADC ACTUATOR_CURRENT_ADC_A
  78:motorctrl.c   **** #define TILT_ACTUATOR_CURRENT_ADC ACTUATOR_CURRENT_ADC_B
  79:motorctrl.c   **** 
  80:motorctrl.c   **** #define TILT_ACTUATOR_LOW_OFFSET ACTUATOR_B_LOW_OFFSET
  81:motorctrl.c   **** #define TILT_ACTUATOR_HIGH_OFFSET ACTUATOR_B_HIGH_OFFSET
  82:motorctrl.c   **** #define ANGLE_ACTUATOR_LOW_OFFSET ACTUATOR_A_LOW_OFFSET
  83:motorctrl.c   **** #define ANGLE_ACTUATOR_HIGH_OFFSET ACTUATOR_A_HIGH_OFFSET
  84:motorctrl.c   **** 
  85:motorctrl.c   **** #define ANGLE_ACTUATOR_MIN_LENGTH ACTUATOR_A_MIN_LENGTH
  86:motorctrl.c   **** #define ANGLE_ACTUATOR_MAX_LENGTH ACTUATOR_A_MAX_LENGTH
  87:motorctrl.c   **** #define ANGLE_ACTUATOR_MIN_LIMIT ACTUATOR_A_MIN_LIMIT
  88:motorctrl.c   **** #define ANGLE_ACTUATOR_MAX_LIMIT ACTUATOR_A_MAX_LIMIT
  89:motorctrl.c   **** 
  90:motorctrl.c   **** #define TILT_ACTUATOR_MIN_LENGTH ACTUATOR_B_MIN_LENGTH
  91:motorctrl.c   **** #define TILT_ACTUATOR_MAX_LENGTH ACTUATOR_B_MAX_LENGTH
  92:motorctrl.c   **** #define TILT_ACTUATOR_MIN_LIMIT ACTUATOR_B_MIN_LIMIT
  93:motorctrl.c   **** #define TILT_ACTUATOR_MAX_LIMIT ACTUATOR_B_MAX_LIMIT
  94:motorctrl.c   **** 
  95:motorctrl.c   **** volatile motor motors[] = {
  96:motorctrl.c   ****     {
  97:motorctrl.c   ****          &PORTD, &DDRD, 6, &TCCR0A, (OC0B + FAST_PWM), &TCCR0B, PRESCALER, &OCR0B, //MOTOR A FORWAR
  98:motorctrl.c   ****          &PORTD, &DDRD, 5, &TCCR0A, (OC0A + FAST_PWM), &TCCR0B, PRESCALER, &OCR0A, //MOTOR A REVERS
  99:motorctrl.c   ****          &PORTD, &DDRD, 7, //MOTOR Enable control
 100:motorctrl.c   ****          ANGLE_ACTUATOR_ADC,
 101:motorctrl.c   ****          ANGLE_ACTUATOR_CURRENT_ADC,
 102:motorctrl.c   ****          &PORTC, &DDRC, 2,
 103:motorctrl.c   ****          &PORTC, &DDRC, 3,
 104:motorctrl.c   ****          0.0,       //Current position
 105:motorctrl.c   ****          FORWARD,   //current dir
 106:motorctrl.c   ****          0.0,       //current position
 107:motorctrl.c   ****          MIN_ANGLE + (ANGLE_RANGE / 2), //Set position, half way
 108:motorctrl.c   ****          MOTOR_ACC_STEP,     //Acceleration step
 109:motorctrl.c   ****          MOTOR_ACC_STEP,     //Deacceleration step
 110:motorctrl.c   ****          MOTOR_ACCELERATION, //Acceleration time
 111:motorctrl.c   ****          MOTOR_ACCELERATION, //deacceleration time
 112:motorctrl.c   ****          MOTOR_HYSTERESIS,   //Anglular hysteresis in degrees
 113:motorctrl.c   ****          ANGLE_MAX_PWM,      //MAX pwm value for anglular movements
 114:motorctrl.c   ****          MIN_ANGLE,          //Minimun allowed angle
 115:motorctrl.c   ****          ANGLE_RANGE,        //0-100 mapping to angle values
 116:motorctrl.c   ****          ANGLE_REFERENCE,    //Reference which against angle corrections are applied   
 117:motorctrl.c   ****          ANGLE_ACTUATOR_MIN_LENGTH,
 118:motorctrl.c   ****          ANGLE_ACTUATOR_MAX_LENGTH,
 119:motorctrl.c   ****          ANGLE_ACTUATOR_MAX_LENGTH - ANGLE_ACTUATOR_MIN_LENGTH,
 120:motorctrl.c   ****          ANGLE_ACTUATOR_MIN_LIMIT,
 121:motorctrl.c   ****          ANGLE_ACTUATOR_MAX_LIMIT,
 122:motorctrl.c   ****          ANGLE_MOTOR_TIMEOUT,//timeout in milliseconds
 123:motorctrl.c   ****          0,                  //timeout current value starts at zero
 124:motorctrl.c   ****          STATUS_OK,
 125:motorctrl.c   ****          &angleConversion, //angle correction function pointer
 126:motorctrl.c   ****          (1024*ANGLE_ACTUATOR_LOW_OFFSET)/VREF, //217,87 offset
 127:motorctrl.c   ****          (1024*ANGLE_ACTUATOR_HIGH_OFFSET)/VREF, //806,12
 128:motorctrl.c   ****          ((1024*ANGLE_ACTUATOR_HIGH_OFFSET)/VREF) - ((1024*ANGLE_ACTUATOR_LOW_OFFSET)/VREF)
 129:motorctrl.c   ****     },
 130:motorctrl.c   ****     {
 131:motorctrl.c   ****          &PORTB, &DDRB, 3, &TCCR2A, (OC2A + FAST_PWM), &TCCR2B, PRESCALER, &OCR2A, //MOTOR B FORWAR
 132:motorctrl.c   ****          &PORTD, &DDRD, 3, &TCCR2A, (OC2B + FAST_PWM), &TCCR2B, PRESCALER, &OCR2B,//MOTOR B REVERSE
 133:motorctrl.c   ****          &PORTB, &DDRB, 4, //MOTOR Enable control
 134:motorctrl.c   ****          TILT_ACTUATOR_ADC,
 135:motorctrl.c   ****          TILT_ACTUATOR_CURRENT_ADC,
 136:motorctrl.c   ****          &PORTC, &DDRC, 4,
 137:motorctrl.c   ****          &PORTC, &DDRC, 5,
 138:motorctrl.c   ****          0.0,         //Current position
 139:motorctrl.c   ****          FORWARD,   //current dir
 140:motorctrl.c   ****          0.0, //current position
 141:motorctrl.c   ****          MIN_TILT + (TILT_RANGE / 2), //Set position, half way
 142:motorctrl.c   ****          MOTOR_ACC_STEP,     //Acceleration step
 143:motorctrl.c   ****          MOTOR_ACC_STEP,     //Deacceleration step
 144:motorctrl.c   ****          MOTOR_ACCELERATION, //Acceleration time
 145:motorctrl.c   ****          MOTOR_ACCELERATION, //deacceleration time
 146:motorctrl.c   ****          MOTOR_HYSTERESIS,   //Anglular hysteresis in degrees
 147:motorctrl.c   ****          TILT_MAX_PWM,      //MAX pwm value for anglular movements
 148:motorctrl.c   ****          MIN_TILT,          //Minimun allowed angle
 149:motorctrl.c   ****          TILT_RANGE,        //0-100 mapping to angle values
 150:motorctrl.c   ****          TILT_REFERENCE,
 151:motorctrl.c   ****          TILT_ACTUATOR_MIN_LENGTH,
 152:motorctrl.c   ****          TILT_ACTUATOR_MAX_LENGTH,
 153:motorctrl.c   ****          TILT_ACTUATOR_MAX_LENGTH - TILT_ACTUATOR_MIN_LENGTH,
 154:motorctrl.c   ****          TILT_ACTUATOR_MIN_LIMIT,
 155:motorctrl.c   ****          TILT_ACTUATOR_MAX_LIMIT,
 156:motorctrl.c   ****          TILT_MOTOR_TIMEOUT,//timeout in milliseconds
 157:motorctrl.c   ****          0,                  //timeout current value starts at zero
 158:motorctrl.c   ****          STATUS_OK,
 159:motorctrl.c   ****          &tiltConversion, //angle correction function pointer
 160:motorctrl.c   ****          (1024*TILT_ACTUATOR_LOW_OFFSET)/VREF, //348,6
 161:motorctrl.c   ****          (1024*TILT_ACTUATOR_HIGH_OFFSET)/VREF, //668,9
 162:motorctrl.c   ****          ((1024*TILT_ACTUATOR_HIGH_OFFSET)/VREF) - ((1024*TILT_ACTUATOR_LOW_OFFSET)/VREF)
 163:motorctrl.c   ****     }};
 164:motorctrl.c   **** 
 165:motorctrl.c   **** FILE *port;
 166:motorctrl.c   **** //Initialize MOTOR A, Angle motor
 167:motorctrl.c   **** //volatile motor motors[NUM_OF_MOTORS];
 168:motorctrl.c   **** //extern motor motors[NUM_OF_MOTORS];
 169:motorctrl.c   **** 
 170:motorctrl.c   **** //returns motor final calculated position in degrees
 171:motorctrl.c   **** float getMotorPosition(volatile motor *m){
 172:motorctrl.c   ****     uint16_t alen = getActuatorLength(m);
 173:motorctrl.c   ****     float aoffset = m->angle_correction(alen);
 174:motorctrl.c   ****     return m->angle_reference + aoffset;
 175:motorctrl.c   ****     /*
 176:motorctrl.c   ****         example reference angle motor = 180
 177:motorctrl.c   ****         aoffset between -90 to 90
 178:motorctrl.c   ****         -90 when actuator is minimum position
 179:motorctrl.c   ****         90 when actuator is at max position
 180:motorctrl.c   **** 
 181:motorctrl.c   ****         ie. 180 + offset => 180 + -90 = 90  degrees
 182:motorctrl.c   ****         ie. 180 +offset  => 180 + +90 = 270 degrees
 183:motorctrl.c   ****     */
 184:motorctrl.c   **** }
 185:motorctrl.c   **** 
 186:motorctrl.c   **** //returns motor actuator length in millimeters
 187:motorctrl.c   **** uint16_t getActuatorLength(volatile motor *m){
 188:motorctrl.c   ****     uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
 189:motorctrl.c   ****     //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
 190:motorctrl.c   ****     voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
 191:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 192:motorctrl.c   ****     uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); /
 193:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 194:motorctrl.c   ****     // 594                                         200/320 = 0.625*(500-348) => 95:
 195:motorctrl.c   **** 
 196:motorctrl.c   ****     //Shutdown if we cross virtual limit
 197:motorctrl.c   ****     if (length >= m->actuator_max_limit){
 198:motorctrl.c   ****         m->status = MAX_LIMIT;
 199:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 200:motorctrl.c   ****     }
 201:motorctrl.c   ****     else if(length <= m->actuator_min_limit){
 202:motorctrl.c   ****         m->status = MIN_LIMIT;
 203:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
 204:motorctrl.c   ****     }
 205:motorctrl.c   ****     return length;
 206:motorctrl.c   **** }
 207:motorctrl.c   **** 
 208:motorctrl.c   **** uint16_t getTiltActuatorCurrentLength(void){
 209:motorctrl.c   ****     return getActuatorLength(&motors[TILT_MOTOR]);
 210:motorctrl.c   **** }
 211:motorctrl.c   **** 
 212:motorctrl.c   **** uint16_t getAngleActuatorCurrentLength(void){
 213:motorctrl.c   ****     return getActuatorLength(&motors[ANGLE_MOTOR]);
 214:motorctrl.c   **** }
 215:motorctrl.c   **** 
 216:motorctrl.c   **** 
 217:motorctrl.c   **** 
 218:motorctrl.c   **** //Returns angle between -90.0 - 90.0, input value is in millimeters.
 219:motorctrl.c   **** float angleConversion(uint16_t f){
 130               	.LM0:
 131               	.LFBB1:
 132 0000 4F92      		push r4
 133 0002 5F92      		push r5
 134 0004 6F92      		push r6
 135 0006 7F92      		push r7
 136 0008 8F92      		push r8
 137 000a 9F92      		push r9
 138 000c AF92      		push r10
 139 000e BF92      		push r11
 140 0010 CF92      		push r12
 141 0012 DF92      		push r13
 142 0014 EF92      		push r14
 143 0016 FF92      		push r15
 144               	/* prologue: function */
 145               	/* frame size = 0 */
 146               	/* stack size = 12 */
 147               	.L__stack_usage = 12
 148 0018 AC01      		movw r20,r24
 220:motorctrl.c   ****     return -(360L*atan((2*ANGLE_C*ANGLE_X-sqrt((-ANGLE_C*ANGLE_C + 2*ANGLE_C*f - pow(f,2.0) + ANGLE
 150               	.LM1:
 151 001a 9C01      		movw r18,r24
 152 001c ACE7      		ldi r26,lo8(124)
 153 001e B1E0      		ldi r27,lo8(1)
 154 0020 0E94 0000 		call __umulhisi3
 155 0024 6B01      		movw r12,r22
 156 0026 7C01      		movw r14,r24
 157 0028 BA01      		movw r22,r20
 158 002a 80E0      		ldi r24,0
 159 002c 90E0      		ldi r25,0
 160 002e 0E94 0000 		call __floatunsisf
 161 0032 9B01      		movw r18,r22
 162 0034 AC01      		movw r20,r24
 163 0036 0E94 0000 		call __mulsf3
 164 003a 4B01      		movw r8,r22
 165 003c 5C01      		movw r10,r24
 166 003e C701      		movw r24,r14
 167 0040 B601      		movw r22,r12
 168 0042 6450      		subi r22,4
 169 0044 7D48      		sbci r23,-115
 170 0046 8109      		sbc r24,__zero_reg__
 171 0048 9109      		sbc r25,__zero_reg__
 221:motorctrl.c   ****             (ANGLE_C*ANGLE_C + 2*ANGLE_C*f + pow(f,2.0)- ANGLE_X*ANGLE_X - ANGLE_Y*ANGLE_Y)))/
 173               	.LM2:
 174 004a 24E0      		ldi r18,4
 175 004c C20E      		add r12,r18
 176 004e 2DE8      		ldi r18,-115
 177 0050 D21E      		adc r13,r18
 178 0052 E11C      		adc r14,__zero_reg__
 179 0054 F11C      		adc r15,__zero_reg__
 220:motorctrl.c   ****     return -(360L*atan((2*ANGLE_C*ANGLE_X-sqrt((-ANGLE_C*ANGLE_C + 2*ANGLE_C*f - pow(f,2.0) + ANGLE
 181               	.LM3:
 182 0056 0E94 0000 		call __floatsisf
 183 005a A501      		movw r20,r10
 184 005c 9401      		movw r18,r8
 185 005e 0E94 0000 		call __subsf3
 186 0062 20E0      		ldi r18,0
 187 0064 32E4      		ldi r19,lo8(66)
 188 0066 4FEE      		ldi r20,lo8(-17)
 189 0068 58E4      		ldi r21,lo8(72)
 190 006a 0E94 0000 		call __addsf3
 191 006e 20E0      		ldi r18,0
 192 0070 30E0      		ldi r19,0
 193 0072 48EC      		ldi r20,lo8(-56)
 194 0074 51E4      		ldi r21,lo8(65)
 195 0076 0E94 0000 		call __addsf3
 196 007a 2B01      		movw r4,r22
 197 007c 3C01      		movw r6,r24
 199               	.LM4:
 200 007e C701      		movw r24,r14
 201 0080 B601      		movw r22,r12
 202 0082 0E94 0000 		call __floatsisf
 203 0086 A501      		movw r20,r10
 204 0088 9401      		movw r18,r8
 205 008a 0E94 0000 		call __addsf3
 206 008e 20E0      		ldi r18,0
 207 0090 32E4      		ldi r19,lo8(66)
 208 0092 4FEE      		ldi r20,lo8(-17)
 209 0094 58E4      		ldi r21,lo8(72)
 210 0096 0E94 0000 		call __subsf3
 211 009a 20E0      		ldi r18,0
 212 009c 30E0      		ldi r19,0
 213 009e 48EC      		ldi r20,lo8(-56)
 214 00a0 51E4      		ldi r21,lo8(65)
 215 00a2 0E94 0000 		call __subsf3
 216 00a6 9B01      		movw r18,r22
 217 00a8 AC01      		movw r20,r24
 220:motorctrl.c   ****     return -(360L*atan((2*ANGLE_C*ANGLE_X-sqrt((-ANGLE_C*ANGLE_C + 2*ANGLE_C*f - pow(f,2.0) + ANGLE
 219               	.LM5:
 220 00aa C301      		movw r24,r6
 221 00ac B201      		movw r22,r4
 222 00ae 0E94 0000 		call __mulsf3
 223 00b2 0E94 0000 		call sqrt
 224 00b6 9B01      		movw r18,r22
 225 00b8 AC01      		movw r20,r24
 226 00ba 60E0      		ldi r22,0
 227 00bc 72EE      		ldi r23,lo8(-30)
 228 00be 81E8      		ldi r24,lo8(-127)
 229 00c0 98E4      		ldi r25,lo8(72)
 230 00c2 0E94 0000 		call __subsf3
 231 00c6 6B01      		movw r12,r22
 232 00c8 7C01      		movw r14,r24
 222:motorctrl.c   ****             (ANGLE_C*ANGLE_C + 2*ANGLE_C*ANGLE_Y - pow(f,2.0) + ANGLE_X*ANGLE_X + ANGLE_Y*ANGLE_Y))
 234               	.LM6:
 235 00ca A501      		movw r20,r10
 236 00cc 9401      		movw r18,r8
 237 00ce 60E0      		ldi r22,0
 238 00d0 70E7      		ldi r23,lo8(112)
 239 00d2 84E1      		ldi r24,lo8(20)
 240 00d4 97E4      		ldi r25,lo8(71)
 241 00d6 0E94 0000 		call __subsf3
 242 00da 20E0      		ldi r18,0
 243 00dc 32E4      		ldi r19,lo8(66)
 244 00de 4FEE      		ldi r20,lo8(-17)
 245 00e0 58E4      		ldi r21,lo8(72)
 246 00e2 0E94 0000 		call __addsf3
 247 00e6 20E0      		ldi r18,0
 248 00e8 30E0      		ldi r19,0
 249 00ea 48EC      		ldi r20,lo8(-56)
 250 00ec 51E4      		ldi r21,lo8(65)
 251 00ee 0E94 0000 		call __addsf3
 252 00f2 9B01      		movw r18,r22
 253 00f4 AC01      		movw r20,r24
 220:motorctrl.c   ****     return -(360L*atan((2*ANGLE_C*ANGLE_X-sqrt((-ANGLE_C*ANGLE_C + 2*ANGLE_C*f - pow(f,2.0) + ANGLE
 255               	.LM7:
 256 00f6 C701      		movw r24,r14
 257 00f8 B601      		movw r22,r12
 258 00fa 0E94 0000 		call __divsf3
 259 00fe 0E94 0000 		call atan
 260 0102 20E0      		ldi r18,0
 261 0104 30E0      		ldi r19,0
 262 0106 44EB      		ldi r20,lo8(-76)
 263 0108 53E4      		ldi r21,lo8(67)
 264 010a 0E94 0000 		call __mulsf3
 265 010e 9058      		subi r25,0x80
 266 0110 2BED      		ldi r18,lo8(-37)
 267 0112 3FE0      		ldi r19,lo8(15)
 268 0114 49E4      		ldi r20,lo8(73)
 269 0116 50E4      		ldi r21,lo8(64)
 270 0118 0E94 0000 		call __divsf3
 271               	/* epilogue start */
 223:motorctrl.c   **** }
 273               	.LM8:
 274 011c FF90      		pop r15
 275 011e EF90      		pop r14
 276 0120 DF90      		pop r13
 277 0122 CF90      		pop r12
 278 0124 BF90      		pop r11
 279 0126 AF90      		pop r10
 280 0128 9F90      		pop r9
 281 012a 8F90      		pop r8
 282 012c 7F90      		pop r7
 283 012e 6F90      		pop r6
 284 0130 5F90      		pop r5
 285 0132 4F90      		pop r4
 286 0134 0895      		ret
 288               	.Lscope1:
 291               	.global	tiltConversion
 293               	tiltConversion:
 224:motorctrl.c   **** 
 225:motorctrl.c   **** //Returns tilt angle between 0 to 90 degrees positive. input values in millimeters 
 226:motorctrl.c   **** float tiltConversion(uint16_t f){
 295               	.LM9:
 296               	.LFBB2:
 297 0136 4F92      		push r4
 298 0138 5F92      		push r5
 299 013a 6F92      		push r6
 300 013c 7F92      		push r7
 301 013e 8F92      		push r8
 302 0140 9F92      		push r9
 303 0142 AF92      		push r10
 304 0144 BF92      		push r11
 305 0146 CF92      		push r12
 306 0148 DF92      		push r13
 307 014a EF92      		push r14
 308 014c FF92      		push r15
 309               	/* prologue: function */
 310               	/* frame size = 0 */
 311               	/* stack size = 12 */
 312               	.L__stack_usage = 12
 313 014e AC01      		movw r20,r24
 227:motorctrl.c   ****     return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_
 315               	.LM10:
 316 0150 9C01      		movw r18,r24
 317 0152 A4E5      		ldi r26,lo8(84)
 318 0154 B1E0      		ldi r27,lo8(1)
 319 0156 0E94 0000 		call __umulhisi3
 320 015a 6B01      		movw r12,r22
 321 015c 7C01      		movw r14,r24
 322 015e BA01      		movw r22,r20
 323 0160 80E0      		ldi r24,0
 324 0162 90E0      		ldi r25,0
 325 0164 0E94 0000 		call __floatunsisf
 326 0168 9B01      		movw r18,r22
 327 016a AC01      		movw r20,r24
 328 016c 0E94 0000 		call __mulsf3
 329 0170 4B01      		movw r8,r22
 330 0172 5C01      		movw r10,r24
 331 0174 C701      		movw r24,r14
 332 0176 B601      		movw r22,r12
 333 0178 645E      		subi r22,-28
 334 017a 7047      		sbci r23,112
 335 017c 8109      		sbc r24,__zero_reg__
 336 017e 9109      		sbc r25,__zero_reg__
 228:motorctrl.c   ****               (TILT_C*TILT_C + 2L*TILT_C*f + pow(f,2.0)- TILT_X*TILT_X - TILT_Y*TILT_Y)))/
 338               	.LM11:
 339 0180 24EE      		ldi r18,-28
 340 0182 C20E      		add r12,r18
 341 0184 20E7      		ldi r18,112
 342 0186 D21E      		adc r13,r18
 343 0188 E11C      		adc r14,__zero_reg__
 344 018a F11C      		adc r15,__zero_reg__
 227:motorctrl.c   ****     return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_
 346               	.LM12:
 347 018c 0E94 0000 		call __floatsisf
 348 0190 A501      		movw r20,r10
 349 0192 9401      		movw r18,r8
 350 0194 0E94 0000 		call __subsf3
 351 0198 20E0      		ldi r18,0
 352 019a 31E0      		ldi r19,lo8(1)
 353 019c 4EE7      		ldi r20,lo8(126)
 354 019e 58E4      		ldi r21,lo8(72)
 355 01a0 0E94 0000 		call __addsf3
 356 01a4 20E0      		ldi r18,0
 357 01a6 30E0      		ldi r19,0
 358 01a8 A901      		movw r20,r18
 359 01aa 0E94 0000 		call __addsf3
 360 01ae 2B01      		movw r4,r22
 361 01b0 3C01      		movw r6,r24
 363               	.LM13:
 364 01b2 C701      		movw r24,r14
 365 01b4 B601      		movw r22,r12
 366 01b6 0E94 0000 		call __floatsisf
 367 01ba A501      		movw r20,r10
 368 01bc 9401      		movw r18,r8
 369 01be 0E94 0000 		call __addsf3
 370 01c2 20E0      		ldi r18,0
 371 01c4 31E0      		ldi r19,lo8(1)
 372 01c6 4EE7      		ldi r20,lo8(126)
 373 01c8 58E4      		ldi r21,lo8(72)
 374 01ca 0E94 0000 		call __subsf3
 375 01ce 9B01      		movw r18,r22
 376 01d0 AC01      		movw r20,r24
 227:motorctrl.c   ****     return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_
 378               	.LM14:
 379 01d2 C301      		movw r24,r6
 380 01d4 B201      		movw r22,r4
 381 01d6 0E94 0000 		call __mulsf3
 382 01da 0E94 0000 		call sqrt
 383 01de 9B01      		movw r18,r22
 384 01e0 AC01      		movw r20,r24
 385 01e2 60E0      		ldi r22,0
 386 01e4 76E5      		ldi r23,lo8(86)
 387 01e6 89E2      		ldi r24,lo8(41)
 388 01e8 98E4      		ldi r25,lo8(72)
 389 01ea 0E94 0000 		call __subsf3
 390 01ee 6B01      		movw r12,r22
 391 01f0 7C01      		movw r14,r24
 229:motorctrl.c   ****               (TILT_C*TILT_C + 2L*TILT_C*TILT_Y - pow(f,2.0) + TILT_X*TILT_X + TILT_Y*TILT_Y)))/M_P
 393               	.LM15:
 394 01f2 A501      		movw r20,r10
 395 01f4 9401      		movw r18,r8
 396 01f6 60E0      		ldi r22,0
 397 01f8 78EC      		ldi r23,lo8(-56)
 398 01fa 81EE      		ldi r24,lo8(-31)
 399 01fc 96E4      		ldi r25,lo8(70)
 400 01fe 0E94 0000 		call __subsf3
 401 0202 20E0      		ldi r18,0
 402 0204 31E0      		ldi r19,lo8(1)
 403 0206 4EE7      		ldi r20,lo8(126)
 404 0208 58E4      		ldi r21,lo8(72)
 405 020a 0E94 0000 		call __addsf3
 406 020e 20E0      		ldi r18,0
 407 0210 30E0      		ldi r19,0
 408 0212 A901      		movw r20,r18
 409 0214 0E94 0000 		call __addsf3
 410 0218 9B01      		movw r18,r22
 411 021a AC01      		movw r20,r24
 227:motorctrl.c   ****     return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_
 413               	.LM16:
 414 021c C701      		movw r24,r14
 415 021e B601      		movw r22,r12
 416 0220 0E94 0000 		call __divsf3
 417 0224 0E94 0000 		call atan
 418 0228 20E0      		ldi r18,0
 419 022a 30E0      		ldi r19,0
 420 022c 44EB      		ldi r20,lo8(-76)
 421 022e 53E4      		ldi r21,lo8(67)
 422 0230 0E94 0000 		call __mulsf3
 424               	.LM17:
 425 0234 2BED      		ldi r18,lo8(-37)
 426 0236 3FE0      		ldi r19,lo8(15)
 427 0238 49E4      		ldi r20,lo8(73)
 428 023a 50E4      		ldi r21,lo8(64)
 429 023c 0E94 0000 		call __divsf3
 430 0240 9B01      		movw r18,r22
 431 0242 AC01      		movw r20,r24
 227:motorctrl.c   ****     return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_
 433               	.LM18:
 434 0244 60E0      		ldi r22,0
 435 0246 70E0      		ldi r23,0
 436 0248 84EB      		ldi r24,lo8(-76)
 437 024a 92E4      		ldi r25,lo8(66)
 438 024c 0E94 0000 		call __subsf3
 439               	/* epilogue start */
 230:motorctrl.c   **** }
 441               	.LM19:
 442 0250 FF90      		pop r15
 443 0252 EF90      		pop r14
 444 0254 DF90      		pop r13
 445 0256 CF90      		pop r12
 446 0258 BF90      		pop r11
 447 025a AF90      		pop r10
 448 025c 9F90      		pop r9
 449 025e 8F90      		pop r8
 450 0260 7F90      		pop r7
 451 0262 6F90      		pop r6
 452 0264 5F90      		pop r5
 453 0266 4F90      		pop r4
 454 0268 0895      		ret
 456               	.Lscope2:
 458               	.global	getAngle
 460               	getAngle:
 231:motorctrl.c   **** 
 232:motorctrl.c   **** 
 233:motorctrl.c   **** float getAngle(void){
 462               	.LM20:
 463               	.LFBB3:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 234:motorctrl.c   ****     return motors[ANGLE_MOTOR].current_position;
 469               	.LM21:
 470 026a 6091 0000 		lds r22,motors+45
 471 026e 7091 0000 		lds r23,motors+45+1
 472 0272 8091 0000 		lds r24,motors+45+2
 473 0276 9091 0000 		lds r25,motors+45+3
 235:motorctrl.c   **** }
 475               	.LM22:
 476 027a 0895      		ret
 478               	.Lscope3:
 480               	.global	getTilt
 482               	getTilt:
 236:motorctrl.c   **** 
 237:motorctrl.c   **** float getTilt(void){
 484               	.LM23:
 485               	.LFBB4:
 486               	/* prologue: function */
 487               	/* frame size = 0 */
 488               	/* stack size = 0 */
 489               	.L__stack_usage = 0
 238:motorctrl.c   ****     return motors[TILT_MOTOR].current_position;
 491               	.LM24:
 492 027c 6091 0000 		lds r22,motors+146
 493 0280 7091 0000 		lds r23,motors+146+1
 494 0284 8091 0000 		lds r24,motors+146+2
 495 0288 9091 0000 		lds r25,motors+146+3
 239:motorctrl.c   **** }
 497               	.LM25:
 498 028c 0895      		ret
 500               	.Lscope4:
 501               	.global	__gesf2
 502               	.global	__lesf2
 505               	.global	setAngle
 507               	setAngle:
 240:motorctrl.c   **** 
 241:motorctrl.c   **** /*
 242:motorctrl.c   ****     This function is used to set wanted Angle value
 243:motorctrl.c   **** */
 244:motorctrl.c   **** uint8_t setAngle(float angle){
 509               	.LM26:
 510               	.LFBB5:
 511 028e CF92      		push r12
 512 0290 DF92      		push r13
 513 0292 EF92      		push r14
 514 0294 FF92      		push r15
 515               	/* prologue: function */
 516               	/* frame size = 0 */
 517               	/* stack size = 4 */
 518               	.L__stack_usage = 4
 519 0296 6B01      		movw r12,r22
 520 0298 7C01      		movw r14,r24
 521               	.LBB44:
 522               	.LBB45:
 245:motorctrl.c   ****     return setMotorPosition(&motors[ANGLE_MOTOR], angle);
 246:motorctrl.c   **** }
 247:motorctrl.c   **** 
 248:motorctrl.c   **** /*
 249:motorctrl.c   ****     This function is used to set wanted TILT angle
 250:motorctrl.c   **** */
 251:motorctrl.c   **** uint8_t setTilt(float tilt){
 252:motorctrl.c   ****     return setMotorPosition(&motors[TILT_MOTOR], tilt);
 253:motorctrl.c   **** }
 254:motorctrl.c   **** 
 255:motorctrl.c   **** uint8_t setMotorPosition(volatile motor *m, float angle){
 256:motorctrl.c   ****     //vefify that angle is in between valid range
 257:motorctrl.c   ****     if (angle >= m->min_angle && angle <= (m->min_angle + m->angle_range)){
 524               	.LM27:
 525 029a 2091 0000 		lds r18,motors+64
 526 029e 3091 0000 		lds r19,motors+64+1
 527 02a2 4091 0000 		lds r20,motors+64+2
 528 02a6 5091 0000 		lds r21,motors+64+3
 529 02aa 0E94 0000 		call __gesf2
 530 02ae 87FF      		sbrs r24,7
 531 02b0 00C0      		rjmp .L16
 532               	.L14:
 258:motorctrl.c   ****         m->set_position = angle;
 259:motorctrl.c   ****         m->timeout_value = 0; //Clear timeout value on every angle change
 260:motorctrl.c   ****         return 0;
 261:motorctrl.c   ****     }
 262:motorctrl.c   ****     else{
 263:motorctrl.c   ****         return 1;
 534               	.LM28:
 535 02b2 81E0      		ldi r24,lo8(1)
 536               	/* epilogue start */
 537               	.LBE45:
 538               	.LBE44:
 246:motorctrl.c   **** 
 540               	.LM29:
 541 02b4 FF90      		pop r15
 542 02b6 EF90      		pop r14
 543 02b8 DF90      		pop r13
 544 02ba CF90      		pop r12
 545 02bc 0895      		ret
 546               	.L16:
 547               	.LBB49:
 548               	.LBB48:
 549               	.LBB46:
 550               	.LBB47:
 257:motorctrl.c   ****         m->set_position = angle;
 552               	.LM30:
 553 02be 6091 0000 		lds r22,motors+64
 554 02c2 7091 0000 		lds r23,motors+64+1
 555 02c6 8091 0000 		lds r24,motors+64+2
 556 02ca 9091 0000 		lds r25,motors+64+3
 557 02ce 2091 0000 		lds r18,motors+68
 558 02d2 3091 0000 		lds r19,motors+68+1
 559 02d6 4091 0000 		lds r20,motors+68+2
 560 02da 5091 0000 		lds r21,motors+68+3
 561 02de 0E94 0000 		call __addsf3
 562 02e2 9B01      		movw r18,r22
 563 02e4 AC01      		movw r20,r24
 564 02e6 C701      		movw r24,r14
 565 02e8 B601      		movw r22,r12
 566 02ea 0E94 0000 		call __lesf2
 567 02ee 1816      		cp __zero_reg__,r24
 568 02f0 04F0      		brlt .L14
 258:motorctrl.c   ****         m->set_position = angle;
 570               	.LM31:
 571 02f2 C092 0000 		sts motors+49,r12
 572 02f6 D092 0000 		sts motors+49+1,r13
 573 02fa E092 0000 		sts motors+49+2,r14
 574 02fe F092 0000 		sts motors+49+3,r15
 259:motorctrl.c   ****         return 0;
 576               	.LM32:
 577 0302 1092 0000 		sts motors+90+1,__zero_reg__
 578 0306 1092 0000 		sts motors+90,__zero_reg__
 260:motorctrl.c   ****     }
 580               	.LM33:
 581 030a 80E0      		ldi r24,0
 582               	/* epilogue start */
 583               	.LBE47:
 584               	.LBE46:
 585               	.LBE48:
 586               	.LBE49:
 246:motorctrl.c   **** 
 588               	.LM34:
 589 030c FF90      		pop r15
 590 030e EF90      		pop r14
 591 0310 DF90      		pop r13
 592 0312 CF90      		pop r12
 593 0314 0895      		ret
 595               	.Lscope5:
 598               	.global	setTilt
 600               	setTilt:
 251:motorctrl.c   ****     return setMotorPosition(&motors[TILT_MOTOR], tilt);
 602               	.LM35:
 603               	.LFBB6:
 604 0316 CF92      		push r12
 605 0318 DF92      		push r13
 606 031a EF92      		push r14
 607 031c FF92      		push r15
 608               	/* prologue: function */
 609               	/* frame size = 0 */
 610               	/* stack size = 4 */
 611               	.L__stack_usage = 4
 612 031e 6B01      		movw r12,r22
 613 0320 7C01      		movw r14,r24
 614               	.LBB54:
 615               	.LBB55:
 257:motorctrl.c   ****         m->set_position = angle;
 617               	.LM36:
 618 0322 2091 0000 		lds r18,motors+165
 619 0326 3091 0000 		lds r19,motors+165+1
 620 032a 4091 0000 		lds r20,motors+165+2
 621 032e 5091 0000 		lds r21,motors+165+3
 622 0332 0E94 0000 		call __gesf2
 623 0336 87FF      		sbrs r24,7
 624 0338 00C0      		rjmp .L27
 625               	.L26:
 627               	.LM37:
 628 033a 81E0      		ldi r24,lo8(1)
 629               	/* epilogue start */
 630               	.LBE55:
 631               	.LBE54:
 253:motorctrl.c   **** 
 633               	.LM38:
 634 033c FF90      		pop r15
 635 033e EF90      		pop r14
 636 0340 DF90      		pop r13
 637 0342 CF90      		pop r12
 638 0344 0895      		ret
 639               	.L27:
 640               	.LBB59:
 641               	.LBB58:
 642               	.LBB56:
 643               	.LBB57:
 257:motorctrl.c   ****         m->set_position = angle;
 645               	.LM39:
 646 0346 6091 0000 		lds r22,motors+165
 647 034a 7091 0000 		lds r23,motors+165+1
 648 034e 8091 0000 		lds r24,motors+165+2
 649 0352 9091 0000 		lds r25,motors+165+3
 650 0356 2091 0000 		lds r18,motors+169
 651 035a 3091 0000 		lds r19,motors+169+1
 652 035e 4091 0000 		lds r20,motors+169+2
 653 0362 5091 0000 		lds r21,motors+169+3
 654 0366 0E94 0000 		call __addsf3
 655 036a 9B01      		movw r18,r22
 656 036c AC01      		movw r20,r24
 657 036e C701      		movw r24,r14
 658 0370 B601      		movw r22,r12
 659 0372 0E94 0000 		call __lesf2
 660 0376 1816      		cp __zero_reg__,r24
 661 0378 04F0      		brlt .L26
 258:motorctrl.c   ****         m->timeout_value = 0; //Clear timeout value on every angle change
 663               	.LM40:
 664 037a C092 0000 		sts motors+150,r12
 665 037e D092 0000 		sts motors+150+1,r13
 666 0382 E092 0000 		sts motors+150+2,r14
 667 0386 F092 0000 		sts motors+150+3,r15
 259:motorctrl.c   ****         return 0;
 669               	.LM41:
 670 038a 1092 0000 		sts motors+191+1,__zero_reg__
 671 038e 1092 0000 		sts motors+191,__zero_reg__
 260:motorctrl.c   ****     }
 673               	.LM42:
 674 0392 80E0      		ldi r24,0
 675               	/* epilogue start */
 676               	.LBE57:
 677               	.LBE56:
 678               	.LBE58:
 679               	.LBE59:
 253:motorctrl.c   **** 
 681               	.LM43:
 682 0394 FF90      		pop r15
 683 0396 EF90      		pop r14
 684 0398 DF90      		pop r13
 685 039a CF90      		pop r12
 686 039c 0895      		ret
 688               	.Lscope6:
 692               	.global	setMotorPosition
 694               	setMotorPosition:
 255:motorctrl.c   ****     //vefify that angle is in between valid range
 696               	.LM44:
 697               	.LFBB7:
 698 039e A0E0      		ldi r26,0
 699 03a0 B0E0      		ldi r27,0
 700 03a2 E0E0      		ldi r30,lo8(gs(1f))
 701 03a4 F0E0      		ldi r31,hi8(gs(1f))
 702 03a6 0C94 0000 		jmp __prologue_saves__+((18 - 8) * 2)
 703               	1:
 704               	/* prologue: function */
 705               	/* frame size = 0 */
 706               	/* stack size = 8 */
 707               	.L__stack_usage = 8
 708 03aa EC01      		movw r28,r24
 709 03ac 6A01      		movw r12,r20
 710 03ae 7B01      		movw r14,r22
 257:motorctrl.c   ****         m->set_position = angle;
 712               	.LM45:
 713 03b0 8C01      		movw r16,r24
 714 03b2 005C      		subi r16,-64
 715 03b4 1F4F      		sbci r17,-1
 716 03b6 F801      		movw r30,r16
 717 03b8 6081      		ld r22,Z
 718 03ba 7181      		ldd r23,Z+1
 719 03bc 8281      		ldd r24,Z+2
 720 03be 9381      		ldd r25,Z+3
 721 03c0 A701      		movw r20,r14
 722 03c2 9601      		movw r18,r12
 723 03c4 0E94 0000 		call __lesf2
 724 03c8 1816      		cp __zero_reg__,r24
 725 03ca 04F0      		brlt .L37
 726               	.LBB62:
 727               	.LBB63:
 728 03cc F801      		movw r30,r16
 729 03ce 6081      		ld r22,Z
 730 03d0 7181      		ldd r23,Z+1
 731 03d2 8281      		ldd r24,Z+2
 732 03d4 9381      		ldd r25,Z+3
 733 03d6 3496      		adiw r30,4
 734 03d8 2081      		ld r18,Z
 735 03da 3181      		ldd r19,Z+1
 736 03dc 4281      		ldd r20,Z+2
 737 03de 5381      		ldd r21,Z+3
 738 03e0 0E94 0000 		call __addsf3
 739 03e4 9B01      		movw r18,r22
 740 03e6 AC01      		movw r20,r24
 741 03e8 C701      		movw r24,r14
 742 03ea B601      		movw r22,r12
 743 03ec 0E94 0000 		call __lesf2
 744 03f0 1816      		cp __zero_reg__,r24
 745 03f2 04F0      		brlt .L37
 258:motorctrl.c   ****         m->timeout_value = 0; //Clear timeout value on every angle change
 747               	.LM46:
 748 03f4 C9AA      		std Y+49,r12
 749 03f6 DAAA      		std Y+50,r13
 750 03f8 EBAA      		std Y+51,r14
 751 03fa FCAA      		std Y+52,r15
 259:motorctrl.c   ****         return 0;
 753               	.LM47:
 754 03fc C65A      		subi r28,-90
 755 03fe DF4F      		sbci r29,-1
 756 0400 1982      		std Y+1,__zero_reg__
 757 0402 1882      		st Y,__zero_reg__
 260:motorctrl.c   ****     }
 759               	.LM48:
 760 0404 80E0      		ldi r24,0
 761               	/* epilogue start */
 762               	.LBE63:
 763               	.LBE62:
 264:motorctrl.c   ****     }
 265:motorctrl.c   **** }   
 765               	.LM49:
 766 0406 CDB7      		in r28,__SP_L__
 767 0408 DEB7      		in r29,__SP_H__
 768 040a E8E0      		ldi r30, lo8(8)
 769 040c 0C94 0000 		jmp __epilogue_restores__ + ((18 - 8) * 2)
 770 0410 00C0      		rjmp .L38
 771               	.L37:
 263:motorctrl.c   ****     }
 773               	.LM50:
 774 0412 81E0      		ldi r24,lo8(1)
 775               	/* epilogue start */
 777               	.LM51:
 778 0414 CDB7      		in r28,__SP_L__
 779 0416 DEB7      		in r29,__SP_H__
 780 0418 E8E0      		ldi r30, lo8(8)
 781 041a 0C94 0000 		jmp __epilogue_restores__ + ((18 - 8) * 2)
 782               	.L38:
 784               	.Lscope7:
 786               	.global	getSetAngle
 788               	getSetAngle:
 266:motorctrl.c   **** 
 267:motorctrl.c   **** /*
 268:motorctrl.c   ****     Returns current Angle Set value
 269:motorctrl.c   **** */
 270:motorctrl.c   **** float getSetAngle(void){
 790               	.LM52:
 791               	.LFBB8:
 792               	/* prologue: function */
 793               	/* frame size = 0 */
 794               	/* stack size = 0 */
 795               	.L__stack_usage = 0
 271:motorctrl.c   ****     return motors[ANGLE_MOTOR].set_position;
 797               	.LM53:
 798 041e 6091 0000 		lds r22,motors+49
 799 0422 7091 0000 		lds r23,motors+49+1
 800 0426 8091 0000 		lds r24,motors+49+2
 801 042a 9091 0000 		lds r25,motors+49+3
 272:motorctrl.c   **** }
 803               	.LM54:
 804 042e 0895      		ret
 806               	.Lscope8:
 808               	.global	getSetTilt
 810               	getSetTilt:
 273:motorctrl.c   **** 
 274:motorctrl.c   **** /*
 275:motorctrl.c   ****     Returns current Tilt Set value  
 276:motorctrl.c   **** */
 277:motorctrl.c   **** float getSetTilt(void){
 812               	.LM55:
 813               	.LFBB9:
 814               	/* prologue: function */
 815               	/* frame size = 0 */
 816               	/* stack size = 0 */
 817               	.L__stack_usage = 0
 278:motorctrl.c   ****     return motors[TILT_MOTOR].set_position;
 819               	.LM56:
 820 0430 6091 0000 		lds r22,motors+150
 821 0434 7091 0000 		lds r23,motors+150+1
 822 0438 8091 0000 		lds r24,motors+150+2
 823 043c 9091 0000 		lds r25,motors+150+3
 279:motorctrl.c   **** }
 825               	.LM57:
 826 0440 0895      		ret
 828               	.Lscope9:
 830               	.global	getAngleMotorStatus
 832               	getAngleMotorStatus:
 280:motorctrl.c   **** 
 281:motorctrl.c   **** /*
 282:motorctrl.c   ****     Returns Angle motor status  
 283:motorctrl.c   **** */
 284:motorctrl.c   **** motor_status getAngleMotorStatus(void){
 834               	.LM58:
 835               	.LFBB10:
 836               	/* prologue: function */
 837               	/* frame size = 0 */
 838               	/* stack size = 0 */
 839               	.L__stack_usage = 0
 285:motorctrl.c   ****     return motors[ANGLE_MOTOR].status;
 841               	.LM59:
 842 0442 8091 0000 		lds r24,motors+92
 286:motorctrl.c   **** }
 844               	.LM60:
 845 0446 0895      		ret
 847               	.Lscope10:
 849               	.global	getTiltMotorStatus
 851               	getTiltMotorStatus:
 287:motorctrl.c   **** 
 288:motorctrl.c   **** /*
 289:motorctrl.c   ****     Returns Tilt motor status,   
 290:motorctrl.c   **** */
 291:motorctrl.c   **** motor_status getTiltMotorStatus(void){
 853               	.LM61:
 854               	.LFBB11:
 855               	/* prologue: function */
 856               	/* frame size = 0 */
 857               	/* stack size = 0 */
 858               	.L__stack_usage = 0
 292:motorctrl.c   ****     return motors[TILT_MOTOR].status;
 860               	.LM62:
 861 0448 8091 0000 		lds r24,motors+193
 293:motorctrl.c   **** }
 863               	.LM63:
 864 044c 0895      		ret
 866               	.Lscope11:
 869               	.global	delayLoop_us
 871               	delayLoop_us:
 294:motorctrl.c   **** 
 295:motorctrl.c   **** /*
 296:motorctrl.c   ****     Shutdown all motors, this is used to activate manual mode
 297:motorctrl.c   **** */
 298:motorctrl.c   **** void shutdownMotors(void){
 299:motorctrl.c   ****     for (uint8_t i = 0; i<NUM_OF_MOTORS; i++){
 300:motorctrl.c   ****         disableMotorPWM(&motors[i]);
 301:motorctrl.c   ****         motors[i].current_position = getMotorPosition(&motors[i]);
 302:motorctrl.c   ****         motors[i].set_position = motors[i].current_position; //reset settings
 303:motorctrl.c   ****     }
 304:motorctrl.c   **** }
 305:motorctrl.c   **** 
 306:motorctrl.c   **** 
 307:motorctrl.c   **** /*
 308:motorctrl.c   ****     This function controls angle and tilt motors
 309:motorctrl.c   ****     It reads actual Angle and Tilt values using ADC
 310:motorctrl.c   ****     Then it Adjust motor PWM to correct direction and leaves it there.
 311:motorctrl.c   ****     This function must be called n. times per second
 312:motorctrl.c   **** */
 313:motorctrl.c   **** motor_status motorController(void){
 314:motorctrl.c   ****     //Update current motor positions
 315:motorctrl.c   ****     uint8_t status = 0;
 316:motorctrl.c   ****     for (uint8_t i = 0; i < NUM_OF_MOTORS; i++){
 317:motorctrl.c   ****         volatile motor *m = &motors[i];
 318:motorctrl.c   ****         m->current_position = getMotorPosition(m); 
 319:motorctrl.c   ****         motorControlLoop(m);
 320:motorctrl.c   ****         status += m->status; //Collect status from all motors
 321:motorctrl.c   ****     }
 322:motorctrl.c   ****     return status;
 323:motorctrl.c   **** }
 324:motorctrl.c   **** 
 325:motorctrl.c   **** //This is motorcontrol loop which is called n. times per second.
 326:motorctrl.c   **** void motorControlLoop(volatile motor *m){    
 327:motorctrl.c   ****     //Check if we have been running too long
 328:motorctrl.c   ****     if (m->timeout_value >= m->timeout_setting){
 329:motorctrl.c   ****         m->status = TIMEOUT_ERROR;
 330:motorctrl.c   ****         fprintf(port, "timeout\n");
 331:motorctrl.c   ****         motorControl(m, m->current_dir, 0); //Shutdown motor if it has been running too long.
 332:motorctrl.c   ****         _delay_ms(100);
 333:motorctrl.c   ****         return;
 334:motorctrl.c   ****     }
 335:motorctrl.c   **** 
 336:motorctrl.c   ****     //Set position is higher than current
 337:motorctrl.c   ****     if (m->current_position <= (m->set_position - m->angle_hysteresis)){// && m->status != MAX_LIMI
 338:motorctrl.c   ****         motorControl(m, FORWARD, m->max_pwm);
 339:motorctrl.c   ****         m->timeout_value ++; //update timeout variables
 340:motorctrl.c   ****         m->status = RUNNING_FORWARD;
 341:motorctrl.c   ****       //  fprintf(port, "fw\n");
 342:motorctrl.c   ****     }
 343:motorctrl.c   ****     else if (m->current_position >= (m->set_position + m->angle_hysteresis)){// && m->status != MIN
 344:motorctrl.c   ****         motorControl(m, BACKWARD, m->max_pwm);
 345:motorctrl.c   ****         m->timeout_value ++;
 346:motorctrl.c   ****         m->status = RUNNING_BACKWARD;
 347:motorctrl.c   ****        // fprintf(port, "rev\n");
 348:motorctrl.c   ****     }
 349:motorctrl.c   ****     else{ //Motor is close enough wanted position, Shutdown motor
 350:motorctrl.c   ****         for(; m->current_pwm > 0; m->current_pwm--){
 351:motorctrl.c   ****             setMotor(m, m->current_dir, m->current_pwm);
 352:motorctrl.c   ****             delayLoop_us(m->deacceleration_time);
 353:motorctrl.c   ****         }
 354:motorctrl.c   ****         //setMotor(m, m->current_dir, 0);
 355:motorctrl.c   ****         m->timeout_value = 0; //Clear timeout
 356:motorctrl.c   ****         m->status = STATUS_OK;
 357:motorctrl.c   ****         disableMotorPWM(m);       
 358:motorctrl.c   ****         _delay_ms(50);
 359:motorctrl.c   ****     }
 360:motorctrl.c   **** }
 361:motorctrl.c   **** 
 362:motorctrl.c   **** void delayLoop_us(uint16_t delay){
 873               	.LM64:
 874               	.LFBB12:
 875               	/* prologue: function */
 876               	/* frame size = 0 */
 877               	/* stack size = 0 */
 878               	.L__stack_usage = 0
 879               	.LBB64:
 363:motorctrl.c   ****     for (uint16_t i = 0; i < delay/50; i++){
 881               	.LM65:
 882 044e 9C01      		movw r18,r24
 883 0450 3695      		lsr r19
 884 0452 2795      		ror r18
 885 0454 ABE7      		ldi r26,lo8(123)
 886 0456 B4E1      		ldi r27,lo8(20)
 887 0458 0E94 0000 		call __umulhisi3
 888 045c 9695      		lsr r25
 889 045e 8795      		ror r24
 890 0460 0097      		sbiw r24,0
 891 0462 01F0      		breq .L43
 892 0464 20E0      		ldi r18,0
 893 0466 30E0      		ldi r19,0
 894               	.L44:
 895               	.LBB65:
 896               	.LBB66:
 898               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 900               	.LM66:
 901 0468 4AEF      		ldi r20,lo8(-6)
 902 046a 4A95      	1:	dec r20
 903 046c 01F4      		brne 1b
 904 046e 00C0      		rjmp .
 905               	.LBE66:
 906               	.LBE65:
 908               	.Ltext2:
 910               	.LM67:
 911 0470 2F5F      		subi r18,-1
 912 0472 3F4F      		sbci r19,-1
 913 0474 2817      		cp r18,r24
 914 0476 3907      		cpc r19,r25
 915 0478 01F4      		brne .L44
 916               	.L43:
 917 047a 0895      		ret
 918               	.LBE64:
 923               	.Lscope12:
 926               	.global	disableMotorPWM
 928               	disableMotorPWM:
 364:motorctrl.c   ****         _delay_us(47);
 365:motorctrl.c   ****     }
 366:motorctrl.c   **** }
 367:motorctrl.c   **** 
 368:motorctrl.c   **** void motorControl(volatile motor *m, uint8_t dir, uint8_t pwm){
 369:motorctrl.c   ****     //verify min/max
 370:motorctrl.c   ****     if (pwm > m->max_pwm){
 371:motorctrl.c   ****         pwm = m->max_pwm;
 372:motorctrl.c   ****     }
 373:motorctrl.c   ****     
 374:motorctrl.c   ****     //Set motor control
 375:motorctrl.c   ****     if (m->current_pwm < pwm){ //Need to accelerate
 376:motorctrl.c   ****         for(; m->current_pwm < pwm; m->current_pwm++){
 377:motorctrl.c   ****             setMotor(m, dir, m->current_pwm);
 378:motorctrl.c   ****             //getActuatorLength(m);
 379:motorctrl.c   ****             delayLoop_us(m->acceleration_time);
 380:motorctrl.c   ****         }
 381:motorctrl.c   ****         setMotor(m, dir, m->current_pwm);
 382:motorctrl.c   ****     }
 383:motorctrl.c   ****     else if (m->current_pwm > pwm){
 384:motorctrl.c   ****         for(; m->current_pwm > pwm; m->current_pwm--){
 385:motorctrl.c   ****             setMotor(m, dir, m->current_pwm);
 386:motorctrl.c   ****             //getActuatorLength(m);
 387:motorctrl.c   ****             delayLoop_us(m->deacceleration_time);
 388:motorctrl.c   ****         } 
 389:motorctrl.c   ****         setMotor(m, dir, m->current_pwm);
 390:motorctrl.c   ****     }
 391:motorctrl.c   ****     m->current_dir = dir;
 392:motorctrl.c   **** }
 393:motorctrl.c   **** 
 394:motorctrl.c   **** 
 395:motorctrl.c   **** void initMotor(FILE *debugport){
 396:motorctrl.c   ****     port = debugport;
 397:motorctrl.c   ****     //motors[ANGLE_MOTOR] = m1;
 398:motorctrl.c   ****     //motors[TILT_MOTOR] = m1;
 399:motorctrl.c   **** 
 400:motorctrl.c   **** 
 401:motorctrl.c   ****     for(uint8_t i = 0; i<NUM_OF_MOTORS; i++){
 402:motorctrl.c   ****         volatile motor *m = &motors[i];
 403:motorctrl.c   ****         //Set direction and enable to output pins
 404:motorctrl.c   ****         *m->fwd_dir_addr |= 1<<m->fwd_pin;
 405:motorctrl.c   ****         *m->rev_dir_addr |= 1<<m->rev_pin;
 406:motorctrl.c   ****         *m->enable_dir_addr |= 1<<m->enable_pin;
 407:motorctrl.c   ****         
 408:motorctrl.c   ****         //Set pullups correctly
 409:motorctrl.c   ****         *m->fwd_port_addr &= ~(1<<m->fwd_pin);
 410:motorctrl.c   ****         *m->rev_port_addr &= ~(1<<m->rev_pin);
 411:motorctrl.c   ****         *m->enable_port_addr &= ~(1<<m->enable_pin);
 412:motorctrl.c   ****         
 413:motorctrl.c   ****         //Init forward PWM settings
 414:motorctrl.c   ****         *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 415:motorctrl.c   ****         *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 416:motorctrl.c   ****         *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 417:motorctrl.c   ****         
 418:motorctrl.c   ****         //Init reverse PWM settings
 419:motorctrl.c   ****         *m->rev_TCCRA_addr = 0x00;//m.rev_TCCRA_value;
 420:motorctrl.c   ****         *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 421:motorctrl.c   ****         *m->rev_OCR_addr = 0x00; //Init PWM to zero
 422:motorctrl.c   ****         
 423:motorctrl.c   ****         //init Actuator +5 and GND pins
 424:motorctrl.c   ****         //*m.actuator_1_port_addr |= 1<<m.actuator_1_pin;
 425:motorctrl.c   ****         //*m.actuator_1_dir_addr |= 1<<m.actuator_1_pin;
 426:motorctrl.c   ****         //*m.actuator_2_port_addr &= ~(1<<m.actuator_2_pin);
 427:motorctrl.c   ****         //*m.actuator_2_dir_addr |= 1<<m.actuator_2_pin;
 428:motorctrl.c   ****         _delay_ms(10); //wait 10ms so ADC pins settle.
 429:motorctrl.c   **** 
 430:motorctrl.c   ****         m->current_position = getMotorPosition(m);
 431:motorctrl.c   ****         m->set_position = m->current_position; //reset settings
 432:motorctrl.c   ****     }
 433:motorctrl.c   **** 
 434:motorctrl.c   **** 
 435:motorctrl.c   ****         //Update motor positions
 436:motorctrl.c   ****     //motors[ANGLE_MOTOR].current_position = getAngle();
 437:motorctrl.c   ****     //motors[TILT_MOTOR].current_position  = getTilt();    
 438:motorctrl.c   ****     
 439:motorctrl.c   ****    // GTCCR = 0x00;       //Start Counter
 440:motorctrl.c   **** }
 441:motorctrl.c   **** void disableMotorPWM(volatile motor *m){
 930               	.LM68:
 931               	.LFBB13:
 932               	/* prologue: function */
 933               	/* frame size = 0 */
 934               	/* stack size = 0 */
 935               	.L__stack_usage = 0
 936 047c FC01      		movw r30,r24
 442:motorctrl.c   **** 
 443:motorctrl.c   ****     *m->enable_port_addr &= ~(1<<m->enable_pin); //Disable motor => clear enable port
 938               	.LM69:
 939 047e 368D      		ldd r19,Z+30
 940 0480 A28D      		ldd r26,Z+26
 941 0482 B38D      		ldd r27,Z+27
 942 0484 2C91      		ld r18,X
 943 0486 81E0      		ldi r24,lo8(1)
 944 0488 90E0      		ldi r25,0
 945 048a 00C0      		rjmp 2f
 946               		1:
 947 048c 880F      		lsl r24
 948 048e 991F      		rol r25
 949               		2:
 950 0490 3A95      		dec r19
 951 0492 02F4      		brpl 1b
 952 0494 8095      		com r24
 953 0496 9095      		com r25
 954 0498 8223      		and r24,r18
 955 049a 8C93      		st X,r24
 444:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 957               	.LM70:
 958 049c A581      		ldd r26,Z+5
 959 049e B681      		ldd r27,Z+6
 960 04a0 1C92      		st X,__zero_reg__
 445:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 962               	.LM71:
 963 04a2 A085      		ldd r26,Z+8
 964 04a4 B185      		ldd r27,Z+9
 965 04a6 1C92      		st X,__zero_reg__
 446:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 967               	.LM72:
 968 04a8 A385      		ldd r26,Z+11
 969 04aa B485      		ldd r27,Z+12
 970 04ac 1C92      		st X,__zero_reg__
 447:motorctrl.c   ****     
 448:motorctrl.c   ****     //Init reverse PWM settings
 449:motorctrl.c   ****     *m->rev_TCCRA_addr = 0x00;//m.rev_TCCRA_value;
 972               	.LM73:
 973 04ae A289      		ldd r26,Z+18
 974 04b0 B389      		ldd r27,Z+19
 975 04b2 1C92      		st X,__zero_reg__
 450:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 977               	.LM74:
 978 04b4 A589      		ldd r26,Z+21
 979 04b6 B689      		ldd r27,Z+22
 980 04b8 1C92      		st X,__zero_reg__
 451:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 982               	.LM75:
 983 04ba A08D      		ldd r26,Z+24
 984 04bc B18D      		ldd r27,Z+25
 985 04be 1C92      		st X,__zero_reg__
 452:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 987               	.LM76:
 988 04c0 13A6      		std Z+43,__zero_reg__
 453:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 990               	.LM77:
 991 04c2 E65A      		subi r30,-90
 992 04c4 FF4F      		sbci r31,-1
 993 04c6 1182      		std Z+1,__zero_reg__
 994 04c8 1082      		st Z,__zero_reg__
 995 04ca 0895      		ret
 997               	.Lscope13:
 1002               	.global	setMotor
 1004               	setMotor:
 454:motorctrl.c   ****     
 455:motorctrl.c   **** } 
 456:motorctrl.c   **** //volatile uint8_t *OCRC_ADDR[] = {&OCR1CL, &OCR4AL }
 457:motorctrl.c   **** //volatile uint8_t *OCRB_ADDR[] = {&OCR1BL, &OCR4BL }
 458:motorctrl.c   **** 
 459:motorctrl.c   **** void setMotor(volatile motor *m, uint8_t dir, uint8_t pwm){
 1006               	.LM78:
 1007               	.LFBB14:
 1008               	/* prologue: function */
 1009               	/* frame size = 0 */
 1010               	/* stack size = 0 */
 1011               	.L__stack_usage = 0
 1012 04cc FC01      		movw r30,r24
 460:motorctrl.c   ****     m->current_pwm = pwm;
 1014               	.LM79:
 1015 04ce 43A7      		std Z+43,r20
 461:motorctrl.c   ****     if (pwm > 0){
 1017               	.LM80:
 1018 04d0 4423      		tst r20
 1019 04d2 01F0      		breq .L50
 462:motorctrl.c   ****         if (dir == FORWARD){ //Forward
 1021               	.LM81:
 1022 04d4 6130      		cpi r22,lo8(1)
 1023 04d6 01F4      		brne .+2
 1024 04d8 00C0      		rjmp .L54
 463:motorctrl.c   ****             *m->rev_OCR_addr = 0x00; //PWM pulse width
 464:motorctrl.c   ****             *m->fwd_OCR_addr = pwm; 
 465:motorctrl.c   ****             *m->rev_port_addr &= ~(1<<m->rev_pin);
 466:motorctrl.c   ****             *m->rev_TCCRA_addr = 0x00; //Disable reverse
 467:motorctrl.c   ****             *m->fwd_TCCRA_addr = m->fwd_TCCRA_value; //Activate PWM forward
 468:motorctrl.c   ****             
 469:motorctrl.c   ****             *m->rev_TCCRB_addr = 0x00; //Disable clock Rev
 470:motorctrl.c   ****             *m->fwd_TCCRB_addr = m->fwd_TCCRB_value;
 471:motorctrl.c   ****         }
 472:motorctrl.c   ****         else{ //Backward
 473:motorctrl.c   ****             *m->fwd_OCR_addr = 0x00;
 1026               	.LM82:
 1027 04da A385      		ldd r26,Z+11
 1028 04dc B485      		ldd r27,Z+12
 1029 04de 1C92      		st X,__zero_reg__
 474:motorctrl.c   ****             *m->rev_OCR_addr = pwm; 
 1031               	.LM83:
 1032 04e0 A08D      		ldd r26,Z+24
 1033 04e2 B18D      		ldd r27,Z+25
 1034 04e4 4C93      		st X,r20
 475:motorctrl.c   ****             *m->fwd_port_addr &= ~(1<<m->fwd_pin);
 1036               	.LM84:
 1037 04e6 3481      		ldd r19,Z+4
 1038 04e8 A081      		ld r26,Z
 1039 04ea B181      		ldd r27,Z+1
 1040 04ec 2C91      		ld r18,X
 1041 04ee 81E0      		ldi r24,lo8(1)
 1042 04f0 90E0      		ldi r25,0
 1043 04f2 00C0      		rjmp 2f
 1044               		1:
 1045 04f4 880F      		lsl r24
 1046 04f6 991F      		rol r25
 1047               		2:
 1048 04f8 3A95      		dec r19
 1049 04fa 02F4      		brpl 1b
 1050 04fc 8095      		com r24
 1051 04fe 9095      		com r25
 1052 0500 8223      		and r24,r18
 1053 0502 8C93      		st X,r24
 476:motorctrl.c   ****             *m->fwd_TCCRA_addr = 0x00; //Disable FWD
 1055               	.LM85:
 1056 0504 A581      		ldd r26,Z+5
 1057 0506 B681      		ldd r27,Z+6
 1058 0508 1C92      		st X,__zero_reg__
 477:motorctrl.c   ****             *m->rev_TCCRA_addr = m->rev_TCCRA_value;
 1060               	.LM86:
 1061 050a A289      		ldd r26,Z+18
 1062 050c B389      		ldd r27,Z+19
 1063 050e 8489      		ldd r24,Z+20
 1064 0510 8C93      		st X,r24
 478:motorctrl.c   **** 
 479:motorctrl.c   ****             *m->fwd_TCCRB_addr = 0x00;
 1066               	.LM87:
 1067 0512 A085      		ldd r26,Z+8
 1068 0514 B185      		ldd r27,Z+9
 1069 0516 1C92      		st X,__zero_reg__
 480:motorctrl.c   ****             *m->rev_TCCRB_addr = m->rev_TCCRB_value;
 1071               	.LM88:
 1072 0518 A589      		ldd r26,Z+21
 1073 051a B689      		ldd r27,Z+22
 1074 051c 8789      		ldd r24,Z+23
 1075 051e 8C93      		st X,r24
 1076               	.L52:
 481:motorctrl.c   ****         }        
 482:motorctrl.c   ****         *m->enable_port_addr |= 1<<m->enable_pin; 
 1078               	.LM89:
 1079 0520 368D      		ldd r19,Z+30
 1080 0522 028C      		ldd __tmp_reg__,Z+26
 1081 0524 F38D      		ldd r31,Z+27
 1082 0526 E02D      		mov r30,__tmp_reg__
 1083 0528 2081      		ld r18,Z
 1084 052a 81E0      		ldi r24,lo8(1)
 1085 052c 90E0      		ldi r25,0
 1086 052e 00C0      		rjmp 2f
 1087               		1:
 1088 0530 880F      		lsl r24
 1089               		2:
 1090 0532 3A95      		dec r19
 1091 0534 02F4      		brpl 1b
 1092 0536 822B      		or r24,r18
 1093 0538 8083      		st Z,r24
 1094 053a 0895      		ret
 1095               	.L50:
 1096               	.LBB69:
 1097               	.LBB70:
 443:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 1099               	.LM90:
 1100 053c 368D      		ldd r19,Z+30
 1101 053e A28D      		ldd r26,Z+26
 1102 0540 B38D      		ldd r27,Z+27
 1103 0542 2C91      		ld r18,X
 1104 0544 81E0      		ldi r24,lo8(1)
 1105 0546 90E0      		ldi r25,0
 1106 0548 00C0      		rjmp 2f
 1107               		1:
 1108 054a 880F      		lsl r24
 1109 054c 991F      		rol r25
 1110               		2:
 1111 054e 3A95      		dec r19
 1112 0550 02F4      		brpl 1b
 1113 0552 8095      		com r24
 1114 0554 9095      		com r25
 1115 0556 8223      		and r24,r18
 1116 0558 8C93      		st X,r24
 444:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 1118               	.LM91:
 1119 055a A581      		ldd r26,Z+5
 1120 055c B681      		ldd r27,Z+6
 1121 055e 1C92      		st X,__zero_reg__
 445:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 1123               	.LM92:
 1124 0560 A085      		ldd r26,Z+8
 1125 0562 B185      		ldd r27,Z+9
 1126 0564 1C92      		st X,__zero_reg__
 446:motorctrl.c   ****     
 1128               	.LM93:
 1129 0566 A385      		ldd r26,Z+11
 1130 0568 B485      		ldd r27,Z+12
 1131 056a 1C92      		st X,__zero_reg__
 449:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 1133               	.LM94:
 1134 056c A289      		ldd r26,Z+18
 1135 056e B389      		ldd r27,Z+19
 1136 0570 1C92      		st X,__zero_reg__
 450:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 1138               	.LM95:
 1139 0572 A589      		ldd r26,Z+21
 1140 0574 B689      		ldd r27,Z+22
 1141 0576 1C92      		st X,__zero_reg__
 451:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 1143               	.LM96:
 1144 0578 A08D      		ldd r26,Z+24
 1145 057a B18D      		ldd r27,Z+25
 1146 057c 1C92      		st X,__zero_reg__
 452:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 1148               	.LM97:
 1149 057e 13A6      		std Z+43,__zero_reg__
 453:motorctrl.c   ****     
 1151               	.LM98:
 1152 0580 E65A      		subi r30,-90
 1153 0582 FF4F      		sbci r31,-1
 1154 0584 1182      		std Z+1,__zero_reg__
 1155 0586 1082      		st Z,__zero_reg__
 1156 0588 0895      		ret
 1157               	.L54:
 1158               	.LBE70:
 1159               	.LBE69:
 463:motorctrl.c   ****             *m->fwd_OCR_addr = pwm; 
 1161               	.LM99:
 1162 058a A08D      		ldd r26,Z+24
 1163 058c B18D      		ldd r27,Z+25
 1164 058e 1C92      		st X,__zero_reg__
 464:motorctrl.c   ****             *m->rev_port_addr &= ~(1<<m->rev_pin);
 1166               	.LM100:
 1167 0590 A385      		ldd r26,Z+11
 1168 0592 B485      		ldd r27,Z+12
 1169 0594 4C93      		st X,r20
 465:motorctrl.c   ****             *m->rev_TCCRA_addr = 0x00; //Disable reverse
 1171               	.LM101:
 1172 0596 3189      		ldd r19,Z+17
 1173 0598 A585      		ldd r26,Z+13
 1174 059a B685      		ldd r27,Z+14
 1175 059c 2C91      		ld r18,X
 1176 059e 81E0      		ldi r24,lo8(1)
 1177 05a0 90E0      		ldi r25,0
 1178 05a2 00C0      		rjmp 2f
 1179               		1:
 1180 05a4 880F      		lsl r24
 1181 05a6 991F      		rol r25
 1182               		2:
 1183 05a8 3A95      		dec r19
 1184 05aa 02F4      		brpl 1b
 1185 05ac 8095      		com r24
 1186 05ae 9095      		com r25
 1187 05b0 8223      		and r24,r18
 1188 05b2 8C93      		st X,r24
 466:motorctrl.c   ****             *m->fwd_TCCRA_addr = m->fwd_TCCRA_value; //Activate PWM forward
 1190               	.LM102:
 1191 05b4 A289      		ldd r26,Z+18
 1192 05b6 B389      		ldd r27,Z+19
 1193 05b8 1C92      		st X,__zero_reg__
 467:motorctrl.c   ****             
 1195               	.LM103:
 1196 05ba A581      		ldd r26,Z+5
 1197 05bc B681      		ldd r27,Z+6
 1198 05be 8781      		ldd r24,Z+7
 1199 05c0 8C93      		st X,r24
 469:motorctrl.c   ****             *m->fwd_TCCRB_addr = m->fwd_TCCRB_value;
 1201               	.LM104:
 1202 05c2 A589      		ldd r26,Z+21
 1203 05c4 B689      		ldd r27,Z+22
 1204 05c6 1C92      		st X,__zero_reg__
 470:motorctrl.c   ****         }
 1206               	.LM105:
 1207 05c8 A085      		ldd r26,Z+8
 1208 05ca B185      		ldd r27,Z+9
 1209 05cc 8285      		ldd r24,Z+10
 1210 05ce 8C93      		st X,r24
 1211 05d0 00C0      		rjmp .L52
 1213               	.Lscope14:
 1218               	.global	motorControl
 1220               	motorControl:
 368:motorctrl.c   ****     //verify min/max
 1222               	.LM106:
 1223               	.LFBB15:
 1224 05d2 0F93      		push r16
 1225 05d4 1F93      		push r17
 1226 05d6 CF93      		push r28
 1227 05d8 DF93      		push r29
 1228               	/* prologue: function */
 1229               	/* frame size = 0 */
 1230               	/* stack size = 4 */
 1231               	.L__stack_usage = 4
 1232 05da EC01      		movw r28,r24
 1233 05dc 062F      		mov r16,r22
 1234 05de 142F      		mov r17,r20
 370:motorctrl.c   ****         pwm = m->max_pwm;
 1236               	.LM107:
 1237 05e0 8FAD      		ldd r24,Y+63
 1238 05e2 8417      		cp r24,r20
 1239 05e4 00F4      		brsh .L56
 371:motorctrl.c   ****     }
 1241               	.LM108:
 1242 05e6 1FAD      		ldd r17,Y+63
 1243               	.L56:
 375:motorctrl.c   ****         for(; m->current_pwm < pwm; m->current_pwm++){
 1245               	.LM109:
 1246 05e8 8BA5      		ldd r24,Y+43
 1247 05ea 8117      		cp r24,r17
 1248 05ec 00F0      		brlo .+2
 1249 05ee 00C0      		rjmp .L57
 376:motorctrl.c   ****             setMotor(m, dir, m->current_pwm);
 1251               	.LM110:
 1252 05f0 8BA5      		ldd r24,Y+43
 1253 05f2 8117      		cp r24,r17
 1254 05f4 00F0      		brlo .+2
 1255 05f6 00C0      		rjmp .L69
 1256               	.LBB83:
 1257               	.LBB84:
 1259               	.LM111:
 1260 05f8 41E0      		ldi r20,lo8(1)
 1261 05fa 50E0      		ldi r21,0
 1262               	.LBB85:
 1263               	.LBB86:
 453:motorctrl.c   ****     
 1265               	.LM112:
 1266 05fc FE01      		movw r30,r28
 1267 05fe E65A      		subi r30,-90
 1268 0600 FF4F      		sbci r31,-1
 1269               	.L73:
 1270               	.LBE86:
 1271               	.LBE85:
 1272               	.LBE84:
 1273               	.LBE83:
 377:motorctrl.c   ****             //getActuatorLength(m);
 1275               	.LM113:
 1276 0602 8BA5      		ldd r24,Y+43
 1277               	.LBB91:
 1278               	.LBB89:
 460:motorctrl.c   ****     if (pwm > 0){
 1280               	.LM114:
 1281 0604 8BA7      		std Y+43,r24
 461:motorctrl.c   ****         if (dir == FORWARD){ //Forward
 1283               	.LM115:
 1284 0606 8823      		tst r24
 1285 0608 01F4      		brne .+2
 1286 060a 00C0      		rjmp .L60
 462:motorctrl.c   ****             *m->rev_OCR_addr = 0x00; //PWM pulse width
 1288               	.LM116:
 1289 060c 0130      		cpi r16,lo8(1)
 1290 060e 01F4      		brne .+2
 1291 0610 00C0      		rjmp .L80
 473:motorctrl.c   ****             *m->rev_OCR_addr = pwm; 
 1293               	.LM117:
 1294 0612 AB85      		ldd r26,Y+11
 1295 0614 BC85      		ldd r27,Y+12
 1296 0616 1C92      		st X,__zero_reg__
 474:motorctrl.c   ****             *m->fwd_port_addr &= ~(1<<m->fwd_pin);
 1298               	.LM118:
 1299 0618 A88D      		ldd r26,Y+24
 1300 061a B98D      		ldd r27,Y+25
 1301 061c 8C93      		st X,r24
 475:motorctrl.c   ****             *m->fwd_TCCRA_addr = 0x00; //Disable FWD
 1303               	.LM119:
 1304 061e 8C81      		ldd r24,Y+4
 1305 0620 A881      		ld r26,Y
 1306 0622 B981      		ldd r27,Y+1
 1307 0624 2C91      		ld r18,X
 1308 0626 BA01      		movw r22,r20
 1309 0628 00C0      		rjmp 2f
 1310               		1:
 1311 062a 660F      		lsl r22
 1312 062c 771F      		rol r23
 1313               		2:
 1314 062e 8A95      		dec r24
 1315 0630 02F4      		brpl 1b
 1316 0632 CB01      		movw r24,r22
 1317 0634 8095      		com r24
 1318 0636 9095      		com r25
 1319 0638 8223      		and r24,r18
 1320 063a 8C93      		st X,r24
 476:motorctrl.c   ****             *m->rev_TCCRA_addr = m->rev_TCCRA_value;
 1322               	.LM120:
 1323 063c AD81      		ldd r26,Y+5
 1324 063e BE81      		ldd r27,Y+6
 1325 0640 1C92      		st X,__zero_reg__
 477:motorctrl.c   **** 
 1327               	.LM121:
 1328 0642 AA89      		ldd r26,Y+18
 1329 0644 BB89      		ldd r27,Y+19
 1330 0646 8C89      		ldd r24,Y+20
 1331 0648 8C93      		st X,r24
 479:motorctrl.c   ****             *m->rev_TCCRB_addr = m->rev_TCCRB_value;
 1333               	.LM122:
 1334 064a A885      		ldd r26,Y+8
 1335 064c B985      		ldd r27,Y+9
 1336 064e 1C92      		st X,__zero_reg__
 480:motorctrl.c   ****         }        
 1338               	.LM123:
 1339 0650 AD89      		ldd r26,Y+21
 1340 0652 BE89      		ldd r27,Y+22
 1341 0654 8F89      		ldd r24,Y+23
 1342 0656 8C93      		st X,r24
 1343               	.L62:
 1345               	.LM124:
 1346 0658 8E8D      		ldd r24,Y+30
 1347 065a AA8D      		ldd r26,Y+26
 1348 065c BB8D      		ldd r27,Y+27
 1349 065e 2C91      		ld r18,X
 1350 0660 BA01      		movw r22,r20
 1351 0662 00C0      		rjmp 2f
 1352               		1:
 1353 0664 660F      		lsl r22
 1354 0666 771F      		rol r23
 1355               		2:
 1356 0668 8A95      		dec r24
 1357 066a 02F4      		brpl 1b
 1358 066c CB01      		movw r24,r22
 1359 066e 822B      		or r24,r18
 1360 0670 8C93      		st X,r24
 1361               	.L63:
 1362               	.LBE89:
 1363               	.LBE91:
 379:motorctrl.c   ****         }
 1365               	.LM125:
 1366 0672 2FA9      		ldd r18,Y+55
 1367 0674 38AD      		ldd r19,Y+56
 1368               	.LBB92:
 1369               	.LBB93:
 363:motorctrl.c   ****         _delay_us(47);
 1371               	.LM126:
 1372 0676 3695      		lsr r19
 1373 0678 2795      		ror r18
 1374 067a ABE7      		ldi r26,lo8(123)
 1375 067c B4E1      		ldi r27,lo8(20)
 1376 067e 0E94 0000 		call __umulhisi3
 1377 0682 9695      		lsr r25
 1378 0684 8795      		ror r24
 1379 0686 0097      		sbiw r24,0
 1380 0688 01F0      		breq .L66
 363:motorctrl.c   ****         _delay_us(47);
 1382               	.LM127:
 1383 068a 20E0      		ldi r18,0
 1384 068c 30E0      		ldi r19,0
 1385               	.L64:
 1386               	.LBB94:
 1387               	.LBB95:
 1389               	.Ltext3:
 1391               	.LM128:
 1392 068e 7AEF      		ldi r23,lo8(-6)
 1393 0690 7A95      	1:	dec r23
 1394 0692 01F4      		brne 1b
 1395 0694 00C0      		rjmp .
 1396               	.LBE95:
 1397               	.LBE94:
 1399               	.Ltext4:
 363:motorctrl.c   ****         _delay_us(47);
 1401               	.LM129:
 1402 0696 2F5F      		subi r18,-1
 1403 0698 3F4F      		sbci r19,-1
 1404 069a 2817      		cp r18,r24
 1405 069c 3907      		cpc r19,r25
 1406 069e 01F4      		brne .L64
 1407               	.L66:
 1408               	.LBE93:
 1409               	.LBE92:
 376:motorctrl.c   ****             setMotor(m, dir, m->current_pwm);
 1411               	.LM130:
 1412 06a0 8BA5      		ldd r24,Y+43
 1413 06a2 8F5F      		subi r24,lo8(-(1))
 1414 06a4 8BA7      		std Y+43,r24
 1415 06a6 8BA5      		ldd r24,Y+43
 1416 06a8 8117      		cp r24,r17
 1417 06aa 00F4      		brsh .+2
 1418 06ac 00C0      		rjmp .L73
 1419               	.L69:
 389:motorctrl.c   ****     }
 1421               	.LM131:
 1422 06ae 4BA5      		ldd r20,Y+43
 1423 06b0 602F      		mov r22,r16
 1424 06b2 CE01      		movw r24,r28
 1425 06b4 0E94 0000 		call setMotor
 1426               	.L59:
 391:motorctrl.c   **** }
 1428               	.LM132:
 1429 06b8 0CA7      		std Y+44,r16
 1430               	/* epilogue start */
 392:motorctrl.c   **** 
 1432               	.LM133:
 1433 06ba DF91      		pop r29
 1434 06bc CF91      		pop r28
 1435 06be 1F91      		pop r17
 1436 06c0 0F91      		pop r16
 1437 06c2 0895      		ret
 1438               	.L57:
 383:motorctrl.c   ****         for(; m->current_pwm > pwm; m->current_pwm--){
 1440               	.LM134:
 1441 06c4 8BA5      		ldd r24,Y+43
 1442 06c6 1817      		cp r17,r24
 1443 06c8 00F4      		brsh .L59
 1444               	.L79:
 384:motorctrl.c   ****             setMotor(m, dir, m->current_pwm);
 1446               	.LM135:
 1447 06ca 8BA5      		ldd r24,Y+43
 1448 06cc 1817      		cp r17,r24
 1449 06ce 00F4      		brsh .L69
 385:motorctrl.c   ****             //getActuatorLength(m);
 1451               	.LM136:
 1452 06d0 4BA5      		ldd r20,Y+43
 1453 06d2 602F      		mov r22,r16
 1454 06d4 CE01      		movw r24,r28
 1455 06d6 0E94 0000 		call setMotor
 387:motorctrl.c   ****         } 
 1457               	.LM137:
 1458 06da 29AD      		ldd r18,Y+57
 1459 06dc 3AAD      		ldd r19,Y+58
 1460               	.LBB96:
 1461               	.LBB97:
 363:motorctrl.c   ****         _delay_us(47);
 1463               	.LM138:
 1464 06de 3695      		lsr r19
 1465 06e0 2795      		ror r18
 1466 06e2 ABE7      		ldi r26,lo8(123)
 1467 06e4 B4E1      		ldi r27,lo8(20)
 1468 06e6 0E94 0000 		call __umulhisi3
 1469 06ea 9695      		lsr r25
 1470 06ec 8795      		ror r24
 1471 06ee 0097      		sbiw r24,0
 1472 06f0 01F0      		breq .L70
 363:motorctrl.c   ****         _delay_us(47);
 1474               	.LM139:
 1475 06f2 20E0      		ldi r18,0
 1476 06f4 30E0      		ldi r19,0
 1477               	.L68:
 1478               	.LBB98:
 1479               	.LBB99:
 1481               	.Ltext5:
 1483               	.LM140:
 1484 06f6 4AEF      		ldi r20,lo8(-6)
 1485 06f8 4A95      	1:	dec r20
 1486 06fa 01F4      		brne 1b
 1487 06fc 00C0      		rjmp .
 1488               	.LBE99:
 1489               	.LBE98:
 1491               	.Ltext6:
 363:motorctrl.c   ****         _delay_us(47);
 1493               	.LM141:
 1494 06fe 2F5F      		subi r18,-1
 1495 0700 3F4F      		sbci r19,-1
 1496 0702 2817      		cp r18,r24
 1497 0704 3907      		cpc r19,r25
 1498 0706 01F4      		brne .L68
 1499               	.L70:
 1500               	.LBE97:
 1501               	.LBE96:
 384:motorctrl.c   ****             setMotor(m, dir, m->current_pwm);
 1503               	.LM142:
 1504 0708 8BA5      		ldd r24,Y+43
 1505 070a 8150      		subi r24,lo8(-(-1))
 1506 070c 8BA7      		std Y+43,r24
 1507 070e 00C0      		rjmp .L79
 1508               	.L60:
 1509               	.LBB100:
 1510               	.LBB90:
 1511               	.LBB88:
 1512               	.LBB87:
 443:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 1514               	.LM143:
 1515 0710 8E8D      		ldd r24,Y+30
 1516 0712 AA8D      		ldd r26,Y+26
 1517 0714 BB8D      		ldd r27,Y+27
 1518 0716 2C91      		ld r18,X
 1519 0718 BA01      		movw r22,r20
 1520 071a 00C0      		rjmp 2f
 1521               		1:
 1522 071c 660F      		lsl r22
 1523 071e 771F      		rol r23
 1524               		2:
 1525 0720 8A95      		dec r24
 1526 0722 02F4      		brpl 1b
 1527 0724 CB01      		movw r24,r22
 1528 0726 8095      		com r24
 1529 0728 9095      		com r25
 1530 072a 8223      		and r24,r18
 1531 072c 8C93      		st X,r24
 444:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 1533               	.LM144:
 1534 072e AD81      		ldd r26,Y+5
 1535 0730 BE81      		ldd r27,Y+6
 1536 0732 1C92      		st X,__zero_reg__
 445:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 1538               	.LM145:
 1539 0734 A885      		ldd r26,Y+8
 1540 0736 B985      		ldd r27,Y+9
 1541 0738 1C92      		st X,__zero_reg__
 446:motorctrl.c   ****     
 1543               	.LM146:
 1544 073a AB85      		ldd r26,Y+11
 1545 073c BC85      		ldd r27,Y+12
 1546 073e 1C92      		st X,__zero_reg__
 449:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 1548               	.LM147:
 1549 0740 AA89      		ldd r26,Y+18
 1550 0742 BB89      		ldd r27,Y+19
 1551 0744 1C92      		st X,__zero_reg__
 450:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 1553               	.LM148:
 1554 0746 AD89      		ldd r26,Y+21
 1555 0748 BE89      		ldd r27,Y+22
 1556 074a 1C92      		st X,__zero_reg__
 451:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 1558               	.LM149:
 1559 074c A88D      		ldd r26,Y+24
 1560 074e B98D      		ldd r27,Y+25
 1561 0750 1C92      		st X,__zero_reg__
 452:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 1563               	.LM150:
 1564 0752 1BA6      		std Y+43,__zero_reg__
 453:motorctrl.c   ****     
 1566               	.LM151:
 1567 0754 1182      		std Z+1,__zero_reg__
 1568 0756 1082      		st Z,__zero_reg__
 1569 0758 00C0      		rjmp .L63
 1570               	.L80:
 1571               	.LBE87:
 1572               	.LBE88:
 463:motorctrl.c   ****             *m->fwd_OCR_addr = pwm; 
 1574               	.LM152:
 1575 075a A88D      		ldd r26,Y+24
 1576 075c B98D      		ldd r27,Y+25
 1577 075e 1C92      		st X,__zero_reg__
 464:motorctrl.c   ****             *m->rev_port_addr &= ~(1<<m->rev_pin);
 1579               	.LM153:
 1580 0760 AB85      		ldd r26,Y+11
 1581 0762 BC85      		ldd r27,Y+12
 1582 0764 8C93      		st X,r24
 465:motorctrl.c   ****             *m->rev_TCCRA_addr = 0x00; //Disable reverse
 1584               	.LM154:
 1585 0766 8989      		ldd r24,Y+17
 1586 0768 AD85      		ldd r26,Y+13
 1587 076a BE85      		ldd r27,Y+14
 1588 076c 2C91      		ld r18,X
 1589 076e BA01      		movw r22,r20
 1590 0770 00C0      		rjmp 2f
 1591               		1:
 1592 0772 660F      		lsl r22
 1593 0774 771F      		rol r23
 1594               		2:
 1595 0776 8A95      		dec r24
 1596 0778 02F4      		brpl 1b
 1597 077a CB01      		movw r24,r22
 1598 077c 8095      		com r24
 1599 077e 9095      		com r25
 1600 0780 8223      		and r24,r18
 1601 0782 8C93      		st X,r24
 466:motorctrl.c   ****             *m->fwd_TCCRA_addr = m->fwd_TCCRA_value; //Activate PWM forward
 1603               	.LM155:
 1604 0784 AA89      		ldd r26,Y+18
 1605 0786 BB89      		ldd r27,Y+19
 1606 0788 1C92      		st X,__zero_reg__
 467:motorctrl.c   ****             
 1608               	.LM156:
 1609 078a AD81      		ldd r26,Y+5
 1610 078c BE81      		ldd r27,Y+6
 1611 078e 8F81      		ldd r24,Y+7
 1612 0790 8C93      		st X,r24
 469:motorctrl.c   ****             *m->fwd_TCCRB_addr = m->fwd_TCCRB_value;
 1614               	.LM157:
 1615 0792 AD89      		ldd r26,Y+21
 1616 0794 BE89      		ldd r27,Y+22
 1617 0796 1C92      		st X,__zero_reg__
 470:motorctrl.c   ****         }
 1619               	.LM158:
 1620 0798 A885      		ldd r26,Y+8
 1621 079a B985      		ldd r27,Y+9
 1622 079c 8A85      		ldd r24,Y+10
 1623 079e 8C93      		st X,r24
 1624 07a0 00C0      		rjmp .L62
 1625               	.LBE90:
 1626               	.LBE100:
 1634               	.Lscope15:
 1635               	.global	__fixunssfsi
 1638               	.global	getActuatorLength
 1640               	getActuatorLength:
 187:motorctrl.c   ****     uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
 1642               	.LM159:
 1643               	.LFBB16:
 1644 07a2 A0E0      		ldi r26,0
 1645 07a4 B0E0      		ldi r27,0
 1646 07a6 E0E0      		ldi r30,lo8(gs(1f))
 1647 07a8 F0E0      		ldi r31,hi8(gs(1f))
 1648 07aa 0C94 0000 		jmp __prologue_saves__+((18 - 18) * 2)
 1649               	1:
 1650               	/* prologue: function */
 1651               	/* frame size = 0 */
 1652               	/* stack size = 18 */
 1653               	.L__stack_usage = 18
 1654 07ae EC01      		movw r28,r24
 188:motorctrl.c   ****     //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
 1656               	.LM160:
 1657 07b0 8F8D      		ldd r24,Y+31
 1658 07b2 44E0      		ldi r20,lo8(4)
 1659 07b4 60E4      		ldi r22,lo8(64)
 1660 07b6 0E94 0000 		call AVGVoltage
 1661 07ba 6C01      		movw r12,r24
 1662 07bc E12C      		mov r14,__zero_reg__
 1663 07be F12C      		mov r15,__zero_reg__
 190:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 1665               	.LM161:
 1666 07c0 FE01      		movw r30,r28
 1667 07c2 E15A      		subi r30,-95
 1668 07c4 FF4F      		sbci r31,-1
 1669 07c6 2080      		ld r2,Z
 1670 07c8 3180      		ldd r3,Z+1
 192:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 1672               	.LM162:
 1673 07ca 7397      		sbiw r30,19
 1674 07cc 6081      		ld r22,Z
 1675 07ce 7181      		ldd r23,Z+1
 1676 07d0 3496      		adiw r30,4
 1677 07d2 4080      		ld r4,Z
 1678 07d4 5180      		ldd r5,Z+1
 1679 07d6 6280      		ldd r6,Z+2
 1680 07d8 7380      		ldd r7,Z+3
 1681 07da 7396      		adiw r30,19
 1682 07dc 0081      		ld r16,Z
 1683 07de 1181      		ldd r17,Z+1
 1684 07e0 80E0      		ldi r24,0
 1685 07e2 90E0      		ldi r25,0
 1686 07e4 0E94 0000 		call __floatunsisf
 1687 07e8 4B01      		movw r8,r22
 1688 07ea 5C01      		movw r10,r24
 1689 07ec B801      		movw r22,r16
 1690 07ee 80E0      		ldi r24,0
 1691 07f0 90E0      		ldi r25,0
 1692 07f2 0E94 0000 		call __floatunsisf
 1693 07f6 9B01      		movw r18,r22
 1694 07f8 AC01      		movw r20,r24
 1695 07fa C301      		movw r24,r6
 1696 07fc B201      		movw r22,r4
 1697 07fe 0E94 0000 		call __divsf3
 1698 0802 2B01      		movw r4,r22
 1699 0804 3C01      		movw r6,r24
 190:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 1701               	.LM163:
 1702 0806 C701      		movw r24,r14
 1703 0808 B601      		movw r22,r12
 1704 080a 6219      		sub r22,r2
 1705 080c 7309      		sbc r23,r3
 1706 080e 8109      		sbc r24,__zero_reg__
 1707 0810 9109      		sbc r25,__zero_reg__
 192:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 1709               	.LM164:
 1710 0812 0E94 0000 		call __floatunsisf
 1711 0816 9B01      		movw r18,r22
 1712 0818 AC01      		movw r20,r24
 1713 081a C301      		movw r24,r6
 1714 081c B201      		movw r22,r4
 1715 081e 0E94 0000 		call __mulsf3
 1716 0822 9B01      		movw r18,r22
 1717 0824 AC01      		movw r20,r24
 1718 0826 C501      		movw r24,r10
 1719 0828 B401      		movw r22,r8
 1720 082a 0E94 0000 		call __addsf3
 1721 082e 0E94 0000 		call __fixunssfsi
 1722 0832 6B01      		movw r12,r22
 1723 0834 7C01      		movw r14,r24
 197:motorctrl.c   ****         m->status = MAX_LIMIT;
 1725               	.LM165:
 1726 0836 FE01      		movw r30,r28
 1727 0838 EA5A      		subi r30,-86
 1728 083a FF4F      		sbci r31,-1
 1729 083c 2081      		ld r18,Z
 1730 083e 3181      		ldd r19,Z+1
 1731 0840 6217      		cp r22,r18
 1732 0842 7307      		cpc r23,r19
 1733 0844 00F4      		brsh .L85
 201:motorctrl.c   ****         m->status = MIN_LIMIT;
 1735               	.LM166:
 1736 0846 FE01      		movw r30,r28
 1737 0848 EC5A      		subi r30,-84
 1738 084a FF4F      		sbci r31,-1
 1739 084c 2081      		ld r18,Z
 1740 084e 3181      		ldd r19,Z+1
 1741 0850 2617      		cp r18,r22
 1742 0852 3707      		cpc r19,r23
 1743 0854 00F4      		brsh .L86
 206:motorctrl.c   **** 
 1745               	.LM167:
 1746 0856 C601      		movw r24,r12
 1747               	/* epilogue start */
 1748 0858 CDB7      		in r28,__SP_L__
 1749 085a DEB7      		in r29,__SP_H__
 1750 085c E2E1      		ldi r30, lo8(18)
 1751 085e 0C94 0000 		jmp __epilogue_restores__ + ((18 - 18) * 2)
 1752 0862 00C0      		rjmp .L87
 1753               	.L86:
 202:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
 1755               	.LM168:
 1756 0864 3896      		adiw r30,8
 1757 0866 84E0      		ldi r24,lo8(4)
 1758               	.L84:
 1759 0868 8083      		st Z,r24
 203:motorctrl.c   ****     }
 1761               	.LM169:
 1762 086a 6CA5      		ldd r22,Y+44
 1763 086c 40E0      		ldi r20,0
 1764 086e CE01      		movw r24,r28
 1765 0870 0E94 0000 		call motorControl
 206:motorctrl.c   **** 
 1767               	.LM170:
 1768 0874 C601      		movw r24,r12
 1769               	/* epilogue start */
 1770 0876 CDB7      		in r28,__SP_L__
 1771 0878 DEB7      		in r29,__SP_H__
 1772 087a E2E1      		ldi r30, lo8(18)
 1773 087c 0C94 0000 		jmp __epilogue_restores__ + ((18 - 18) * 2)
 1774 0880 00C0      		rjmp .L87
 1775               	.L85:
 1776               	.LBB103:
 1777               	.LBB104:
 198:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 1779               	.LM171:
 1780 0882 3696      		adiw r30,6
 1781 0884 85E0      		ldi r24,lo8(5)
 1782 0886 00C0      		rjmp .L84
 1783               	.L87:
 1784               	.LBE104:
 1785               	.LBE103:
 1790               	.Lscope16:
 1791               		.section	.rodata.str1.1,"aMS",@progbits,1
 1792               	.LC0:
 1793 0000 7469 6D65 		.string	"timeout\n"
 1793      6F75 740A 
 1793      00
 1794               		.text
 1797               	.global	motorControlLoop
 1799               	motorControlLoop:
 326:motorctrl.c   ****     //Check if we have been running too long
 1801               	.LM172:
 1802               	.LFBB17:
 1803 0888 A0E0      		ldi r26,0
 1804 088a B0E0      		ldi r27,0
 1805 088c E0E0      		ldi r30,lo8(gs(1f))
 1806 088e F0E0      		ldi r31,hi8(gs(1f))
 1807 0890 0C94 0000 		jmp __prologue_saves__+((18 - 8) * 2)
 1808               	1:
 1809               	/* prologue: function */
 1810               	/* frame size = 0 */
 1811               	/* stack size = 8 */
 1812               	.L__stack_usage = 8
 1813 0894 EC01      		movw r28,r24
 328:motorctrl.c   ****         m->status = TIMEOUT_ERROR;
 1815               	.LM173:
 1816 0896 8C01      		movw r16,r24
 1817 0898 065A      		subi r16,-90
 1818 089a 1F4F      		sbci r17,-1
 1819 089c F801      		movw r30,r16
 1820 089e 2081      		ld r18,Z
 1821 08a0 3181      		ldd r19,Z+1
 1822 08a2 3297      		sbiw r30,2
 1823 08a4 8081      		ld r24,Z
 1824 08a6 9181      		ldd r25,Z+1
 1825 08a8 2817      		cp r18,r24
 1826 08aa 3907      		cpc r19,r25
 1827 08ac 00F0      		brlo .+2
 1828 08ae 00C0      		rjmp .L108
 337:motorctrl.c   ****         motorControl(m, FORWARD, m->max_pwm);
 1830               	.LM174:
 1831 08b0 CDA4      		ldd r12,Y+45
 1832 08b2 DEA4      		ldd r13,Y+46
 1833 08b4 EFA4      		ldd r14,Y+47
 1834 08b6 F8A8      		ldd r15,Y+48
 1835 08b8 69A9      		ldd r22,Y+49
 1836 08ba 7AA9      		ldd r23,Y+50
 1837 08bc 8BA9      		ldd r24,Y+51
 1838 08be 9CA9      		ldd r25,Y+52
 1839 08c0 2BAD      		ldd r18,Y+59
 1840 08c2 3CAD      		ldd r19,Y+60
 1841 08c4 4DAD      		ldd r20,Y+61
 1842 08c6 5EAD      		ldd r21,Y+62
 1843 08c8 0E94 0000 		call __subsf3
 1844 08cc 9B01      		movw r18,r22
 1845 08ce AC01      		movw r20,r24
 1846 08d0 C701      		movw r24,r14
 1847 08d2 B601      		movw r22,r12
 1848 08d4 0E94 0000 		call __lesf2
 1849 08d8 1816      		cp __zero_reg__,r24
 1850 08da 04F0      		brlt .+2
 1851 08dc 00C0      		rjmp .L109
 1852               	.LBB123:
 1853               	.LBB124:
 343:motorctrl.c   ****         motorControl(m, BACKWARD, m->max_pwm);
 1855               	.LM175:
 1856 08de CDA4      		ldd r12,Y+45
 1857 08e0 DEA4      		ldd r13,Y+46
 1858 08e2 EFA4      		ldd r14,Y+47
 1859 08e4 F8A8      		ldd r15,Y+48
 1860 08e6 69A9      		ldd r22,Y+49
 1861 08e8 7AA9      		ldd r23,Y+50
 1862 08ea 8BA9      		ldd r24,Y+51
 1863 08ec 9CA9      		ldd r25,Y+52
 1864 08ee 2BAD      		ldd r18,Y+59
 1865 08f0 3CAD      		ldd r19,Y+60
 1866 08f2 4DAD      		ldd r20,Y+61
 1867 08f4 5EAD      		ldd r21,Y+62
 1868 08f6 0E94 0000 		call __addsf3
 1869 08fa 9B01      		movw r18,r22
 1870 08fc AC01      		movw r20,r24
 1871 08fe C701      		movw r24,r14
 1872 0900 B601      		movw r22,r12
 1873 0902 0E94 0000 		call __gesf2
 1874 0906 87FF      		sbrs r24,7
 1875 0908 00C0      		rjmp .L93
 350:motorctrl.c   ****             setMotor(m, m->current_dir, m->current_pwm);
 1877               	.LM176:
 1878 090a 8BA5      		ldd r24,Y+43
 1879 090c 8823      		tst r24
 1880 090e 01F4      		brne .+2
 1881 0910 00C0      		rjmp .L100
 1882               	.LBB125:
 1883               	.LBB126:
 1885               	.LM177:
 1886 0912 41E0      		ldi r20,lo8(1)
 1887 0914 50E0      		ldi r21,0
 1888               	.L104:
 1889               	.LBE126:
 1890               	.LBE125:
 351:motorctrl.c   ****             delayLoop_us(m->deacceleration_time);
 1892               	.LM178:
 1893 0916 8BA5      		ldd r24,Y+43
 1894 0918 9CA5      		ldd r25,Y+44
 1895               	.LBB131:
 1896               	.LBB129:
 460:motorctrl.c   ****     if (pwm > 0){
 1898               	.LM179:
 1899 091a 8BA7      		std Y+43,r24
 461:motorctrl.c   ****         if (dir == FORWARD){ //Forward
 1901               	.LM180:
 1902 091c 8823      		tst r24
 1903 091e 01F4      		brne .+2
 1904 0920 00C0      		rjmp .L95
 462:motorctrl.c   ****             *m->rev_OCR_addr = 0x00; //PWM pulse width
 1906               	.LM181:
 1907 0922 9130      		cpi r25,lo8(1)
 1908 0924 01F4      		brne .+2
 1909 0926 00C0      		rjmp .L110
 473:motorctrl.c   ****             *m->rev_OCR_addr = pwm; 
 1911               	.LM182:
 1912 0928 EB85      		ldd r30,Y+11
 1913 092a FC85      		ldd r31,Y+12
 1914 092c 1082      		st Z,__zero_reg__
 474:motorctrl.c   ****             *m->fwd_port_addr &= ~(1<<m->fwd_pin);
 1916               	.LM183:
 1917 092e E88D      		ldd r30,Y+24
 1918 0930 F98D      		ldd r31,Y+25
 1919 0932 8083      		st Z,r24
 475:motorctrl.c   ****             *m->fwd_TCCRA_addr = 0x00; //Disable FWD
 1921               	.LM184:
 1922 0934 8C81      		ldd r24,Y+4
 1923 0936 E881      		ld r30,Y
 1924 0938 F981      		ldd r31,Y+1
 1925 093a 2081      		ld r18,Z
 1926 093c BA01      		movw r22,r20
 1927 093e 00C0      		rjmp 2f
 1928               		1:
 1929 0940 660F      		lsl r22
 1930 0942 771F      		rol r23
 1931               		2:
 1932 0944 8A95      		dec r24
 1933 0946 02F4      		brpl 1b
 1934 0948 CB01      		movw r24,r22
 1935 094a 8095      		com r24
 1936 094c 9095      		com r25
 1937 094e 8223      		and r24,r18
 1938 0950 8083      		st Z,r24
 476:motorctrl.c   ****             *m->rev_TCCRA_addr = m->rev_TCCRA_value;
 1940               	.LM185:
 1941 0952 ED81      		ldd r30,Y+5
 1942 0954 FE81      		ldd r31,Y+6
 1943 0956 1082      		st Z,__zero_reg__
 477:motorctrl.c   **** 
 1945               	.LM186:
 1946 0958 EA89      		ldd r30,Y+18
 1947 095a FB89      		ldd r31,Y+19
 1948 095c 8C89      		ldd r24,Y+20
 1949 095e 8083      		st Z,r24
 479:motorctrl.c   ****             *m->rev_TCCRB_addr = m->rev_TCCRB_value;
 1951               	.LM187:
 1952 0960 E885      		ldd r30,Y+8
 1953 0962 F985      		ldd r31,Y+9
 1954 0964 1082      		st Z,__zero_reg__
 480:motorctrl.c   ****         }        
 1956               	.LM188:
 1957 0966 ED89      		ldd r30,Y+21
 1958 0968 FE89      		ldd r31,Y+22
 1959 096a 8F89      		ldd r24,Y+23
 1960 096c 8083      		st Z,r24
 1961               	.L97:
 1963               	.LM189:
 1964 096e 8E8D      		ldd r24,Y+30
 1965 0970 EA8D      		ldd r30,Y+26
 1966 0972 FB8D      		ldd r31,Y+27
 1967 0974 2081      		ld r18,Z
 1968 0976 BA01      		movw r22,r20
 1969 0978 00C0      		rjmp 2f
 1970               		1:
 1971 097a 660F      		lsl r22
 1972 097c 771F      		rol r23
 1973               		2:
 1974 097e 8A95      		dec r24
 1975 0980 02F4      		brpl 1b
 1976 0982 CB01      		movw r24,r22
 1977 0984 822B      		or r24,r18
 1978 0986 8083      		st Z,r24
 1979               	.L98:
 1980               	.LBE129:
 1981               	.LBE131:
 352:motorctrl.c   ****         }
 1983               	.LM190:
 1984 0988 29AD      		ldd r18,Y+57
 1985 098a 3AAD      		ldd r19,Y+58
 1986               	.LBB132:
 1987               	.LBB133:
 363:motorctrl.c   ****         _delay_us(47);
 1989               	.LM191:
 1990 098c 3695      		lsr r19
 1991 098e 2795      		ror r18
 1992 0990 ABE7      		ldi r26,lo8(123)
 1993 0992 B4E1      		ldi r27,lo8(20)
 1994 0994 0E94 0000 		call __umulhisi3
 1995 0998 9695      		lsr r25
 1996 099a 8795      		ror r24
 1997 099c 0097      		sbiw r24,0
 1998 099e 01F0      		breq .L101
 1999 09a0 20E0      		ldi r18,0
 2000 09a2 30E0      		ldi r19,0
 2001               	.L99:
 2002               	.LBB134:
 2003               	.LBB135:
 2005               	.Ltext7:
 2007               	.LM192:
 2008 09a4 FAEF      		ldi r31,lo8(-6)
 2009 09a6 FA95      	1:	dec r31
 2010 09a8 01F4      		brne 1b
 2011 09aa 00C0      		rjmp .
 2012               	.LBE135:
 2013               	.LBE134:
 2015               	.Ltext8:
 363:motorctrl.c   ****         _delay_us(47);
 2017               	.LM193:
 2018 09ac 2F5F      		subi r18,-1
 2019 09ae 3F4F      		sbci r19,-1
 2020 09b0 2817      		cp r18,r24
 2021 09b2 3907      		cpc r19,r25
 2022 09b4 01F4      		brne .L99
 2023               	.L101:
 2024               	.LBE133:
 2025               	.LBE132:
 350:motorctrl.c   ****             setMotor(m, m->current_dir, m->current_pwm);
 2027               	.LM194:
 2028 09b6 8BA5      		ldd r24,Y+43
 2029 09b8 8150      		subi r24,lo8(-(-1))
 2030 09ba 8BA7      		std Y+43,r24
 2031 09bc 8BA5      		ldd r24,Y+43
 2032 09be 8111      		cpse r24,__zero_reg__
 2033 09c0 00C0      		rjmp .L104
 2034               	.L100:
 355:motorctrl.c   ****         m->status = STATUS_OK;
 2036               	.LM195:
 2037 09c2 F801      		movw r30,r16
 2038 09c4 1182      		std Z+1,__zero_reg__
 2039 09c6 1082      		st Z,__zero_reg__
 356:motorctrl.c   ****         disableMotorPWM(m);       
 2041               	.LM196:
 2042 09c8 FE01      		movw r30,r28
 2043 09ca E45A      		subi r30,-92
 2044 09cc FF4F      		sbci r31,-1
 2045 09ce 1082      		st Z,__zero_reg__
 2046               	.LBB136:
 2047               	.LBB137:
 443:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 2049               	.LM197:
 2050 09d0 3E8D      		ldd r19,Y+30
 2051 09d2 EA8D      		ldd r30,Y+26
 2052 09d4 FB8D      		ldd r31,Y+27
 2053 09d6 2081      		ld r18,Z
 2054 09d8 81E0      		ldi r24,lo8(1)
 2055 09da 90E0      		ldi r25,0
 2056 09dc 00C0      		rjmp 2f
 2057               		1:
 2058 09de 880F      		lsl r24
 2059 09e0 991F      		rol r25
 2060               		2:
 2061 09e2 3A95      		dec r19
 2062 09e4 02F4      		brpl 1b
 2063 09e6 8095      		com r24
 2064 09e8 9095      		com r25
 2065 09ea 8223      		and r24,r18
 2066 09ec 8083      		st Z,r24
 444:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 2068               	.LM198:
 2069 09ee ED81      		ldd r30,Y+5
 2070 09f0 FE81      		ldd r31,Y+6
 2071 09f2 1082      		st Z,__zero_reg__
 445:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 2073               	.LM199:
 2074 09f4 E885      		ldd r30,Y+8
 2075 09f6 F985      		ldd r31,Y+9
 2076 09f8 1082      		st Z,__zero_reg__
 446:motorctrl.c   ****     
 2078               	.LM200:
 2079 09fa EB85      		ldd r30,Y+11
 2080 09fc FC85      		ldd r31,Y+12
 2081 09fe 1082      		st Z,__zero_reg__
 449:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 2083               	.LM201:
 2084 0a00 EA89      		ldd r30,Y+18
 2085 0a02 FB89      		ldd r31,Y+19
 2086 0a04 1082      		st Z,__zero_reg__
 450:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 2088               	.LM202:
 2089 0a06 ED89      		ldd r30,Y+21
 2090 0a08 FE89      		ldd r31,Y+22
 2091 0a0a 1082      		st Z,__zero_reg__
 451:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 2093               	.LM203:
 2094 0a0c E88D      		ldd r30,Y+24
 2095 0a0e F98D      		ldd r31,Y+25
 2096 0a10 1082      		st Z,__zero_reg__
 452:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 2098               	.LM204:
 2099 0a12 1BA6      		std Y+43,__zero_reg__
 453:motorctrl.c   ****     
 2101               	.LM205:
 2102 0a14 F801      		movw r30,r16
 2103 0a16 1182      		std Z+1,__zero_reg__
 2104 0a18 1082      		st Z,__zero_reg__
 2105               	.LBE137:
 2106               	.LBE136:
 2107               	.LBB138:
 2108               	.LBB139:
 2110               	.Ltext9:
 163:/usr/lib/avr/include/util/delay.h **** 
 2112               	.LM206:
 2113 0a1a FFEF      		ldi r31,lo8(159999)
 2114 0a1c 20E7      		ldi r18,hi8(159999)
 2115 0a1e 62E0      		ldi r22,hlo8(159999)
 2116 0a20 F150      	1:	subi r31,1
 2117 0a22 2040      		sbci r18,0
 2118 0a24 6040      		sbci r22,0
 2119 0a26 01F4      		brne 1b
 2120 0a28 00C0      		rjmp .
 2121 0a2a 0000      		nop
 2122               	/* epilogue start */
 2123               	.LBE139:
 2124               	.LBE138:
 2125               	.LBE124:
 2126               	.LBE123:
 2128               	.Ltext10:
 360:motorctrl.c   **** 
 2130               	.LM207:
 2131 0a2c CDB7      		in r28,__SP_L__
 2132 0a2e DEB7      		in r29,__SP_H__
 2133 0a30 E8E0      		ldi r30, lo8(8)
 2134 0a32 0C94 0000 		jmp __epilogue_restores__ + ((18 - 8) * 2)
 2135 0a36 00C0      		rjmp .L111
 2136               	.L95:
 2137               	.LBB143:
 2138               	.LBB141:
 2139               	.LBB140:
 2140               	.LBB130:
 2141               	.LBB127:
 2142               	.LBB128:
 443:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 2144               	.LM208:
 2145 0a38 8E8D      		ldd r24,Y+30
 2146 0a3a EA8D      		ldd r30,Y+26
 2147 0a3c FB8D      		ldd r31,Y+27
 2148 0a3e 2081      		ld r18,Z
 2149 0a40 BA01      		movw r22,r20
 2150 0a42 00C0      		rjmp 2f
 2151               		1:
 2152 0a44 660F      		lsl r22
 2153 0a46 771F      		rol r23
 2154               		2:
 2155 0a48 8A95      		dec r24
 2156 0a4a 02F4      		brpl 1b
 2157 0a4c CB01      		movw r24,r22
 2158 0a4e 8095      		com r24
 2159 0a50 9095      		com r25
 2160 0a52 8223      		and r24,r18
 2161 0a54 8083      		st Z,r24
 444:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 2163               	.LM209:
 2164 0a56 ED81      		ldd r30,Y+5
 2165 0a58 FE81      		ldd r31,Y+6
 2166 0a5a 1082      		st Z,__zero_reg__
 445:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 2168               	.LM210:
 2169 0a5c E885      		ldd r30,Y+8
 2170 0a5e F985      		ldd r31,Y+9
 2171 0a60 1082      		st Z,__zero_reg__
 446:motorctrl.c   ****     
 2173               	.LM211:
 2174 0a62 EB85      		ldd r30,Y+11
 2175 0a64 FC85      		ldd r31,Y+12
 2176 0a66 1082      		st Z,__zero_reg__
 449:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 2178               	.LM212:
 2179 0a68 EA89      		ldd r30,Y+18
 2180 0a6a FB89      		ldd r31,Y+19
 2181 0a6c 1082      		st Z,__zero_reg__
 450:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 2183               	.LM213:
 2184 0a6e ED89      		ldd r30,Y+21
 2185 0a70 FE89      		ldd r31,Y+22
 2186 0a72 1082      		st Z,__zero_reg__
 451:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 2188               	.LM214:
 2189 0a74 E88D      		ldd r30,Y+24
 2190 0a76 F98D      		ldd r31,Y+25
 2191 0a78 1082      		st Z,__zero_reg__
 452:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 2193               	.LM215:
 2194 0a7a 1BA6      		std Y+43,__zero_reg__
 453:motorctrl.c   ****     
 2196               	.LM216:
 2197 0a7c F801      		movw r30,r16
 2198 0a7e 1182      		std Z+1,__zero_reg__
 2199 0a80 1082      		st Z,__zero_reg__
 2200 0a82 00C0      		rjmp .L98
 2201               	.L110:
 2202               	.LBE128:
 2203               	.LBE127:
 463:motorctrl.c   ****             *m->fwd_OCR_addr = pwm; 
 2205               	.LM217:
 2206 0a84 E88D      		ldd r30,Y+24
 2207 0a86 F98D      		ldd r31,Y+25
 2208 0a88 1082      		st Z,__zero_reg__
 464:motorctrl.c   ****             *m->rev_port_addr &= ~(1<<m->rev_pin);
 2210               	.LM218:
 2211 0a8a EB85      		ldd r30,Y+11
 2212 0a8c FC85      		ldd r31,Y+12
 2213 0a8e 8083      		st Z,r24
 465:motorctrl.c   ****             *m->rev_TCCRA_addr = 0x00; //Disable reverse
 2215               	.LM219:
 2216 0a90 8989      		ldd r24,Y+17
 2217 0a92 ED85      		ldd r30,Y+13
 2218 0a94 FE85      		ldd r31,Y+14
 2219 0a96 2081      		ld r18,Z
 2220 0a98 BA01      		movw r22,r20
 2221 0a9a 00C0      		rjmp 2f
 2222               		1:
 2223 0a9c 660F      		lsl r22
 2224 0a9e 771F      		rol r23
 2225               		2:
 2226 0aa0 8A95      		dec r24
 2227 0aa2 02F4      		brpl 1b
 2228 0aa4 CB01      		movw r24,r22
 2229 0aa6 8095      		com r24
 2230 0aa8 9095      		com r25
 2231 0aaa 8223      		and r24,r18
 2232 0aac 8083      		st Z,r24
 466:motorctrl.c   ****             *m->fwd_TCCRA_addr = m->fwd_TCCRA_value; //Activate PWM forward
 2234               	.LM220:
 2235 0aae EA89      		ldd r30,Y+18
 2236 0ab0 FB89      		ldd r31,Y+19
 2237 0ab2 1082      		st Z,__zero_reg__
 467:motorctrl.c   ****             
 2239               	.LM221:
 2240 0ab4 ED81      		ldd r30,Y+5
 2241 0ab6 FE81      		ldd r31,Y+6
 2242 0ab8 8F81      		ldd r24,Y+7
 2243 0aba 8083      		st Z,r24
 469:motorctrl.c   ****             *m->fwd_TCCRB_addr = m->fwd_TCCRB_value;
 2245               	.LM222:
 2246 0abc ED89      		ldd r30,Y+21
 2247 0abe FE89      		ldd r31,Y+22
 2248 0ac0 1082      		st Z,__zero_reg__
 470:motorctrl.c   ****         }
 2250               	.LM223:
 2251 0ac2 E885      		ldd r30,Y+8
 2252 0ac4 F985      		ldd r31,Y+9
 2253 0ac6 8A85      		ldd r24,Y+10
 2254 0ac8 8083      		st Z,r24
 2255 0aca 00C0      		rjmp .L97
 2256               	.L108:
 2257               	.LBE130:
 2258               	.LBE140:
 2259               	.LBE141:
 2260               	.LBE143:
 329:motorctrl.c   ****         fprintf(port, "timeout\n");
 2262               	.LM224:
 2263 0acc 3496      		adiw r30,4
 2264 0ace 83E0      		ldi r24,lo8(3)
 2265 0ad0 8083      		st Z,r24
 330:motorctrl.c   ****         motorControl(m, m->current_dir, 0); //Shutdown motor if it has been running too long.
 2267               	.LM225:
 2268 0ad2 2091 0000 		lds r18,port
 2269 0ad6 3091 0000 		lds r19,port+1
 2270 0ada 48E0      		ldi r20,lo8(8)
 2271 0adc 50E0      		ldi r21,0
 2272 0ade 61E0      		ldi r22,lo8(1)
 2273 0ae0 70E0      		ldi r23,0
 2274 0ae2 80E0      		ldi r24,lo8(.LC0)
 2275 0ae4 90E0      		ldi r25,hi8(.LC0)
 2276 0ae6 0E94 0000 		call fwrite
 331:motorctrl.c   ****         _delay_ms(100);
 2278               	.LM226:
 2279 0aea 6CA5      		ldd r22,Y+44
 2280 0aec 40E0      		ldi r20,0
 2281 0aee CE01      		movw r24,r28
 2282 0af0 0E94 0000 		call motorControl
 2283               	.LBB144:
 2284               	.LBB145:
 2286               	.Ltext11:
 163:/usr/lib/avr/include/util/delay.h **** 
 2288               	.LM227:
 2289 0af4 FFEF      		ldi r31,lo8(319999)
 2290 0af6 21EE      		ldi r18,hi8(319999)
 2291 0af8 64E0      		ldi r22,hlo8(319999)
 2292 0afa F150      	1:	subi r31,1
 2293 0afc 2040      		sbci r18,0
 2294 0afe 6040      		sbci r22,0
 2295 0b00 01F4      		brne 1b
 2296 0b02 00C0      		rjmp .
 2297 0b04 0000      		nop
 2298               	/* epilogue start */
 2299               	.LBE145:
 2300               	.LBE144:
 2302               	.Ltext12:
 360:motorctrl.c   **** 
 2304               	.LM228:
 2305 0b06 CDB7      		in r28,__SP_L__
 2306 0b08 DEB7      		in r29,__SP_H__
 2307 0b0a E8E0      		ldi r30, lo8(8)
 2308 0b0c 0C94 0000 		jmp __epilogue_restores__ + ((18 - 8) * 2)
 2309 0b10 00C0      		rjmp .L111
 2310               	.L109:
 338:motorctrl.c   ****         m->timeout_value ++; //update timeout variables
 2312               	.LM229:
 2313 0b12 4FAD      		ldd r20,Y+63
 2314 0b14 61E0      		ldi r22,lo8(1)
 2315 0b16 CE01      		movw r24,r28
 2316 0b18 0E94 0000 		call motorControl
 339:motorctrl.c   ****         m->status = RUNNING_FORWARD;
 2318               	.LM230:
 2319 0b1c F801      		movw r30,r16
 2320 0b1e 8081      		ld r24,Z
 2321 0b20 9181      		ldd r25,Z+1
 2322 0b22 0196      		adiw r24,1
 2323 0b24 9183      		std Z+1,r25
 2324 0b26 8083      		st Z,r24
 340:motorctrl.c   ****       //  fprintf(port, "fw\n");
 2326               	.LM231:
 2327 0b28 C45A      		subi r28,-92
 2328 0b2a DF4F      		sbci r29,-1
 2329 0b2c 81E0      		ldi r24,lo8(1)
 2330 0b2e 8883      		st Y,r24
 2331               	/* epilogue start */
 360:motorctrl.c   **** 
 2333               	.LM232:
 2334 0b30 CDB7      		in r28,__SP_L__
 2335 0b32 DEB7      		in r29,__SP_H__
 2336 0b34 E8E0      		ldi r30, lo8(8)
 2337 0b36 0C94 0000 		jmp __epilogue_restores__ + ((18 - 8) * 2)
 2338 0b3a 00C0      		rjmp .L111
 2339               	.L93:
 2340               	.LBB146:
 2341               	.LBB142:
 344:motorctrl.c   ****         m->timeout_value ++;
 2343               	.LM233:
 2344 0b3c 4FAD      		ldd r20,Y+63
 2345 0b3e 60E0      		ldi r22,0
 2346 0b40 CE01      		movw r24,r28
 2347 0b42 0E94 0000 		call motorControl
 345:motorctrl.c   ****         m->status = RUNNING_BACKWARD;
 2349               	.LM234:
 2350 0b46 F801      		movw r30,r16
 2351 0b48 8081      		ld r24,Z
 2352 0b4a 9181      		ldd r25,Z+1
 2353 0b4c 0196      		adiw r24,1
 2354 0b4e 9183      		std Z+1,r25
 2355 0b50 8083      		st Z,r24
 346:motorctrl.c   ****        // fprintf(port, "rev\n");
 2357               	.LM235:
 2358 0b52 C45A      		subi r28,-92
 2359 0b54 DF4F      		sbci r29,-1
 2360 0b56 82E0      		ldi r24,lo8(2)
 2361 0b58 8883      		st Y,r24
 2362               	/* epilogue start */
 2363               	.LBE142:
 2364               	.LBE146:
 360:motorctrl.c   **** 
 2366               	.LM236:
 2367 0b5a CDB7      		in r28,__SP_L__
 2368 0b5c DEB7      		in r29,__SP_H__
 2369 0b5e E8E0      		ldi r30, lo8(8)
 2370 0b60 0C94 0000 		jmp __epilogue_restores__ + ((18 - 8) * 2)
 2371               	.L111:
 2376               	.Lscope17:
 2378               	.global	getTiltActuatorCurrentLength
 2380               	getTiltActuatorCurrentLength:
 208:motorctrl.c   ****     return getActuatorLength(&motors[TILT_MOTOR]);
 2382               	.LM237:
 2383               	.LFBB18:
 2384 0b64 A0E0      		ldi r26,0
 2385 0b66 B0E0      		ldi r27,0
 2386 0b68 E0E0      		ldi r30,lo8(gs(1f))
 2387 0b6a F0E0      		ldi r31,hi8(gs(1f))
 2388 0b6c 0C94 0000 		jmp __prologue_saves__+((18 - 16) * 2)
 2389               	1:
 2390               	/* prologue: function */
 2391               	/* frame size = 0 */
 2392               	/* stack size = 16 */
 2393               	.L__stack_usage = 16
 2394               	.LBB151:
 2395               	.LBB152:
 188:motorctrl.c   ****     //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
 2397               	.LM238:
 2398 0b70 8091 0000 		lds r24,motors+132
 2399 0b74 44E0      		ldi r20,lo8(4)
 2400 0b76 60E4      		ldi r22,lo8(64)
 2401 0b78 0E94 0000 		call AVGVoltage
 2402 0b7c 6C01      		movw r12,r24
 2403 0b7e E12C      		mov r14,__zero_reg__
 2404 0b80 F12C      		mov r15,__zero_reg__
 190:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 2406               	.LM239:
 2407 0b82 C091 0000 		lds r28,motors+196
 2408 0b86 D091 0000 		lds r29,motors+196+1
 192:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 2410               	.LM240:
 2411 0b8a 6091 0000 		lds r22,motors+177
 2412 0b8e 7091 0000 		lds r23,motors+177+1
 2413 0b92 4090 0000 		lds r4,motors+181
 2414 0b96 5090 0000 		lds r5,motors+181+1
 2415 0b9a 6090 0000 		lds r6,motors+181+2
 2416 0b9e 7090 0000 		lds r7,motors+181+3
 2417 0ba2 0091 0000 		lds r16,motors+200
 2418 0ba6 1091 0000 		lds r17,motors+200+1
 2419 0baa 80E0      		ldi r24,0
 2420 0bac 90E0      		ldi r25,0
 2421 0bae 0E94 0000 		call __floatunsisf
 2422 0bb2 4B01      		movw r8,r22
 2423 0bb4 5C01      		movw r10,r24
 2424 0bb6 B801      		movw r22,r16
 2425 0bb8 80E0      		ldi r24,0
 2426 0bba 90E0      		ldi r25,0
 2427 0bbc 0E94 0000 		call __floatunsisf
 2428 0bc0 9B01      		movw r18,r22
 2429 0bc2 AC01      		movw r20,r24
 2430 0bc4 C301      		movw r24,r6
 2431 0bc6 B201      		movw r22,r4
 2432 0bc8 0E94 0000 		call __divsf3
 2433 0bcc 2B01      		movw r4,r22
 2434 0bce 3C01      		movw r6,r24
 190:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 2436               	.LM241:
 2437 0bd0 C701      		movw r24,r14
 2438 0bd2 B601      		movw r22,r12
 2439 0bd4 6C1B      		sub r22,r28
 2440 0bd6 7D0B      		sbc r23,r29
 2441 0bd8 8109      		sbc r24,__zero_reg__
 2442 0bda 9109      		sbc r25,__zero_reg__
 192:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 2444               	.LM242:
 2445 0bdc 0E94 0000 		call __floatunsisf
 2446 0be0 9B01      		movw r18,r22
 2447 0be2 AC01      		movw r20,r24
 2448 0be4 C301      		movw r24,r6
 2449 0be6 B201      		movw r22,r4
 2450 0be8 0E94 0000 		call __mulsf3
 2451 0bec 9B01      		movw r18,r22
 2452 0bee AC01      		movw r20,r24
 2453 0bf0 C501      		movw r24,r10
 2454 0bf2 B401      		movw r22,r8
 2455 0bf4 0E94 0000 		call __addsf3
 2456 0bf8 0E94 0000 		call __fixunssfsi
 2457 0bfc 6B01      		movw r12,r22
 2458 0bfe 7C01      		movw r14,r24
 197:motorctrl.c   ****         m->status = MAX_LIMIT;
 2460               	.LM243:
 2461 0c00 2091 0000 		lds r18,motors+187
 2462 0c04 3091 0000 		lds r19,motors+187+1
 2463 0c08 6217      		cp r22,r18
 2464 0c0a 7307      		cpc r23,r19
 2465 0c0c 00F4      		brsh .L116
 201:motorctrl.c   ****         m->status = MIN_LIMIT;
 2467               	.LM244:
 2468 0c0e 2091 0000 		lds r18,motors+185
 2469 0c12 3091 0000 		lds r19,motors+185+1
 2470 0c16 2617      		cp r18,r22
 2471 0c18 3707      		cpc r19,r23
 2472 0c1a 00F4      		brsh .L117
 2473               	.LBE152:
 2474               	.LBE151:
 210:motorctrl.c   **** 
 2476               	.LM245:
 2477 0c1c C601      		movw r24,r12
 2478               	/* epilogue start */
 2479 0c1e CDB7      		in r28,__SP_L__
 2480 0c20 DEB7      		in r29,__SP_H__
 2481 0c22 E0E1      		ldi r30, lo8(16)
 2482 0c24 0C94 0000 		jmp __epilogue_restores__ + ((18 - 16) * 2)
 2483 0c28 00C0      		rjmp .L118
 2484               	.L117:
 2485               	.LBB157:
 2486               	.LBB155:
 202:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
 2488               	.LM246:
 2489 0c2a 84E0      		ldi r24,lo8(4)
 2490               	.L115:
 2491 0c2c 8093 0000 		sts motors+193,r24
 203:motorctrl.c   ****     }
 2493               	.LM247:
 2494 0c30 6091 0000 		lds r22,motors+145
 2495 0c34 40E0      		ldi r20,0
 2496 0c36 80E0      		ldi r24,lo8(motors+101)
 2497 0c38 90E0      		ldi r25,hi8(motors+101)
 2498 0c3a 0E94 0000 		call motorControl
 2499               	.LBE155:
 2500               	.LBE157:
 210:motorctrl.c   **** 
 2502               	.LM248:
 2503 0c3e C601      		movw r24,r12
 2504               	/* epilogue start */
 2505 0c40 CDB7      		in r28,__SP_L__
 2506 0c42 DEB7      		in r29,__SP_H__
 2507 0c44 E0E1      		ldi r30, lo8(16)
 2508 0c46 0C94 0000 		jmp __epilogue_restores__ + ((18 - 16) * 2)
 2509 0c4a 00C0      		rjmp .L118
 2510               	.L116:
 2511               	.LBB158:
 2512               	.LBB156:
 2513               	.LBB153:
 2514               	.LBB154:
 198:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 2516               	.LM249:
 2517 0c4c 85E0      		ldi r24,lo8(5)
 2518 0c4e 00C0      		rjmp .L115
 2519               	.L118:
 2520               	.LBE154:
 2521               	.LBE153:
 2522               	.LBE156:
 2523               	.LBE158:
 2534               	.Lscope18:
 2536               	.global	getAngleActuatorCurrentLength
 2538               	getAngleActuatorCurrentLength:
 212:motorctrl.c   ****     return getActuatorLength(&motors[ANGLE_MOTOR]);
 2540               	.LM250:
 2541               	.LFBB19:
 2542 0c50 A0E0      		ldi r26,0
 2543 0c52 B0E0      		ldi r27,0
 2544 0c54 E0E0      		ldi r30,lo8(gs(1f))
 2545 0c56 F0E0      		ldi r31,hi8(gs(1f))
 2546 0c58 0C94 0000 		jmp __prologue_saves__+((18 - 16) * 2)
 2547               	1:
 2548               	/* prologue: function */
 2549               	/* frame size = 0 */
 2550               	/* stack size = 16 */
 2551               	.L__stack_usage = 16
 2552               	.LBB163:
 2553               	.LBB164:
 188:motorctrl.c   ****     //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
 2555               	.LM251:
 2556 0c5c 8091 0000 		lds r24,motors+31
 2557 0c60 44E0      		ldi r20,lo8(4)
 2558 0c62 60E4      		ldi r22,lo8(64)
 2559 0c64 0E94 0000 		call AVGVoltage
 2560 0c68 6C01      		movw r12,r24
 2561 0c6a E12C      		mov r14,__zero_reg__
 2562 0c6c F12C      		mov r15,__zero_reg__
 190:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 2564               	.LM252:
 2565 0c6e C091 0000 		lds r28,motors+95
 2566 0c72 D091 0000 		lds r29,motors+95+1
 192:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 2568               	.LM253:
 2569 0c76 6091 0000 		lds r22,motors+76
 2570 0c7a 7091 0000 		lds r23,motors+76+1
 2571 0c7e 4090 0000 		lds r4,motors+80
 2572 0c82 5090 0000 		lds r5,motors+80+1
 2573 0c86 6090 0000 		lds r6,motors+80+2
 2574 0c8a 7090 0000 		lds r7,motors+80+3
 2575 0c8e 0091 0000 		lds r16,motors+99
 2576 0c92 1091 0000 		lds r17,motors+99+1
 2577 0c96 80E0      		ldi r24,0
 2578 0c98 90E0      		ldi r25,0
 2579 0c9a 0E94 0000 		call __floatunsisf
 2580 0c9e 4B01      		movw r8,r22
 2581 0ca0 5C01      		movw r10,r24
 2582 0ca2 B801      		movw r22,r16
 2583 0ca4 80E0      		ldi r24,0
 2584 0ca6 90E0      		ldi r25,0
 2585 0ca8 0E94 0000 		call __floatunsisf
 2586 0cac 9B01      		movw r18,r22
 2587 0cae AC01      		movw r20,r24
 2588 0cb0 C301      		movw r24,r6
 2589 0cb2 B201      		movw r22,r4
 2590 0cb4 0E94 0000 		call __divsf3
 2591 0cb8 2B01      		movw r4,r22
 2592 0cba 3C01      		movw r6,r24
 190:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 2594               	.LM254:
 2595 0cbc C701      		movw r24,r14
 2596 0cbe B601      		movw r22,r12
 2597 0cc0 6C1B      		sub r22,r28
 2598 0cc2 7D0B      		sbc r23,r29
 2599 0cc4 8109      		sbc r24,__zero_reg__
 2600 0cc6 9109      		sbc r25,__zero_reg__
 192:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 2602               	.LM255:
 2603 0cc8 0E94 0000 		call __floatunsisf
 2604 0ccc 9B01      		movw r18,r22
 2605 0cce AC01      		movw r20,r24
 2606 0cd0 C301      		movw r24,r6
 2607 0cd2 B201      		movw r22,r4
 2608 0cd4 0E94 0000 		call __mulsf3
 2609 0cd8 9B01      		movw r18,r22
 2610 0cda AC01      		movw r20,r24
 2611 0cdc C501      		movw r24,r10
 2612 0cde B401      		movw r22,r8
 2613 0ce0 0E94 0000 		call __addsf3
 2614 0ce4 0E94 0000 		call __fixunssfsi
 2615 0ce8 6B01      		movw r12,r22
 2616 0cea 7C01      		movw r14,r24
 197:motorctrl.c   ****         m->status = MAX_LIMIT;
 2618               	.LM256:
 2619 0cec 2091 0000 		lds r18,motors+86
 2620 0cf0 3091 0000 		lds r19,motors+86+1
 2621 0cf4 6217      		cp r22,r18
 2622 0cf6 7307      		cpc r23,r19
 2623 0cf8 00F4      		brsh .L123
 201:motorctrl.c   ****         m->status = MIN_LIMIT;
 2625               	.LM257:
 2626 0cfa 2091 0000 		lds r18,motors+84
 2627 0cfe 3091 0000 		lds r19,motors+84+1
 2628 0d02 2617      		cp r18,r22
 2629 0d04 3707      		cpc r19,r23
 2630 0d06 00F4      		brsh .L124
 2631               	.LBE164:
 2632               	.LBE163:
 214:motorctrl.c   **** 
 2634               	.LM258:
 2635 0d08 C601      		movw r24,r12
 2636               	/* epilogue start */
 2637 0d0a CDB7      		in r28,__SP_L__
 2638 0d0c DEB7      		in r29,__SP_H__
 2639 0d0e E0E1      		ldi r30, lo8(16)
 2640 0d10 0C94 0000 		jmp __epilogue_restores__ + ((18 - 16) * 2)
 2641 0d14 00C0      		rjmp .L125
 2642               	.L124:
 2643               	.LBB169:
 2644               	.LBB167:
 202:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
 2646               	.LM259:
 2647 0d16 84E0      		ldi r24,lo8(4)
 2648               	.L122:
 2649 0d18 8093 0000 		sts motors+92,r24
 203:motorctrl.c   ****     }
 2651               	.LM260:
 2652 0d1c 6091 0000 		lds r22,motors+44
 2653 0d20 40E0      		ldi r20,0
 2654 0d22 80E0      		ldi r24,lo8(motors)
 2655 0d24 90E0      		ldi r25,hi8(motors)
 2656 0d26 0E94 0000 		call motorControl
 2657               	.LBE167:
 2658               	.LBE169:
 214:motorctrl.c   **** 
 2660               	.LM261:
 2661 0d2a C601      		movw r24,r12
 2662               	/* epilogue start */
 2663 0d2c CDB7      		in r28,__SP_L__
 2664 0d2e DEB7      		in r29,__SP_H__
 2665 0d30 E0E1      		ldi r30, lo8(16)
 2666 0d32 0C94 0000 		jmp __epilogue_restores__ + ((18 - 16) * 2)
 2667 0d36 00C0      		rjmp .L125
 2668               	.L123:
 2669               	.LBB170:
 2670               	.LBB168:
 2671               	.LBB165:
 2672               	.LBB166:
 198:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 2674               	.LM262:
 2675 0d38 85E0      		ldi r24,lo8(5)
 2676 0d3a 00C0      		rjmp .L122
 2677               	.L125:
 2678               	.LBE166:
 2679               	.LBE165:
 2680               	.LBE168:
 2681               	.LBE170:
 2692               	.Lscope19:
 2695               	.global	getMotorPosition
 2697               	getMotorPosition:
 171:motorctrl.c   ****     uint16_t alen = getActuatorLength(m);
 2699               	.LM263:
 2700               	.LFBB20:
 2701 0d3c A0E0      		ldi r26,0
 2702 0d3e B0E0      		ldi r27,0
 2703 0d40 E0E0      		ldi r30,lo8(gs(1f))
 2704 0d42 F0E0      		ldi r31,hi8(gs(1f))
 2705 0d44 0C94 0000 		jmp __prologue_saves__+((18 - 18) * 2)
 2706               	1:
 2707               	/* prologue: function */
 2708               	/* frame size = 0 */
 2709               	/* stack size = 18 */
 2710               	.L__stack_usage = 18
 2711 0d48 EC01      		movw r28,r24
 2712               	.LBB175:
 2713               	.LBB176:
 188:motorctrl.c   ****     //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
 2715               	.LM264:
 2716 0d4a 8F8D      		ldd r24,Y+31
 2717 0d4c 44E0      		ldi r20,lo8(4)
 2718 0d4e 60E4      		ldi r22,lo8(64)
 2719 0d50 0E94 0000 		call AVGVoltage
 2720 0d54 6C01      		movw r12,r24
 2721 0d56 E12C      		mov r14,__zero_reg__
 2722 0d58 F12C      		mov r15,__zero_reg__
 190:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 2724               	.LM265:
 2725 0d5a FE01      		movw r30,r28
 2726 0d5c E15A      		subi r30,-95
 2727 0d5e FF4F      		sbci r31,-1
 2728 0d60 2080      		ld r2,Z
 2729 0d62 3180      		ldd r3,Z+1
 192:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 2731               	.LM266:
 2732 0d64 7397      		sbiw r30,19
 2733 0d66 6081      		ld r22,Z
 2734 0d68 7181      		ldd r23,Z+1
 2735 0d6a 3496      		adiw r30,4
 2736 0d6c 4080      		ld r4,Z
 2737 0d6e 5180      		ldd r5,Z+1
 2738 0d70 6280      		ldd r6,Z+2
 2739 0d72 7380      		ldd r7,Z+3
 2740 0d74 7396      		adiw r30,19
 2741 0d76 0081      		ld r16,Z
 2742 0d78 1181      		ldd r17,Z+1
 2743 0d7a 80E0      		ldi r24,0
 2744 0d7c 90E0      		ldi r25,0
 2745 0d7e 0E94 0000 		call __floatunsisf
 2746 0d82 4B01      		movw r8,r22
 2747 0d84 5C01      		movw r10,r24
 2748 0d86 B801      		movw r22,r16
 2749 0d88 80E0      		ldi r24,0
 2750 0d8a 90E0      		ldi r25,0
 2751 0d8c 0E94 0000 		call __floatunsisf
 2752 0d90 9B01      		movw r18,r22
 2753 0d92 AC01      		movw r20,r24
 2754 0d94 C301      		movw r24,r6
 2755 0d96 B201      		movw r22,r4
 2756 0d98 0E94 0000 		call __divsf3
 2757 0d9c 2B01      		movw r4,r22
 2758 0d9e 3C01      		movw r6,r24
 190:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 2760               	.LM267:
 2761 0da0 C701      		movw r24,r14
 2762 0da2 B601      		movw r22,r12
 2763 0da4 6219      		sub r22,r2
 2764 0da6 7309      		sbc r23,r3
 2765 0da8 8109      		sbc r24,__zero_reg__
 2766 0daa 9109      		sbc r25,__zero_reg__
 192:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 2768               	.LM268:
 2769 0dac 0E94 0000 		call __floatunsisf
 2770 0db0 9B01      		movw r18,r22
 2771 0db2 AC01      		movw r20,r24
 2772 0db4 C301      		movw r24,r6
 2773 0db6 B201      		movw r22,r4
 2774 0db8 0E94 0000 		call __mulsf3
 2775 0dbc 9B01      		movw r18,r22
 2776 0dbe AC01      		movw r20,r24
 2777 0dc0 C501      		movw r24,r10
 2778 0dc2 B401      		movw r22,r8
 2779 0dc4 0E94 0000 		call __addsf3
 2780 0dc8 0E94 0000 		call __fixunssfsi
 2781 0dcc 6B01      		movw r12,r22
 2782 0dce 7C01      		movw r14,r24
 197:motorctrl.c   ****         m->status = MAX_LIMIT;
 2784               	.LM269:
 2785 0dd0 FE01      		movw r30,r28
 2786 0dd2 EA5A      		subi r30,-86
 2787 0dd4 FF4F      		sbci r31,-1
 2788 0dd6 2081      		ld r18,Z
 2789 0dd8 3181      		ldd r19,Z+1
 2790 0dda 6217      		cp r22,r18
 2791 0ddc 7307      		cpc r23,r19
 2792 0dde 00F4      		brsh .L130
 201:motorctrl.c   ****         m->status = MIN_LIMIT;
 2794               	.LM270:
 2795 0de0 FE01      		movw r30,r28
 2796 0de2 EC5A      		subi r30,-84
 2797 0de4 FF4F      		sbci r31,-1
 2798 0de6 2081      		ld r18,Z
 2799 0de8 3181      		ldd r19,Z+1
 2800 0dea 2617      		cp r18,r22
 2801 0dec 3707      		cpc r19,r23
 2802 0dee 00F4      		brsh .L131
 2803               	.L128:
 2804               	.LBE176:
 2805               	.LBE175:
 173:motorctrl.c   ****     return m->angle_reference + aoffset;
 2807               	.LM271:
 2808 0df0 FE01      		movw r30,r28
 2809 0df2 E35A      		subi r30,-93
 2810 0df4 FF4F      		sbci r31,-1
 2811 0df6 0190      		ld __tmp_reg__,Z+
 2812 0df8 F081      		ld r31,Z
 2813 0dfa E02D      		mov r30,__tmp_reg__
 2814 0dfc C601      		movw r24,r12
 2815 0dfe 0995      		icall
 2816 0e00 9B01      		movw r18,r22
 2817 0e02 AC01      		movw r20,r24
 174:motorctrl.c   ****     /*
 2819               	.LM272:
 2820 0e04 C85B      		subi r28,-72
 2821 0e06 DF4F      		sbci r29,-1
 2822 0e08 6881      		ld r22,Y
 2823 0e0a 7981      		ldd r23,Y+1
 2824 0e0c 8A81      		ldd r24,Y+2
 2825 0e0e 9B81      		ldd r25,Y+3
 2826 0e10 0E94 0000 		call __addsf3
 2827               	/* epilogue start */
 184:motorctrl.c   **** 
 2829               	.LM273:
 2830 0e14 CDB7      		in r28,__SP_L__
 2831 0e16 DEB7      		in r29,__SP_H__
 2832 0e18 E2E1      		ldi r30, lo8(18)
 2833 0e1a 0C94 0000 		jmp __epilogue_restores__ + ((18 - 18) * 2)
 2834               	.L131:
 2835               	.LBB180:
 2836               	.LBB179:
 202:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
 2838               	.LM274:
 2839 0e1e 84E0      		ldi r24,lo8(4)
 2840 0e20 3896      		adiw r30,8
 2841               	.L129:
 2842 0e22 8083      		st Z,r24
 203:motorctrl.c   ****     }
 2844               	.LM275:
 2845 0e24 6CA5      		ldd r22,Y+44
 2846 0e26 40E0      		ldi r20,0
 2847 0e28 CE01      		movw r24,r28
 2848 0e2a 0E94 0000 		call motorControl
 2849 0e2e 00C0      		rjmp .L128
 2850               	.L130:
 2851               	.LBB177:
 2852               	.LBB178:
 198:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 2854               	.LM276:
 2855 0e30 85E0      		ldi r24,lo8(5)
 2856 0e32 3696      		adiw r30,6
 2857 0e34 00C0      		rjmp .L129
 2858               	.LBE178:
 2859               	.LBE177:
 2860               	.LBE179:
 2861               	.LBE180:
 2867               	.Lscope20:
 2869               	.global	motorController
 2871               	motorController:
 313:motorctrl.c   ****     //Update current motor positions
 2873               	.LM277:
 2874               	.LFBB21:
 2875 0e36 A7E0      		ldi r26,lo8(7)
 2876 0e38 B0E0      		ldi r27,0
 2877 0e3a E0E0      		ldi r30,lo8(gs(1f))
 2878 0e3c F0E0      		ldi r31,hi8(gs(1f))
 2879 0e3e 0C94 0000 		jmp __prologue_saves__+((18 - 18) * 2)
 2880               	1:
 2881               	/* prologue: function */
 2882               	/* frame size = 7 */
 2883               	/* stack size = 25 */
 2884               	.L__stack_usage = 25
 2885 0e42 00E0      		ldi r16,lo8(motors)
 2886 0e44 10E0      		ldi r17,hi8(motors)
 2887               	.LBB189:
 2888 0e46 212C      		mov r2,__zero_reg__
 2889 0e48 312C      		mov r3,__zero_reg__
 2890               	.LBE189:
 315:motorctrl.c   ****     for (uint8_t i = 0; i < NUM_OF_MOTORS; i++){
 2892               	.LM278:
 2893 0e4a 1982      		std Y+1,__zero_reg__
 2894               	.L135:
 2895               	.LBB204:
 2896               	.LBB190:
 2897               	.LBB191:
 2898               	.LBB192:
 2899               	.LBB193:
 2900               	.LBB194:
 188:motorctrl.c   ****     //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
 2902               	.LM279:
 2903 0e4c 85E6      		ldi r24,lo8(101)
 2904 0e4e 829D      		mul r24,r2
 2905 0e50 9001      		movw r18,r0
 2906 0e52 839D      		mul r24,r3
 2907 0e54 300D      		add r19,r0
 2908 0e56 1124      		clr __zero_reg__
 2909 0e58 F901      		movw r30,r18
 2910 0e5a E050      		subi r30,lo8(-(motors))
 2911 0e5c F040      		sbci r31,hi8(-(motors))
 2912 0e5e FF83      		std Y+7,r31
 2913 0e60 EE83      		std Y+6,r30
 2914 0e62 878D      		ldd r24,Z+31
 2915 0e64 44E0      		ldi r20,lo8(4)
 2916 0e66 60E4      		ldi r22,lo8(64)
 2917 0e68 0E94 0000 		call AVGVoltage
 2918 0e6c 2C01      		movw r4,r24
 2919 0e6e 612C      		mov r6,__zero_reg__
 2920 0e70 712C      		mov r7,__zero_reg__
 190:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 2922               	.LM280:
 2923 0e72 EE81      		ldd r30,Y+6
 2924 0e74 FF81      		ldd r31,Y+7
 2925 0e76 E15A      		subi r30,-95
 2926 0e78 FF4F      		sbci r31,-1
 2927 0e7a 2081      		ld r18,Z
 2928 0e7c 3181      		ldd r19,Z+1
 2929 0e7e 3B83      		std Y+3,r19
 2930 0e80 2A83      		std Y+2,r18
 192:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 2932               	.LM281:
 2933 0e82 EE81      		ldd r30,Y+6
 2934 0e84 FF81      		ldd r31,Y+7
 2935 0e86 E45B      		subi r30,-76
 2936 0e88 FF4F      		sbci r31,-1
 2937 0e8a 6081      		ld r22,Z
 2938 0e8c 7181      		ldd r23,Z+1
 2939 0e8e EE81      		ldd r30,Y+6
 2940 0e90 FF81      		ldd r31,Y+7
 2941 0e92 E05B      		subi r30,-80
 2942 0e94 FF4F      		sbci r31,-1
 2943 0e96 8080      		ld r8,Z
 2944 0e98 9180      		ldd r9,Z+1
 2945 0e9a A280      		ldd r10,Z+2
 2946 0e9c B380      		ldd r11,Z+3
 2947 0e9e EE81      		ldd r30,Y+6
 2948 0ea0 FF81      		ldd r31,Y+7
 2949 0ea2 ED59      		subi r30,-99
 2950 0ea4 FF4F      		sbci r31,-1
 2951 0ea6 2081      		ld r18,Z
 2952 0ea8 3181      		ldd r19,Z+1
 2953 0eaa 80E0      		ldi r24,0
 2954 0eac 90E0      		ldi r25,0
 2955 0eae 2C83      		std Y+4,r18
 2956 0eb0 3D83      		std Y+5,r19
 2957 0eb2 0E94 0000 		call __floatunsisf
 2958 0eb6 6B01      		movw r12,r22
 2959 0eb8 7C01      		movw r14,r24
 2960 0eba 2C81      		ldd r18,Y+4
 2961 0ebc 3D81      		ldd r19,Y+5
 2962 0ebe B901      		movw r22,r18
 2963 0ec0 80E0      		ldi r24,0
 2964 0ec2 90E0      		ldi r25,0
 2965 0ec4 0E94 0000 		call __floatunsisf
 2966 0ec8 9B01      		movw r18,r22
 2967 0eca AC01      		movw r20,r24
 2968 0ecc C501      		movw r24,r10
 2969 0ece B401      		movw r22,r8
 2970 0ed0 0E94 0000 		call __divsf3
 2971 0ed4 4B01      		movw r8,r22
 2972 0ed6 5C01      		movw r10,r24
 190:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 2974               	.LM282:
 2975 0ed8 C301      		movw r24,r6
 2976 0eda B201      		movw r22,r4
 2977 0edc EA81      		ldd r30,Y+2
 2978 0ede FB81      		ldd r31,Y+3
 2979 0ee0 6E1B      		sub r22,r30
 2980 0ee2 7F0B      		sbc r23,r31
 2981 0ee4 8109      		sbc r24,__zero_reg__
 2982 0ee6 9109      		sbc r25,__zero_reg__
 192:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 2984               	.LM283:
 2985 0ee8 0E94 0000 		call __floatunsisf
 2986 0eec 9B01      		movw r18,r22
 2987 0eee AC01      		movw r20,r24
 2988 0ef0 C501      		movw r24,r10
 2989 0ef2 B401      		movw r22,r8
 2990 0ef4 0E94 0000 		call __mulsf3
 2991 0ef8 9B01      		movw r18,r22
 2992 0efa AC01      		movw r20,r24
 2993 0efc C701      		movw r24,r14
 2994 0efe B601      		movw r22,r12
 2995 0f00 0E94 0000 		call __addsf3
 2996 0f04 0E94 0000 		call __fixunssfsi
 2997 0f08 6B01      		movw r12,r22
 2998 0f0a 7C01      		movw r14,r24
 197:motorctrl.c   ****         m->status = MAX_LIMIT;
 3000               	.LM284:
 3001 0f0c EE81      		ldd r30,Y+6
 3002 0f0e FF81      		ldd r31,Y+7
 3003 0f10 EA5A      		subi r30,-86
 3004 0f12 FF4F      		sbci r31,-1
 3005 0f14 2081      		ld r18,Z
 3006 0f16 3181      		ldd r19,Z+1
 3007               	.LBB195:
 3008               	.LBB196:
 198:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 3010               	.LM285:
 3011 0f18 EE81      		ldd r30,Y+6
 3012 0f1a FF81      		ldd r31,Y+7
 3013               	.LBE196:
 3014               	.LBE195:
 197:motorctrl.c   ****         m->status = MAX_LIMIT;
 3016               	.LM286:
 3017 0f1c 6217      		cp r22,r18
 3018 0f1e 7307      		cpc r23,r19
 3019 0f20 00F0      		brlo .+2
 3020 0f22 00C0      		rjmp .L138
 201:motorctrl.c   ****         m->status = MIN_LIMIT;
 3022               	.LM287:
 3023 0f24 EC5A      		subi r30,-84
 3024 0f26 FF4F      		sbci r31,-1
 3025 0f28 2081      		ld r18,Z
 3026 0f2a 3181      		ldd r19,Z+1
 3027 0f2c 2617      		cp r18,r22
 3028 0f2e 3707      		cpc r19,r23
 3029 0f30 00F4      		brsh .L139
 3030               	.L134:
 3031               	.LBE194:
 3032               	.LBE193:
 173:motorctrl.c   ****     return m->angle_reference + aoffset;
 3034               	.LM288:
 3035 0f32 F5E6      		ldi r31,lo8(101)
 3036 0f34 F29D      		mul r31,r2
 3037 0f36 9001      		movw r18,r0
 3038 0f38 F39D      		mul r31,r3
 3039 0f3a 300D      		add r19,r0
 3040 0f3c 1124      		clr __zero_reg__
 3041 0f3e C901      		movw r24,r18
 3042 0f40 8050      		subi r24,lo8(-(motors))
 3043 0f42 9040      		sbci r25,hi8(-(motors))
 3044 0f44 5C01      		movw r10,r24
 3045 0f46 FC01      		movw r30,r24
 3046 0f48 E35A      		subi r30,-93
 3047 0f4a FF4F      		sbci r31,-1
 3048 0f4c 0190      		ld __tmp_reg__,Z+
 3049 0f4e F081      		ld r31,Z
 3050 0f50 E02D      		mov r30,__tmp_reg__
 3051 0f52 C601      		movw r24,r12
 3052 0f54 0995      		icall
 174:motorctrl.c   ****     /*
 3054               	.LM289:
 3055 0f56 F501      		movw r30,r10
 3056 0f58 E85B      		subi r30,-72
 3057 0f5a FF4F      		sbci r31,-1
 3058 0f5c 2081      		ld r18,Z
 3059 0f5e 3181      		ldd r19,Z+1
 3060 0f60 4281      		ldd r20,Z+2
 3061 0f62 5381      		ldd r21,Z+3
 3062 0f64 0E94 0000 		call __addsf3
 3063               	.LBE192:
 3064               	.LBE191:
 318:motorctrl.c   ****         motorControlLoop(m);
 3066               	.LM290:
 3067 0f68 F501      		movw r30,r10
 3068 0f6a 65A7      		std Z+45,r22
 3069 0f6c 76A7      		std Z+46,r23
 3070 0f6e 87A7      		std Z+47,r24
 3071 0f70 90AB      		std Z+48,r25
 319:motorctrl.c   ****         status += m->status; //Collect status from all motors
 3073               	.LM291:
 3074 0f72 C801      		movw r24,r16
 3075 0f74 0E94 0000 		call motorControlLoop
 320:motorctrl.c   ****     }
 3077               	.LM292:
 3078 0f78 F501      		movw r30,r10
 3079 0f7a E45A      		subi r30,-92
 3080 0f7c FF4F      		sbci r31,-1
 3081 0f7e 8081      		ld r24,Z
 3082 0f80 F981      		ldd r31,Y+1
 3083 0f82 F80F      		add r31,r24
 3084 0f84 F983      		std Y+1,r31
 3085 0f86 0B59      		subi r16,-101
 3086 0f88 1F4F      		sbci r17,-1
 3087               	.LBE190:
 316:motorctrl.c   ****         volatile motor *m = &motors[i];
 3089               	.LM293:
 3090 0f8a 21E0      		ldi r18,1
 3091 0f8c 2216      		cp r2,r18
 3092 0f8e 3104      		cpc r3,__zero_reg__
 3093 0f90 01F4      		brne .L136
 3094               	.LBE204:
 323:motorctrl.c   **** 
 3096               	.LM294:
 3097 0f92 8F2F      		mov r24,r31
 3098               	/* epilogue start */
 3099 0f94 2796      		adiw r28,7
 3100 0f96 E2E1      		ldi r30, lo8(18)
 3101 0f98 0C94 0000 		jmp __epilogue_restores__ + ((18 - 18) * 2)
 3102               	.L136:
 3103               	.LBB205:
 3104 0f9c 2224      		clr r2
 3105 0f9e 2394      		inc r2
 3106 0fa0 312C      		mov r3,__zero_reg__
 3107 0fa2 00C0      		rjmp .L135
 3108               	.L139:
 3109               	.LBB203:
 3110               	.LBB202:
 3111               	.LBB201:
 3112               	.LBB200:
 3113               	.LBB199:
 202:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
 3115               	.LM295:
 3116 0fa4 EE81      		ldd r30,Y+6
 3117 0fa6 FF81      		ldd r31,Y+7
 3118 0fa8 E45A      		subi r30,-92
 3119 0faa FF4F      		sbci r31,-1
 3120 0fac 84E0      		ldi r24,lo8(4)
 3121 0fae 8083      		st Z,r24
 3122               	.L137:
 203:motorctrl.c   ****     }
 3124               	.LM296:
 3125 0fb0 EE81      		ldd r30,Y+6
 3126 0fb2 FF81      		ldd r31,Y+7
 3127 0fb4 64A5      		ldd r22,Z+44
 3128 0fb6 40E0      		ldi r20,0
 3129 0fb8 C801      		movw r24,r16
 3130 0fba 0E94 0000 		call motorControl
 3131 0fbe 00C0      		rjmp .L134
 3132               	.L138:
 3133               	.LBB198:
 3134               	.LBB197:
 198:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 3136               	.LM297:
 3137 0fc0 E45A      		subi r30,-92
 3138 0fc2 FF4F      		sbci r31,-1
 3139 0fc4 25E0      		ldi r18,lo8(5)
 3140 0fc6 2083      		st Z,r18
 3141 0fc8 00C0      		rjmp .L137
 3142               	.LBE197:
 3143               	.LBE198:
 3144               	.LBE199:
 3145               	.LBE200:
 3146               	.LBE201:
 3147               	.LBE202:
 3148               	.LBE203:
 3149               	.LBE205:
 3162               	.Lscope21:
 3164               	.global	shutdownMotors
 3166               	shutdownMotors:
 298:motorctrl.c   ****     for (uint8_t i = 0; i<NUM_OF_MOTORS; i++){
 3168               	.LM298:
 3169               	.LFBB22:
 3170 0fca A6E0      		ldi r26,lo8(6)
 3171 0fcc B0E0      		ldi r27,0
 3172 0fce E0E0      		ldi r30,lo8(gs(1f))
 3173 0fd0 F0E0      		ldi r31,hi8(gs(1f))
 3174 0fd2 0C94 0000 		jmp __prologue_saves__+((18 - 18) * 2)
 3175               	1:
 3176               	/* prologue: function */
 3177               	/* frame size = 6 */
 3178               	/* stack size = 24 */
 3179               	.L__stack_usage = 24
 3180 0fd6 80E0      		ldi r24,lo8(motors)
 3181 0fd8 282E      		mov r2,r24
 3182 0fda 80E0      		ldi r24,hi8(motors)
 3183 0fdc 382E      		mov r3,r24
 3184               	.LBB215:
 3185 0fde 00E0      		ldi r16,0
 3186 0fe0 10E0      		ldi r17,0
 3187               	.L143:
 3188               	.LBB216:
 3189               	.LBB217:
 443:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 3191               	.LM299:
 3192 0fe2 45E6      		ldi r20,lo8(101)
 3193 0fe4 409F      		mul r20,r16
 3194 0fe6 9001      		movw r18,r0
 3195 0fe8 419F      		mul r20,r17
 3196 0fea 300D      		add r19,r0
 3197 0fec 1124      		clr __zero_reg__
 3198 0fee C901      		movw r24,r18
 3199 0ff0 8050      		subi r24,lo8(-(motors))
 3200 0ff2 9040      		sbci r25,hi8(-(motors))
 3201 0ff4 9E83      		std Y+6,r25
 3202 0ff6 8D83      		std Y+5,r24
 3203 0ff8 DC01      		movw r26,r24
 3204 0ffa 5E96      		adiw r26,30
 3205 0ffc 8C91      		ld r24,X
 3206 0ffe 5E97      		sbiw r26,30
 3207 1000 5A96      		adiw r26,26
 3208 1002 ED91      		ld r30,X+
 3209 1004 FC91      		ld r31,X
 3210 1006 5B97      		sbiw r26,26+1
 3211 1008 2081      		ld r18,Z
 3212 100a 41E0      		ldi r20,lo8(1)
 3213 100c 50E0      		ldi r21,0
 3214 100e 00C0      		rjmp 2f
 3215               		1:
 3216 1010 440F      		lsl r20
 3217 1012 551F      		rol r21
 3218               		2:
 3219 1014 8A95      		dec r24
 3220 1016 02F4      		brpl 1b
 3221 1018 CA01      		movw r24,r20
 3222 101a 8095      		com r24
 3223 101c 9095      		com r25
 3224 101e 8223      		and r24,r18
 3225 1020 8083      		st Z,r24
 444:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 3227               	.LM300:
 3228 1022 1596      		adiw r26,5
 3229 1024 ED91      		ld r30,X+
 3230 1026 FC91      		ld r31,X
 3231 1028 1697      		sbiw r26,5+1
 3232 102a 1082      		st Z,__zero_reg__
 445:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 3234               	.LM301:
 3235 102c 1896      		adiw r26,8
 3236 102e ED91      		ld r30,X+
 3237 1030 FC91      		ld r31,X
 3238 1032 1997      		sbiw r26,8+1
 3239 1034 1082      		st Z,__zero_reg__
 446:motorctrl.c   ****     
 3241               	.LM302:
 3242 1036 1B96      		adiw r26,11
 3243 1038 ED91      		ld r30,X+
 3244 103a FC91      		ld r31,X
 3245 103c 1C97      		sbiw r26,11+1
 3246 103e 1082      		st Z,__zero_reg__
 449:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 3248               	.LM303:
 3249 1040 5296      		adiw r26,18
 3250 1042 ED91      		ld r30,X+
 3251 1044 FC91      		ld r31,X
 3252 1046 5397      		sbiw r26,18+1
 3253 1048 1082      		st Z,__zero_reg__
 450:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 3255               	.LM304:
 3256 104a 5596      		adiw r26,21
 3257 104c ED91      		ld r30,X+
 3258 104e FC91      		ld r31,X
 3259 1050 5697      		sbiw r26,21+1
 3260 1052 1082      		st Z,__zero_reg__
 451:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 3262               	.LM305:
 3263 1054 5896      		adiw r26,24
 3264 1056 ED91      		ld r30,X+
 3265 1058 FC91      		ld r31,X
 3266 105a 5997      		sbiw r26,24+1
 3267 105c 1082      		st Z,__zero_reg__
 452:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 3269               	.LM306:
 3270 105e 9B96      		adiw r26,43
 3271 1060 1C92      		st X,__zero_reg__
 3272 1062 9B97      		sbiw r26,43
 453:motorctrl.c   ****     
 3274               	.LM307:
 3275 1064 FD01      		movw r30,r26
 3276 1066 E65A      		subi r30,-90
 3277 1068 FF4F      		sbci r31,-1
 3278 106a 1182      		std Z+1,__zero_reg__
 3279 106c 1082      		st Z,__zero_reg__
 3280               	.LBE217:
 3281               	.LBE216:
 3282               	.LBB218:
 3283               	.LBB219:
 3284               	.LBB220:
 3285               	.LBB221:
 188:motorctrl.c   ****     //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
 3287               	.LM308:
 3288 106e 5F96      		adiw r26,31
 3289 1070 8C91      		ld r24,X
 3290 1072 44E0      		ldi r20,lo8(4)
 3291 1074 60E4      		ldi r22,lo8(64)
 3292 1076 0E94 0000 		call AVGVoltage
 3293 107a 6C01      		movw r12,r24
 3294 107c E12C      		mov r14,__zero_reg__
 3295 107e F12C      		mov r15,__zero_reg__
 190:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 3297               	.LM309:
 3298 1080 ED81      		ldd r30,Y+5
 3299 1082 FE81      		ldd r31,Y+6
 3300 1084 E15A      		subi r30,-95
 3301 1086 FF4F      		sbci r31,-1
 3302 1088 8081      		ld r24,Z
 3303 108a 9181      		ldd r25,Z+1
 3304 108c 9A83      		std Y+2,r25
 3305 108e 8983      		std Y+1,r24
 192:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 3307               	.LM310:
 3308 1090 ED81      		ldd r30,Y+5
 3309 1092 FE81      		ldd r31,Y+6
 3310 1094 E45B      		subi r30,-76
 3311 1096 FF4F      		sbci r31,-1
 3312 1098 6081      		ld r22,Z
 3313 109a 7181      		ldd r23,Z+1
 3314 109c ED81      		ldd r30,Y+5
 3315 109e FE81      		ldd r31,Y+6
 3316 10a0 E05B      		subi r30,-80
 3317 10a2 FF4F      		sbci r31,-1
 3318 10a4 4080      		ld r4,Z
 3319 10a6 5180      		ldd r5,Z+1
 3320 10a8 6280      		ldd r6,Z+2
 3321 10aa 7380      		ldd r7,Z+3
 3322 10ac ED81      		ldd r30,Y+5
 3323 10ae FE81      		ldd r31,Y+6
 3324 10b0 ED59      		subi r30,-99
 3325 10b2 FF4F      		sbci r31,-1
 3326 10b4 2081      		ld r18,Z
 3327 10b6 3181      		ldd r19,Z+1
 3328 10b8 80E0      		ldi r24,0
 3329 10ba 90E0      		ldi r25,0
 3330 10bc 2B83      		std Y+3,r18
 3331 10be 3C83      		std Y+4,r19
 3332 10c0 0E94 0000 		call __floatunsisf
 3333 10c4 4B01      		movw r8,r22
 3334 10c6 5C01      		movw r10,r24
 3335 10c8 2B81      		ldd r18,Y+3
 3336 10ca 3C81      		ldd r19,Y+4
 3337 10cc B901      		movw r22,r18
 3338 10ce 80E0      		ldi r24,0
 3339 10d0 90E0      		ldi r25,0
 3340 10d2 0E94 0000 		call __floatunsisf
 3341 10d6 9B01      		movw r18,r22
 3342 10d8 AC01      		movw r20,r24
 3343 10da C301      		movw r24,r6
 3344 10dc B201      		movw r22,r4
 3345 10de 0E94 0000 		call __divsf3
 3346 10e2 2B01      		movw r4,r22
 3347 10e4 3C01      		movw r6,r24
 190:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 3349               	.LM311:
 3350 10e6 C701      		movw r24,r14
 3351 10e8 B601      		movw r22,r12
 3352 10ea A981      		ldd r26,Y+1
 3353 10ec BA81      		ldd r27,Y+2
 3354 10ee 6A1B      		sub r22,r26
 3355 10f0 7B0B      		sbc r23,r27
 3356 10f2 8109      		sbc r24,__zero_reg__
 3357 10f4 9109      		sbc r25,__zero_reg__
 192:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 3359               	.LM312:
 3360 10f6 0E94 0000 		call __floatunsisf
 3361 10fa 9B01      		movw r18,r22
 3362 10fc AC01      		movw r20,r24
 3363 10fe C301      		movw r24,r6
 3364 1100 B201      		movw r22,r4
 3365 1102 0E94 0000 		call __mulsf3
 3366 1106 9B01      		movw r18,r22
 3367 1108 AC01      		movw r20,r24
 3368 110a C501      		movw r24,r10
 3369 110c B401      		movw r22,r8
 3370 110e 0E94 0000 		call __addsf3
 3371 1112 0E94 0000 		call __fixunssfsi
 3372 1116 6B01      		movw r12,r22
 3373 1118 7C01      		movw r14,r24
 197:motorctrl.c   ****         m->status = MAX_LIMIT;
 3375               	.LM313:
 3376 111a ED81      		ldd r30,Y+5
 3377 111c FE81      		ldd r31,Y+6
 3378 111e EA5A      		subi r30,-86
 3379 1120 FF4F      		sbci r31,-1
 3380 1122 2081      		ld r18,Z
 3381 1124 3181      		ldd r19,Z+1
 3382               	.LBB222:
 3383               	.LBB223:
 198:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 3385               	.LM314:
 3386 1126 ED81      		ldd r30,Y+5
 3387 1128 FE81      		ldd r31,Y+6
 3388               	.LBE223:
 3389               	.LBE222:
 197:motorctrl.c   ****         m->status = MAX_LIMIT;
 3391               	.LM315:
 3392 112a 6217      		cp r22,r18
 3393 112c 7307      		cpc r23,r19
 3394 112e 00F0      		brlo .+2
 3395 1130 00C0      		rjmp .L145
 201:motorctrl.c   ****         m->status = MIN_LIMIT;
 3397               	.LM316:
 3398 1132 EC5A      		subi r30,-84
 3399 1134 FF4F      		sbci r31,-1
 3400 1136 2081      		ld r18,Z
 3401 1138 3181      		ldd r19,Z+1
 3402 113a 2617      		cp r18,r22
 3403 113c 3707      		cpc r19,r23
 3404 113e 00F0      		brlo .L142
 202:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
 3406               	.LM317:
 3407 1140 ED81      		ldd r30,Y+5
 3408 1142 FE81      		ldd r31,Y+6
 3409 1144 E45A      		subi r30,-92
 3410 1146 FF4F      		sbci r31,-1
 3411 1148 84E0      		ldi r24,lo8(4)
 3412 114a 8083      		st Z,r24
 203:motorctrl.c   ****     }
 3414               	.LM318:
 3415 114c AD81      		ldd r26,Y+5
 3416 114e BE81      		ldd r27,Y+6
 3417 1150 9C96      		adiw r26,44
 3418 1152 6C91      		ld r22,X
 3419 1154 40E0      		ldi r20,0
 3420 1156 C101      		movw r24,r2
 3421 1158 0E94 0000 		call motorControl
 3422               	.L142:
 3423               	.LBE221:
 3424               	.LBE220:
 173:motorctrl.c   ****     return m->angle_reference + aoffset;
 3426               	.LM319:
 3427 115c B5E6      		ldi r27,lo8(101)
 3428 115e B09F      		mul r27,r16
 3429 1160 9001      		movw r18,r0
 3430 1162 B19F      		mul r27,r17
 3431 1164 300D      		add r19,r0
 3432 1166 1124      		clr __zero_reg__
 3433 1168 F901      		movw r30,r18
 3434 116a E050      		subi r30,lo8(-(motors))
 3435 116c F040      		sbci r31,hi8(-(motors))
 3436 116e 5F01      		movw r10,r30
 3437 1170 E35A      		subi r30,-93
 3438 1172 FF4F      		sbci r31,-1
 3439 1174 0190      		ld __tmp_reg__,Z+
 3440 1176 F081      		ld r31,Z
 3441 1178 E02D      		mov r30,__tmp_reg__
 3442 117a C601      		movw r24,r12
 3443 117c 0995      		icall
 174:motorctrl.c   ****     /*
 3445               	.LM320:
 3446 117e F501      		movw r30,r10
 3447 1180 E85B      		subi r30,-72
 3448 1182 FF4F      		sbci r31,-1
 3449 1184 2081      		ld r18,Z
 3450 1186 3181      		ldd r19,Z+1
 3451 1188 4281      		ldd r20,Z+2
 3452 118a 5381      		ldd r21,Z+3
 3453 118c 0E94 0000 		call __addsf3
 3454               	.LBE219:
 3455               	.LBE218:
 301:motorctrl.c   ****         motors[i].set_position = motors[i].current_position; //reset settings
 3457               	.LM321:
 3458 1190 D501      		movw r26,r10
 3459 1192 9D96      		adiw r26,45
 3460 1194 6D93      		st X+,r22
 3461 1196 7D93      		st X+,r23
 3462 1198 8D93      		st X+,r24
 3463 119a 9C93      		st X,r25
 3464 119c D097      		sbiw r26,45+3
 302:motorctrl.c   ****     }
 3466               	.LM322:
 3467 119e 9D96      		adiw r26,45
 3468 11a0 8D91      		ld r24,X+
 3469 11a2 9D91      		ld r25,X+
 3470 11a4 0D90      		ld __tmp_reg__,X+
 3471 11a6 BC91      		ld r27,X
 3472 11a8 A02D      		mov r26,__tmp_reg__
 3473 11aa F501      		movw r30,r10
 3474 11ac 81AB      		std Z+49,r24
 3475 11ae 92AB      		std Z+50,r25
 3476 11b0 A3AB      		std Z+51,r26
 3477 11b2 B4AB      		std Z+52,r27
 3478 11b4 F5E6      		ldi r31,101
 3479 11b6 2F0E      		add r2,r31
 3480 11b8 311C      		adc r3,__zero_reg__
 299:motorctrl.c   ****         disableMotorPWM(&motors[i]);
 3482               	.LM323:
 3483 11ba 0130      		cpi r16,1
 3484 11bc 1105      		cpc r17,__zero_reg__
 3485 11be 01F4      		brne .L144
 3486               	/* epilogue start */
 3487               	.LBE215:
 304:motorctrl.c   **** 
 3489               	.LM324:
 3490 11c0 2696      		adiw r28,6
 3491 11c2 E2E1      		ldi r30, lo8(18)
 3492 11c4 0C94 0000 		jmp __epilogue_restores__ + ((18 - 18) * 2)
 3493               	.L144:
 3494               	.LBB230:
 3495 11c8 01E0      		ldi r16,lo8(1)
 3496 11ca 10E0      		ldi r17,0
 3497 11cc 00C0      		rjmp .L143
 3498               	.L145:
 3499               	.LBB229:
 3500               	.LBB228:
 3501               	.LBB227:
 3502               	.LBB226:
 3503               	.LBB225:
 3504               	.LBB224:
 198:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 3506               	.LM325:
 3507 11ce E45A      		subi r30,-92
 3508 11d0 FF4F      		sbci r31,-1
 3509 11d2 B5E0      		ldi r27,lo8(5)
 3510 11d4 B083      		st Z,r27
 199:motorctrl.c   ****     }
 3512               	.LM326:
 3513 11d6 ED81      		ldd r30,Y+5
 3514 11d8 FE81      		ldd r31,Y+6
 3515 11da 64A5      		ldd r22,Z+44
 3516 11dc 40E0      		ldi r20,0
 3517 11de C101      		movw r24,r2
 3518 11e0 0E94 0000 		call motorControl
 3519 11e4 00C0      		rjmp .L142
 3520               	.LBE224:
 3521               	.LBE225:
 3522               	.LBE226:
 3523               	.LBE227:
 3524               	.LBE228:
 3525               	.LBE229:
 3526               	.LBE230:
 3536               	.Lscope22:
 3539               	.global	initMotor
 3541               	initMotor:
 395:motorctrl.c   ****     port = debugport;
 3543               	.LM327:
 3544               	.LFBB23:
 3545 11e6 A8E0      		ldi r26,lo8(8)
 3546 11e8 B0E0      		ldi r27,0
 3547 11ea E0E0      		ldi r30,lo8(gs(1f))
 3548 11ec F0E0      		ldi r31,hi8(gs(1f))
 3549 11ee 0C94 0000 		jmp __prologue_saves__+((18 - 18) * 2)
 3550               	1:
 3551               	/* prologue: function */
 3552               	/* frame size = 8 */
 3553               	/* stack size = 26 */
 3554               	.L__stack_usage = 26
 396:motorctrl.c   ****     //motors[ANGLE_MOTOR] = m1;
 3556               	.LM328:
 3557 11f2 9093 0000 		sts port+1,r25
 3558 11f6 8093 0000 		sts port,r24
 3559 11fa 20E0      		ldi r18,lo8(motors)
 3560 11fc 30E0      		ldi r19,hi8(motors)
 3561 11fe 3A83      		std Y+2,r19
 3562 1200 2983      		std Y+1,r18
 3563 1202 212C      		mov r2,__zero_reg__
 3564 1204 312C      		mov r3,__zero_reg__
 3565               	.LBB241:
 3566               	.LBB242:
 404:motorctrl.c   ****         *m->rev_dir_addr |= 1<<m->rev_pin;
 3568               	.LM329:
 3569 1206 01E0      		ldi r16,lo8(1)
 3570 1208 10E0      		ldi r17,0
 3571               	.L149:
 404:motorctrl.c   ****         *m->rev_dir_addr |= 1<<m->rev_pin;
 3573               	.LM330:
 3574 120a 45E6      		ldi r20,lo8(101)
 3575 120c 429D      		mul r20,r2
 3576 120e 9001      		movw r18,r0
 3577 1210 439D      		mul r20,r3
 3578 1212 300D      		add r19,r0
 3579 1214 1124      		clr __zero_reg__
 3580 1216 C901      		movw r24,r18
 3581 1218 8050      		subi r24,lo8(-(motors))
 3582 121a 9040      		sbci r25,hi8(-(motors))
 3583 121c 9887      		std Y+8,r25
 3584 121e 8F83      		std Y+7,r24
 3585 1220 DC01      		movw r26,r24
 3586 1222 1496      		adiw r26,4
 3587 1224 8C91      		ld r24,X
 3588 1226 1497      		sbiw r26,4
 3589 1228 1296      		adiw r26,2
 3590 122a ED91      		ld r30,X+
 3591 122c FC91      		ld r31,X
 3592 122e 1397      		sbiw r26,2+1
 3593 1230 2081      		ld r18,Z
 3594 1232 A801      		movw r20,r16
 3595 1234 00C0      		rjmp 2f
 3596               		1:
 3597 1236 440F      		lsl r20
 3598 1238 551F      		rol r21
 3599               		2:
 3600 123a 8A95      		dec r24
 3601 123c 02F4      		brpl 1b
 3602 123e CA01      		movw r24,r20
 3603 1240 822B      		or r24,r18
 3604 1242 8083      		st Z,r24
 405:motorctrl.c   ****         *m->enable_dir_addr |= 1<<m->enable_pin;
 3606               	.LM331:
 3607 1244 5196      		adiw r26,17
 3608 1246 8C91      		ld r24,X
 3609 1248 5197      		sbiw r26,17
 3610 124a 1F96      		adiw r26,15
 3611 124c ED91      		ld r30,X+
 3612 124e FC91      		ld r31,X
 3613 1250 5097      		sbiw r26,15+1
 3614 1252 2081      		ld r18,Z
 3615 1254 D801      		movw r26,r16
 3616 1256 00C0      		rjmp 2f
 3617               		1:
 3618 1258 AA0F      		lsl r26
 3619 125a BB1F      		rol r27
 3620               		2:
 3621 125c 8A95      		dec r24
 3622 125e 02F4      		brpl 1b
 3623 1260 CD01      		movw r24,r26
 3624 1262 822B      		or r24,r18
 3625 1264 8083      		st Z,r24
 406:motorctrl.c   ****         
 3627               	.LM332:
 3628 1266 EF81      		ldd r30,Y+7
 3629 1268 F885      		ldd r31,Y+8
 3630 126a 868D      		ldd r24,Z+30
 3631 126c 048C      		ldd __tmp_reg__,Z+28
 3632 126e F58D      		ldd r31,Z+29
 3633 1270 E02D      		mov r30,__tmp_reg__
 3634 1272 2081      		ld r18,Z
 3635 1274 A801      		movw r20,r16
 3636 1276 00C0      		rjmp 2f
 3637               		1:
 3638 1278 440F      		lsl r20
 3639 127a 551F      		rol r21
 3640               		2:
 3641 127c 8A95      		dec r24
 3642 127e 02F4      		brpl 1b
 3643 1280 CA01      		movw r24,r20
 3644 1282 822B      		or r24,r18
 3645 1284 8083      		st Z,r24
 409:motorctrl.c   ****         *m->rev_port_addr &= ~(1<<m->rev_pin);
 3647               	.LM333:
 3648 1286 AF81      		ldd r26,Y+7
 3649 1288 B885      		ldd r27,Y+8
 3650 128a 1496      		adiw r26,4
 3651 128c 8C91      		ld r24,X
 3652 128e 1497      		sbiw r26,4
 3653 1290 ED91      		ld r30,X+
 3654 1292 FC91      		ld r31,X
 3655 1294 1197      		sbiw r26,1
 3656 1296 2081      		ld r18,Z
 3657 1298 A801      		movw r20,r16
 3658 129a 00C0      		rjmp 2f
 3659               		1:
 3660 129c 440F      		lsl r20
 3661 129e 551F      		rol r21
 3662               		2:
 3663 12a0 8A95      		dec r24
 3664 12a2 02F4      		brpl 1b
 3665 12a4 CA01      		movw r24,r20
 3666 12a6 8095      		com r24
 3667 12a8 9095      		com r25
 3668 12aa 8223      		and r24,r18
 3669 12ac 8083      		st Z,r24
 410:motorctrl.c   ****         *m->enable_port_addr &= ~(1<<m->enable_pin);
 3671               	.LM334:
 3672 12ae 5196      		adiw r26,17
 3673 12b0 8C91      		ld r24,X
 3674 12b2 5197      		sbiw r26,17
 3675 12b4 1D96      		adiw r26,13
 3676 12b6 ED91      		ld r30,X+
 3677 12b8 FC91      		ld r31,X
 3678 12ba 1E97      		sbiw r26,13+1
 3679 12bc 2081      		ld r18,Z
 3680 12be D801      		movw r26,r16
 3681 12c0 00C0      		rjmp 2f
 3682               		1:
 3683 12c2 AA0F      		lsl r26
 3684 12c4 BB1F      		rol r27
 3685               		2:
 3686 12c6 8A95      		dec r24
 3687 12c8 02F4      		brpl 1b
 3688 12ca CD01      		movw r24,r26
 3689 12cc 8095      		com r24
 3690 12ce 9095      		com r25
 3691 12d0 8223      		and r24,r18
 3692 12d2 8083      		st Z,r24
 411:motorctrl.c   ****         
 3694               	.LM335:
 3695 12d4 EF81      		ldd r30,Y+7
 3696 12d6 F885      		ldd r31,Y+8
 3697 12d8 868D      		ldd r24,Z+30
 3698 12da 028C      		ldd __tmp_reg__,Z+26
 3699 12dc F38D      		ldd r31,Z+27
 3700 12de E02D      		mov r30,__tmp_reg__
 3701 12e0 2081      		ld r18,Z
 3702 12e2 A801      		movw r20,r16
 3703 12e4 00C0      		rjmp 2f
 3704               		1:
 3705 12e6 440F      		lsl r20
 3706 12e8 551F      		rol r21
 3707               		2:
 3708 12ea 8A95      		dec r24
 3709 12ec 02F4      		brpl 1b
 3710 12ee CA01      		movw r24,r20
 3711 12f0 8095      		com r24
 3712 12f2 9095      		com r25
 3713 12f4 8223      		and r24,r18
 3714 12f6 8083      		st Z,r24
 414:motorctrl.c   ****         *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 3716               	.LM336:
 3717 12f8 AF81      		ldd r26,Y+7
 3718 12fa B885      		ldd r27,Y+8
 3719 12fc 1596      		adiw r26,5
 3720 12fe ED91      		ld r30,X+
 3721 1300 FC91      		ld r31,X
 3722 1302 1697      		sbiw r26,5+1
 3723 1304 1082      		st Z,__zero_reg__
 415:motorctrl.c   ****         *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 3725               	.LM337:
 3726 1306 1896      		adiw r26,8
 3727 1308 ED91      		ld r30,X+
 3728 130a FC91      		ld r31,X
 3729 130c 1997      		sbiw r26,8+1
 3730 130e 1082      		st Z,__zero_reg__
 416:motorctrl.c   ****         
 3732               	.LM338:
 3733 1310 1B96      		adiw r26,11
 3734 1312 ED91      		ld r30,X+
 3735 1314 FC91      		ld r31,X
 3736 1316 1C97      		sbiw r26,11+1
 3737 1318 1082      		st Z,__zero_reg__
 419:motorctrl.c   ****         *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 3739               	.LM339:
 3740 131a 5296      		adiw r26,18
 3741 131c ED91      		ld r30,X+
 3742 131e FC91      		ld r31,X
 3743 1320 5397      		sbiw r26,18+1
 3744 1322 1082      		st Z,__zero_reg__
 420:motorctrl.c   ****         *m->rev_OCR_addr = 0x00; //Init PWM to zero
 3746               	.LM340:
 3747 1324 5596      		adiw r26,21
 3748 1326 ED91      		ld r30,X+
 3749 1328 FC91      		ld r31,X
 3750 132a 5697      		sbiw r26,21+1
 3751 132c 1082      		st Z,__zero_reg__
 421:motorctrl.c   ****         
 3753               	.LM341:
 3754 132e 5896      		adiw r26,24
 3755 1330 ED91      		ld r30,X+
 3756 1332 FC91      		ld r31,X
 3757 1334 5997      		sbiw r26,24+1
 3758 1336 1082      		st Z,__zero_reg__
 3759               	.LBB243:
 3760               	.LBB244:
 3762               	.Ltext13:
 163:/usr/lib/avr/include/util/delay.h **** 
 3764               	.LM342:
 3765 1338 EFE3      		ldi r30,lo8(-25537)
 3766 133a FCE9      		ldi r31,hi8(-25537)
 3767 133c 3197      	1:	sbiw r30,1
 3768 133e 01F4      		brne 1b
 3769 1340 00C0      		rjmp .
 3770 1342 0000      		nop
 3771               	.LBE244:
 3772               	.LBE243:
 3773               	.LBB245:
 3774               	.LBB246:
 3775               	.LBB247:
 3776               	.LBB248:
 3778               	.Ltext14:
 188:motorctrl.c   ****     //uint32_t voltage = Actuator_ADC(m->actuator_adc_channel, 0x40);
 3780               	.LM343:
 3781 1344 5F96      		adiw r26,31
 3782 1346 8C91      		ld r24,X
 3783 1348 44E0      		ldi r20,lo8(4)
 3784 134a 60E4      		ldi r22,lo8(64)
 3785 134c 0E94 0000 		call AVGVoltage
 3786 1350 2C01      		movw r4,r24
 3787 1352 612C      		mov r6,__zero_reg__
 3788 1354 712C      		mov r7,__zero_reg__
 190:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 3790               	.LM344:
 3791 1356 EF81      		ldd r30,Y+7
 3792 1358 F885      		ldd r31,Y+8
 3793 135a E15A      		subi r30,-95
 3794 135c FF4F      		sbci r31,-1
 3795 135e 2081      		ld r18,Z
 3796 1360 3181      		ldd r19,Z+1
 3797 1362 3C83      		std Y+4,r19
 3798 1364 2B83      		std Y+3,r18
 192:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 3800               	.LM345:
 3801 1366 EF81      		ldd r30,Y+7
 3802 1368 F885      		ldd r31,Y+8
 3803 136a E45B      		subi r30,-76
 3804 136c FF4F      		sbci r31,-1
 3805 136e 6081      		ld r22,Z
 3806 1370 7181      		ldd r23,Z+1
 3807 1372 EF81      		ldd r30,Y+7
 3808 1374 F885      		ldd r31,Y+8
 3809 1376 E05B      		subi r30,-80
 3810 1378 FF4F      		sbci r31,-1
 3811 137a 8080      		ld r8,Z
 3812 137c 9180      		ldd r9,Z+1
 3813 137e A280      		ldd r10,Z+2
 3814 1380 B380      		ldd r11,Z+3
 3815 1382 EF81      		ldd r30,Y+7
 3816 1384 F885      		ldd r31,Y+8
 3817 1386 ED59      		subi r30,-99
 3818 1388 FF4F      		sbci r31,-1
 3819 138a 2081      		ld r18,Z
 3820 138c 3181      		ldd r19,Z+1
 3821 138e 80E0      		ldi r24,0
 3822 1390 90E0      		ldi r25,0
 3823 1392 2D83      		std Y+5,r18
 3824 1394 3E83      		std Y+6,r19
 3825 1396 0E94 0000 		call __floatunsisf
 3826 139a 6B01      		movw r12,r22
 3827 139c 7C01      		movw r14,r24
 3828 139e 2D81      		ldd r18,Y+5
 3829 13a0 3E81      		ldd r19,Y+6
 3830 13a2 B901      		movw r22,r18
 3831 13a4 80E0      		ldi r24,0
 3832 13a6 90E0      		ldi r25,0
 3833 13a8 0E94 0000 		call __floatunsisf
 3834 13ac 9B01      		movw r18,r22
 3835 13ae AC01      		movw r20,r24
 3836 13b0 C501      		movw r24,r10
 3837 13b2 B401      		movw r22,r8
 3838 13b4 0E94 0000 		call __divsf3
 3839 13b8 4B01      		movw r8,r22
 3840 13ba 5C01      		movw r10,r24
 190:motorctrl.c   **** //  float effective_range = (m->actuator_max_length - m->actuator_min_length); 
 3842               	.LM346:
 3843 13bc C301      		movw r24,r6
 3844 13be B201      		movw r22,r4
 3845 13c0 4B81      		ldd r20,Y+3
 3846 13c2 5C81      		ldd r21,Y+4
 3847 13c4 641B      		sub r22,r20
 3848 13c6 750B      		sbc r23,r21
 3849 13c8 8109      		sbc r24,__zero_reg__
 3850 13ca 9109      		sbc r25,__zero_reg__
 192:motorctrl.c   ****     //                        B 340               200                 669                  -    348
 3852               	.LM347:
 3853 13cc 0E94 0000 		call __floatunsisf
 3854 13d0 9B01      		movw r18,r22
 3855 13d2 AC01      		movw r20,r24
 3856 13d4 C501      		movw r24,r10
 3857 13d6 B401      		movw r22,r8
 3858 13d8 0E94 0000 		call __mulsf3
 3859 13dc 9B01      		movw r18,r22
 3860 13de AC01      		movw r20,r24
 3861 13e0 C701      		movw r24,r14
 3862 13e2 B601      		movw r22,r12
 3863 13e4 0E94 0000 		call __addsf3
 3864 13e8 0E94 0000 		call __fixunssfsi
 3865 13ec 6B01      		movw r12,r22
 3866 13ee 7C01      		movw r14,r24
 197:motorctrl.c   ****         m->status = MAX_LIMIT;
 3868               	.LM348:
 3869 13f0 EF81      		ldd r30,Y+7
 3870 13f2 F885      		ldd r31,Y+8
 3871 13f4 EA5A      		subi r30,-86
 3872 13f6 FF4F      		sbci r31,-1
 3873 13f8 2081      		ld r18,Z
 3874 13fa 3181      		ldd r19,Z+1
 3875               	.LBB249:
 3876               	.LBB250:
 198:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 3878               	.LM349:
 3879 13fc EF81      		ldd r30,Y+7
 3880 13fe F885      		ldd r31,Y+8
 3881               	.LBE250:
 3882               	.LBE249:
 197:motorctrl.c   ****         m->status = MAX_LIMIT;
 3884               	.LM350:
 3885 1400 6217      		cp r22,r18
 3886 1402 7307      		cpc r23,r19
 3887 1404 00F0      		brlo .+2
 3888 1406 00C0      		rjmp .L151
 201:motorctrl.c   ****         m->status = MIN_LIMIT;
 3890               	.LM351:
 3891 1408 EC5A      		subi r30,-84
 3892 140a FF4F      		sbci r31,-1
 3893 140c 2081      		ld r18,Z
 3894 140e 3181      		ldd r19,Z+1
 3895 1410 2617      		cp r18,r22
 3896 1412 3707      		cpc r19,r23
 3897 1414 00F0      		brlo .L148
 202:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
 3899               	.LM352:
 3900 1416 EF81      		ldd r30,Y+7
 3901 1418 F885      		ldd r31,Y+8
 3902 141a E45A      		subi r30,-92
 3903 141c FF4F      		sbci r31,-1
 3904 141e 84E0      		ldi r24,lo8(4)
 3905 1420 8083      		st Z,r24
 203:motorctrl.c   ****     }
 3907               	.LM353:
 3908 1422 EF81      		ldd r30,Y+7
 3909 1424 F885      		ldd r31,Y+8
 3910 1426 64A5      		ldd r22,Z+44
 3911 1428 40E0      		ldi r20,0
 3912 142a 8981      		ldd r24,Y+1
 3913 142c 9A81      		ldd r25,Y+2
 3914 142e 0E94 0000 		call motorControl
 3915               	.L148:
 3916               	.LBE248:
 3917               	.LBE247:
 173:motorctrl.c   ****     return m->angle_reference + aoffset;
 3919               	.LM354:
 3920 1432 F5E6      		ldi r31,lo8(101)
 3921 1434 F29D      		mul r31,r2
 3922 1436 9001      		movw r18,r0
 3923 1438 F39D      		mul r31,r3
 3924 143a 300D      		add r19,r0
 3925 143c 1124      		clr __zero_reg__
 3926 143e A901      		movw r20,r18
 3927 1440 4050      		subi r20,lo8(-(motors))
 3928 1442 5040      		sbci r21,hi8(-(motors))
 3929 1444 5A01      		movw r10,r20
 3930 1446 FA01      		movw r30,r20
 3931 1448 E35A      		subi r30,-93
 3932 144a FF4F      		sbci r31,-1
 3933 144c 0190      		ld __tmp_reg__,Z+
 3934 144e F081      		ld r31,Z
 3935 1450 E02D      		mov r30,__tmp_reg__
 3936 1452 C601      		movw r24,r12
 3937 1454 0995      		icall
 174:motorctrl.c   ****     /*
 3939               	.LM355:
 3940 1456 F501      		movw r30,r10
 3941 1458 E85B      		subi r30,-72
 3942 145a FF4F      		sbci r31,-1
 3943 145c 2081      		ld r18,Z
 3944 145e 3181      		ldd r19,Z+1
 3945 1460 4281      		ldd r20,Z+2
 3946 1462 5381      		ldd r21,Z+3
 3947 1464 0E94 0000 		call __addsf3
 3948               	.LBE246:
 3949               	.LBE245:
 430:motorctrl.c   ****         m->set_position = m->current_position; //reset settings
 3951               	.LM356:
 3952 1468 D501      		movw r26,r10
 3953 146a 9D96      		adiw r26,45
 3954 146c 6D93      		st X+,r22
 3955 146e 7D93      		st X+,r23
 3956 1470 8D93      		st X+,r24
 3957 1472 9C93      		st X,r25
 3958 1474 D097      		sbiw r26,45+3
 431:motorctrl.c   ****     }
 3960               	.LM357:
 3961 1476 9D96      		adiw r26,45
 3962 1478 8D91      		ld r24,X+
 3963 147a 9D91      		ld r25,X+
 3964 147c 0D90      		ld __tmp_reg__,X+
 3965 147e BC91      		ld r27,X
 3966 1480 A02D      		mov r26,__tmp_reg__
 3967 1482 F501      		movw r30,r10
 3968 1484 81AB      		std Z+49,r24
 3969 1486 92AB      		std Z+50,r25
 3970 1488 A3AB      		std Z+51,r26
 3971 148a B4AB      		std Z+52,r27
 3972 148c 2981      		ldd r18,Y+1
 3973 148e 3A81      		ldd r19,Y+2
 3974 1490 2B59      		subi r18,-101
 3975 1492 3F4F      		sbci r19,-1
 3976 1494 3A83      		std Y+2,r19
 3977 1496 2983      		std Y+1,r18
 3978               	.LBE242:
 401:motorctrl.c   ****         volatile motor *m = &motors[i];
 3980               	.LM358:
 3981 1498 31E0      		ldi r19,1
 3982 149a 2316      		cp r2,r19
 3983 149c 3104      		cpc r3,__zero_reg__
 3984 149e 01F4      		brne .L150
 3985               	/* epilogue start */
 3986               	.LBE241:
 440:motorctrl.c   **** void disableMotorPWM(volatile motor *m){
 3988               	.LM359:
 3989 14a0 2896      		adiw r28,8
 3990 14a2 E2E1      		ldi r30, lo8(18)
 3991 14a4 0C94 0000 		jmp __epilogue_restores__ + ((18 - 18) * 2)
 3992               	.L150:
 3993               	.LBB258:
 3994 14a8 2224      		clr r2
 3995 14aa 2394      		inc r2
 3996 14ac 312C      		mov r3,__zero_reg__
 3997 14ae 00C0      		rjmp .L149
 3998               	.L151:
 3999               	.LBB257:
 4000               	.LBB256:
 4001               	.LBB255:
 4002               	.LBB254:
 4003               	.LBB253:
 4004               	.LBB252:
 4005               	.LBB251:
 198:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 4007               	.LM360:
 4008 14b0 E45A      		subi r30,-92
 4009 14b2 FF4F      		sbci r31,-1
 4010 14b4 55E0      		ldi r21,lo8(5)
 4011 14b6 5083      		st Z,r21
 199:motorctrl.c   ****     }
 4013               	.LM361:
 4014 14b8 AF81      		ldd r26,Y+7
 4015 14ba B885      		ldd r27,Y+8
 4016 14bc 9C96      		adiw r26,44
 4017 14be 6C91      		ld r22,X
 4018 14c0 40E0      		ldi r20,0
 4019 14c2 8981      		ldd r24,Y+1
 4020 14c4 9A81      		ldd r25,Y+2
 4021 14c6 0E94 0000 		call motorControl
 4022 14ca 00C0      		rjmp .L148
 4023               	.LBE251:
 4024               	.LBE252:
 4025               	.LBE253:
 4026               	.LBE254:
 4027               	.LBE255:
 4028               	.LBE256:
 4029               	.LBE257:
 4030               	.LBE258:
 4040               	.Lscope23:
 4041               		.comm	port,2,1
 4042               	.global	motors
 4043               		.data
 4046               	motors:
 4047 0000 2B00      		.word	43
 4048 0002 2A00      		.word	42
 4049 0004 06        		.byte	6
 4050 0005 4400      		.word	68
 4051 0007 23        		.byte	35
 4052 0008 4500      		.word	69
 4053 000a 02        		.byte	2
 4054 000b 4800      		.word	72
 4055 000d 2B00      		.word	43
 4056 000f 2A00      		.word	42
 4057 0011 05        		.byte	5
 4058 0012 4400      		.word	68
 4059 0014 83        		.byte	-125
 4060 0015 4500      		.word	69
 4061 0017 02        		.byte	2
 4062 0018 4700      		.word	71
 4063 001a 2B00      		.word	43
 4064 001c 2A00      		.word	42
 4065 001e 07        		.byte	7
 4066 001f 00        		.byte	0
 4067 0020 06        		.byte	6
 4068 0021 2800      		.word	40
 4069 0023 2700      		.word	39
 4070 0025 02        		.byte	2
 4071 0026 2800      		.word	40
 4072 0028 2700      		.word	39
 4073 002a 03        		.byte	3
 4074 002b 00        		.byte	0
 4075 002c 01        		.byte	1
 4076 002d 00        		.byte	0
 4077 002e 00        		.byte	0
 4078 002f 00        		.byte	0
 4079 0030 00        		.byte	0
 4080 0031 00        		.byte	0
 4081 0032 00        		.byte	0
 4082 0033 2F        		.byte	47
 4083 0034 43        		.byte	67
 4084 0035 01        		.byte	1
 4085 0036 01        		.byte	1
 4086 0037 F401      		.word	500
 4087 0039 F401      		.word	500
 4088 003b 00        		.byte	0
 4089 003c 00        		.byte	0
 4090 003d C0        		.byte	-64
 4091 003e 3F        		.byte	63
 4092 003f EE        		.byte	-18
 4093 0040 00        		.byte	0
 4094 0041 00        		.byte	0
 4095 0042 C8        		.byte	-56
 4096 0043 42        		.byte	66
 4097 0044 00        		.byte	0
 4098 0045 00        		.byte	0
 4099 0046 16        		.byte	22
 4100 0047 43        		.byte	67
 4101 0048 00        		.byte	0
 4102 0049 00        		.byte	0
 4103 004a 34        		.byte	52
 4104 004b 43        		.byte	67
 4105 004c 0302      		.word	515
 4106 004e 7A03      		.word	890
 4107 0050 00        		.byte	0
 4108 0051 80        		.byte	-128
 4109 0052 BB        		.byte	-69
 4110 0053 43        		.byte	67
 4111 0054 0802      		.word	520
 4112 0056 7003      		.word	880
 4113 0058 1027      		.word	10000
 4114 005a 0000      		.word	0
 4115 005c 00        		.byte	0
 4116 005d 0000      		.word	gs(angleConversion)
 4117 005f D100      		.word	209
 4118 0061 1B03      		.word	795
 4119 0063 4A02      		.word	586
 4120 0065 2500      		.word	37
 4121 0067 2400      		.word	36
 4122 0069 03        		.byte	3
 4123 006a B000      		.word	176
 4124 006c 83        		.byte	-125
 4125 006d B100      		.word	177
 4126 006f 02        		.byte	2
 4127 0070 B300      		.word	179
 4128 0072 2B00      		.word	43
 4129 0074 2A00      		.word	42
 4130 0076 03        		.byte	3
 4131 0077 B000      		.word	176
 4132 0079 23        		.byte	35
 4133 007a B100      		.word	177
 4134 007c 02        		.byte	2
 4135 007d B400      		.word	180
 4136 007f 2500      		.word	37
 4137 0081 2400      		.word	36
 4138 0083 04        		.byte	4
 4139 0084 01        		.byte	1
 4140 0085 07        		.byte	7
 4141 0086 2800      		.word	40
 4142 0088 2700      		.word	39
 4143 008a 04        		.byte	4
 4144 008b 2800      		.word	40
 4145 008d 2700      		.word	39
 4146 008f 05        		.byte	5
 4147 0090 00        		.byte	0
 4148 0091 01        		.byte	1
 4149 0092 00        		.byte	0
 4150 0093 00        		.byte	0
 4151 0094 00        		.byte	0
 4152 0095 00        		.byte	0
 4153 0096 00        		.byte	0
 4154 0097 00        		.byte	0
 4155 0098 48        		.byte	72
 4156 0099 42        		.byte	66
 4157 009a 01        		.byte	1
 4158 009b 01        		.byte	1
 4159 009c F401      		.word	500
 4160 009e F401      		.word	500
 4161 00a0 00        		.byte	0
 4162 00a1 00        		.byte	0
 4163 00a2 C0        		.byte	-64
 4164 00a3 3F        		.byte	63
 4165 00a4 EE        		.byte	-18
 4166 00a5 00        		.byte	0
 4167 00a6 00        		.byte	0
 4168 00a7 20        		.byte	32
 4169 00a8 41        		.byte	65
 4170 00a9 00        		.byte	0
 4171 00aa 00        		.byte	0
 4172 00ab A0        		.byte	-96
 4173 00ac 42        		.byte	66
 4174 00ad 00        		.byte	0
 4175 00ae 00        		.byte	0
 4176 00af A0        		.byte	-96
 4177 00b0 40        		.byte	64
 4178 00b1 5401      		.word	340
 4179 00b3 1C02      		.word	540
 4180 00b5 00        		.byte	0
 4181 00b6 00        		.byte	0
 4182 00b7 48        		.byte	72
 4183 00b8 43        		.byte	67
 4184 00b9 5E01      		.word	350
 4185 00bb 1202      		.word	530
 4186 00bd 1027      		.word	10000
 4187 00bf 0000      		.word	0
 4188 00c1 00        		.byte	0
 4189 00c2 0000      		.word	gs(tiltConversion)
 4190 00c4 6301      		.word	355
 4191 00c6 9102      		.word	657
 4192 00c8 2E01      		.word	302
 4195               		.text
 4197               	.Letext0:
 4198               		.ident	"GCC: (GNU) 4.9.2"
 4199               	.global __do_copy_data
 4200               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 motorctrl.c
     /tmp/ccOLqyQJ.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccOLqyQJ.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccOLqyQJ.s:4      *ABS*:0000003f __SREG__
     /tmp/ccOLqyQJ.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccOLqyQJ.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccOLqyQJ.s:128    .text:00000000 angleConversion
     /tmp/ccOLqyQJ.s:293    .text:00000136 tiltConversion
     /tmp/ccOLqyQJ.s:460    .text:0000026a getAngle
     /tmp/ccOLqyQJ.s:4046   .data:00000000 motors
     /tmp/ccOLqyQJ.s:482    .text:0000027c getTilt
     /tmp/ccOLqyQJ.s:507    .text:0000028e setAngle
     /tmp/ccOLqyQJ.s:600    .text:00000316 setTilt
     /tmp/ccOLqyQJ.s:694    .text:0000039e setMotorPosition
     /tmp/ccOLqyQJ.s:788    .text:0000041e getSetAngle
     /tmp/ccOLqyQJ.s:810    .text:00000430 getSetTilt
     /tmp/ccOLqyQJ.s:832    .text:00000442 getAngleMotorStatus
     /tmp/ccOLqyQJ.s:851    .text:00000448 getTiltMotorStatus
     /tmp/ccOLqyQJ.s:871    .text:0000044e delayLoop_us
     /tmp/ccOLqyQJ.s:928    .text:0000047c disableMotorPWM
     /tmp/ccOLqyQJ.s:1004   .text:000004cc setMotor
     /tmp/ccOLqyQJ.s:1220   .text:000005d2 motorControl
     /tmp/ccOLqyQJ.s:1640   .text:000007a2 getActuatorLength
     /tmp/ccOLqyQJ.s:1799   .text:00000888 motorControlLoop
                            *COM*:00000002 port
     /tmp/ccOLqyQJ.s:2380   .text:00000b64 getTiltActuatorCurrentLength
     /tmp/ccOLqyQJ.s:2538   .text:00000c50 getAngleActuatorCurrentLength
     /tmp/ccOLqyQJ.s:2697   .text:00000d3c getMotorPosition
     /tmp/ccOLqyQJ.s:2871   .text:00000e36 motorController
     /tmp/ccOLqyQJ.s:3166   .text:00000fca shutdownMotors
     /tmp/ccOLqyQJ.s:3541   .text:000011e6 initMotor

UNDEFINED SYMBOLS
__floatunsisf
__mulsf3
__floatsisf
__subsf3
__addsf3
__divsf3
__umulhisi3
sqrt
atan
__gesf2
__lesf2
__prologue_saves__
__epilogue_restores__
__fixunssfsi
AVGVoltage
fwrite
__do_copy_data
__do_clear_bss
