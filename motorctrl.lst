   1               		.file	"motorctrl.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 118               	.global	__floatunsisf
 119               	.global	__mulsf3
 120               	.global	__floatsisf
 121               	.global	__subsf3
 122               	.global	__addsf3
 123               	.global	__divsf3
 126               	.global	angleConversion
 128               	angleConversion:
   1:motorctrl.c   **** #include "motorctrl.h"
   2:motorctrl.c   **** #include "ADC.h"
   3:motorctrl.c   **** 
   4:motorctrl.c   **** // Forward and backward definition, can be changed
   5:motorctrl.c   **** #define FAST_PWM 0x03
   6:motorctrl.c   **** #define OC0A 0x80
   7:motorctrl.c   **** #define OC0B 0x20
   8:motorctrl.c   **** #define OC2A 0x80
   9:motorctrl.c   **** #define OC2B 0x20
  10:motorctrl.c   **** 
  11:motorctrl.c   **** #define DEG2RAD  M_PI / 180.0
  12:motorctrl.c   **** 
  13:motorctrl.c   **** #define CALIBRATION_HYSTERESIS 2 //in millimeters
  14:motorctrl.c   **** 
  15:motorctrl.c   **** #define SHUTDOWN 0 //shutdown motor
  16:motorctrl.c   **** #define ANGLE_MAX_PWM 0x9A //Angle motor
  17:motorctrl.c   **** #define TILT_MAX_PWM 0xFF //Tilt MOTOR
  18:motorctrl.c   **** #define PRESCALER 0x02 //PWM frequency divider
  19:motorctrl.c   **** #define NUMOFSAMPLES 4 //ADC averaging sample count
  20:motorctrl.c   **** 
  21:motorctrl.c   **** #define SET_HYSTERESIS_MM 2 
  22:motorctrl.c   **** #define TILT_HYSTERESIS_MM 3 
  23:motorctrl.c   **** #define ANGLE_HYSTERESIS_MM 4 //in millimeters
  24:motorctrl.c   **** #define MOTOR_ACCELERATION 500 //wait time in micro seconds between speed increase
  25:motorctrl.c   **** #define MOTOR_ACC_STEP 1 //8bit PWM step per acceleration.
  26:motorctrl.c   **** 
  27:motorctrl.c   **** //SET limits for the API
  28:motorctrl.c   **** #define MIN_ANGLE 105.0
  29:motorctrl.c   **** #define ANGLE_RANGE 123.0
  30:motorctrl.c   **** #define MIN_TILT 8.5
  31:motorctrl.c   **** #define TILT_RANGE 85.0
  32:motorctrl.c   **** 
  33:motorctrl.c   **** #define ANGLE_REFERENCE 165.0 //heading by default South
  34:motorctrl.c   **** #define TILT_REFERENCE 0.0   //Tilted 5 degrees upward frow vertical angle
  35:motorctrl.c   **** 
  36:motorctrl.c   **** #define ANGLE_MOTOR_TIMEOUT 60000L // TODO refactor timeout mechanism
  37:motorctrl.c   **** #define TILT_MOTOR_TIMEOUT 40000L  //
  38:motorctrl.c   **** 
  39:motorctrl.c   **** //Angle correction factors, all values are millimeters
  40:motorctrl.c   **** #define ANGLE_X 700L //Distance from center to actuator lower point
  41:motorctrl.c   **** #define ANGLE_C 190L //Distance from center to actuator far end
  42:motorctrl.c   **** #define ANGLE_Y 50L  //Offset distance from X to outside
  43:motorctrl.c   **** 
  44:motorctrl.c   **** #define TILT_X 505L //Distance from center to actuator lower point
  45:motorctrl.c   **** #define TILT_C 170L //Distance from center to actuator far end
  46:motorctrl.c   **** #define TILT_Y -145L  //Offset distance from X to outside
  47:motorctrl.c   **** 
  48:motorctrl.c   **** //Define Actuator physical measurements
  49:motorctrl.c   **** #define ACTUATOR_A_MIN_LENGTH 515L //absolute value
  50:motorctrl.c   **** #define ACTUATOR_A_MAX_LENGTH 890L //absolute value
  51:motorctrl.c   **** #define ACTUATOR_A_MIN_LIMIT  540L//Minimum limit where actuator can go
  52:motorctrl.c   **** #define ACTUATOR_A_MAX_LIMIT  870L //Maximum limit where actuator can go
  53:motorctrl.c   **** 
  54:motorctrl.c   **** #define ACTUATOR_B_MIN_LENGTH 340L  //375 515-890               //pidempi
  55:motorctrl.c   **** #define ACTUATOR_B_MAX_LENGTH 540L  //200 340-540 pisimmällään  //lyhyempi
  56:motorctrl.c   **** #define ACTUATOR_B_MIN_LIMIT  375L
  57:motorctrl.c   **** #define ACTUATOR_B_MAX_LIMIT  540L
  58:motorctrl.c   **** 
  59:motorctrl.c   **** #define VREF 4.7 //Reference voltage which is used for actuators
  60:motorctrl.c   **** #define ACTUATOR_A_LOW_OFFSET 0.93
  61:motorctrl.c   **** #define ACTUATOR_A_HIGH_OFFSET 3.75
  62:motorctrl.c   **** #define ACTUATOR_B_LOW_OFFSET 1.57
  63:motorctrl.c   **** #define ACTUATOR_B_HIGH_OFFSET 3.11
  64:motorctrl.c   **** #define ADC_BITS 1024 //16384L
  65:motorctrl.c   **** 
  66:motorctrl.c   **** #define MOTOR_A 0
  67:motorctrl.c   **** #define MOTOR_B 1
  68:motorctrl.c   **** //Define Actuator ADC Channels for Motor_A and Motor_b
  69:motorctrl.c   **** 
  70:motorctrl.c   **** #define ACTUATOR_ADC_A 0
  71:motorctrl.c   **** #define ACTUATOR_ADC_B 1
  72:motorctrl.c   **** #define ACTUATOR_CURRENT_ADC_A 7 
  73:motorctrl.c   **** #define ACTUATOR_CURRENT_ADC_B 6
  74:motorctrl.c   **** //Defines which actuator is controlling tilt and which controls angular movements
  75:motorctrl.c   **** 
  76:motorctrl.c   **** #define ANGLE_MOTOR MOTOR_A
  77:motorctrl.c   **** #define TILT_MOTOR MOTOR_B 
  78:motorctrl.c   **** 
  79:motorctrl.c   **** #define ANGLE_ACTUATOR_ADC ACTUATOR_ADC_A
  80:motorctrl.c   **** #define TILT_ACTUATOR_ADC  ACTUATOR_ADC_B
  81:motorctrl.c   **** #define ANGLE_ACTUATOR_CURRENT_ADC ACTUATOR_CURRENT_ADC_A
  82:motorctrl.c   **** #define TILT_ACTUATOR_CURRENT_ADC ACTUATOR_CURRENT_ADC_B
  83:motorctrl.c   **** 
  84:motorctrl.c   **** #define TILT_ACTUATOR_LOW_OFFSET ACTUATOR_B_LOW_OFFSET
  85:motorctrl.c   **** #define TILT_ACTUATOR_HIGH_OFFSET ACTUATOR_B_HIGH_OFFSET
  86:motorctrl.c   **** #define ANGLE_ACTUATOR_LOW_OFFSET ACTUATOR_A_LOW_OFFSET
  87:motorctrl.c   **** #define ANGLE_ACTUATOR_HIGH_OFFSET ACTUATOR_A_HIGH_OFFSET
  88:motorctrl.c   **** 
  89:motorctrl.c   **** #define ANGLE_ACTUATOR_MIN_LENGTH ACTUATOR_A_MIN_LENGTH
  90:motorctrl.c   **** #define ANGLE_ACTUATOR_MAX_LENGTH ACTUATOR_A_MAX_LENGTH
  91:motorctrl.c   **** #define ANGLE_ACTUATOR_MIN_LIMIT ACTUATOR_A_MIN_LIMIT
  92:motorctrl.c   **** #define ANGLE_ACTUATOR_MAX_LIMIT ACTUATOR_A_MAX_LIMIT
  93:motorctrl.c   **** 
  94:motorctrl.c   **** #define TILT_ACTUATOR_MIN_LENGTH ACTUATOR_B_MIN_LENGTH
  95:motorctrl.c   **** #define TILT_ACTUATOR_MAX_LENGTH ACTUATOR_B_MAX_LENGTH
  96:motorctrl.c   **** #define TILT_ACTUATOR_MIN_LIMIT ACTUATOR_B_MIN_LIMIT
  97:motorctrl.c   **** #define TILT_ACTUATOR_MAX_LIMIT ACTUATOR_B_MAX_LIMIT
  98:motorctrl.c   **** 
  99:motorctrl.c   **** volatile motor motors[] = {
 100:motorctrl.c   ****     {
 101:motorctrl.c   ****          &PORTB, &DDRB, 3, &TCCR2A, (OC2A + FAST_PWM), &TCCR2B, PRESCALER, &OCR2A, //MOTOR B FORWAR
 102:motorctrl.c   ****          &PORTD, &DDRD, 3, &TCCR2A, (OC2B + FAST_PWM), &TCCR2B, PRESCALER, &OCR2B,//MOTOR B REVERSE
 103:motorctrl.c   ****          &PORTB, &DDRB, 4,  //MOTOR Enable control       
 104:motorctrl.c   ****          ANGLE_ACTUATOR_ADC,
 105:motorctrl.c   ****          ANGLE_ACTUATOR_CURRENT_ADC,
 106:motorctrl.c   ****          0,                  //pwm
 107:motorctrl.c   ****          FORWARD,            //current dir
 108:motorctrl.c   ****          0,                  //current length       
 109:motorctrl.c   ****          0,                  //current set length
 110:motorctrl.c   ****          MOTOR_ACC_STEP,     //Acceleration step
 111:motorctrl.c   ****          MOTOR_ACC_STEP,     //Deacceleration step
 112:motorctrl.c   ****          MOTOR_ACCELERATION, //Acceleration time
 113:motorctrl.c   ****          MOTOR_ACCELERATION, //deacceleration time
 114:motorctrl.c   ****          ANGLE_HYSTERESIS_MM,
 115:motorctrl.c   ****          ANGLE_MAX_PWM,      //MAX pwm value for anglular movements
 116:motorctrl.c   ****          MIN_ANGLE,          //Minimun allowed angle
 117:motorctrl.c   ****          ANGLE_RANGE,        //0-100 mapping to angle values
 118:motorctrl.c   ****          ANGLE_REFERENCE,    //Reference which against angle corrections are applied   
 119:motorctrl.c   ****          ANGLE_ACTUATOR_MIN_LENGTH,
 120:motorctrl.c   ****          ANGLE_ACTUATOR_MAX_LENGTH,
 121:motorctrl.c   ****          ANGLE_ACTUATOR_MAX_LENGTH - ANGLE_ACTUATOR_MIN_LENGTH,
 122:motorctrl.c   ****          ANGLE_ACTUATOR_MIN_LIMIT,
 123:motorctrl.c   ****          ANGLE_ACTUATOR_MAX_LIMIT,
 124:motorctrl.c   ****          ANGLE_MOTOR_TIMEOUT,//timeout in milliseconds
 125:motorctrl.c   ****          0,                  //timeout current value starts at zero
 126:motorctrl.c   ****          STATUS_OK,
 127:motorctrl.c   ****          &angleConversion, //angle correction function pointer
 128:motorctrl.c   ****          (ADC_BITS*ANGLE_ACTUATOR_LOW_OFFSET)/VREF, //217,87 offset
 129:motorctrl.c   ****          (ADC_BITS*ANGLE_ACTUATOR_HIGH_OFFSET)/VREF, //806,12
 130:motorctrl.c   ****          ((ADC_BITS*ANGLE_ACTUATOR_HIGH_OFFSET)/VREF) - ((ADC_BITS*ANGLE_ACTUATOR_LOW_OFFSET)/VREF)
 131:motorctrl.c   ****          &angleDegToLength,
 132:motorctrl.c   ****          0.0, //Motor current
 133:motorctrl.c   ****          0.0, //motor speed
 134:motorctrl.c   ****          0 //move length
 135:motorctrl.c   ****     },
 136:motorctrl.c   ****     {
 137:motorctrl.c   ****          &PORTD, &DDRD, 6, &TCCR0A, (OC0B + FAST_PWM), &TCCR0B, PRESCALER, &OCR0B, //MOTOR A FORWAR
 138:motorctrl.c   ****          &PORTD, &DDRD, 5, &TCCR0A, (OC0A + FAST_PWM), &TCCR0B, PRESCALER, &OCR0A, //MOTOR A REVERS
 139:motorctrl.c   ****          &PORTD, &DDRD, 7, //MOTOR Enable control
 140:motorctrl.c   ****          TILT_ACTUATOR_ADC,
 141:motorctrl.c   ****          TILT_ACTUATOR_CURRENT_ADC,
 142:motorctrl.c   ****          0,         //PWM
 143:motorctrl.c   ****          FORWARD,   //current dir
 144:motorctrl.c   ****          0,  //current length       
 145:motorctrl.c   ****          0,  //current set lengthMOTOR_ACC_STEP,     //Acceleration step
 146:motorctrl.c   ****          MOTOR_ACC_STEP,
 147:motorctrl.c   ****          MOTOR_ACC_STEP,     //Deacceleration step
 148:motorctrl.c   ****          MOTOR_ACCELERATION, //Acceleration time
 149:motorctrl.c   ****          MOTOR_ACCELERATION, //deacceleration time
 150:motorctrl.c   ****          TILT_HYSTERESIS_MM,
 151:motorctrl.c   ****          TILT_MAX_PWM,      //MAX pwm value for anglular movements
 152:motorctrl.c   ****          MIN_TILT,          //Minimun allowed angle
 153:motorctrl.c   ****          TILT_RANGE,        //0-100 mapping to angle values
 154:motorctrl.c   ****          TILT_REFERENCE,
 155:motorctrl.c   ****          TILT_ACTUATOR_MIN_LENGTH,
 156:motorctrl.c   ****          TILT_ACTUATOR_MAX_LENGTH,
 157:motorctrl.c   ****          TILT_ACTUATOR_MAX_LENGTH - TILT_ACTUATOR_MIN_LENGTH,
 158:motorctrl.c   ****          TILT_ACTUATOR_MIN_LIMIT,
 159:motorctrl.c   ****          TILT_ACTUATOR_MAX_LIMIT,
 160:motorctrl.c   ****          TILT_MOTOR_TIMEOUT,//timeout in milliseconds
 161:motorctrl.c   ****          0,                  //timeout current value starts at zero
 162:motorctrl.c   ****          STATUS_OK,
 163:motorctrl.c   ****          &tiltConversion, //angle correction function pointer
 164:motorctrl.c   ****          (ADC_BITS*TILT_ACTUATOR_LOW_OFFSET)/VREF, //348,6
 165:motorctrl.c   ****          (ADC_BITS*TILT_ACTUATOR_HIGH_OFFSET)/VREF, //668,9
 166:motorctrl.c   ****          ((ADC_BITS*TILT_ACTUATOR_HIGH_OFFSET)/VREF) - ((ADC_BITS*TILT_ACTUATOR_LOW_OFFSET)/VREF),
 167:motorctrl.c   ****          &tiltDegToLength,
 168:motorctrl.c   ****          0.0,
 169:motorctrl.c   ****          0.0,
 170:motorctrl.c   ****          0
 171:motorctrl.c   ****     }};
 172:motorctrl.c   **** 
 173:motorctrl.c   **** volatile uint16_t systick = 0;
 174:motorctrl.c   **** volatile int8_t running_motor = -1;
 175:motorctrl.c   **** FILE *port;
 176:motorctrl.c   **** 
 177:motorctrl.c   **** 
 178:motorctrl.c   **** //16bit timer interrupt
 179:motorctrl.c   **** ISR(TIMER1_COMPA_vect){
 180:motorctrl.c   ****     systick ++;
 181:motorctrl.c   **** }
 182:motorctrl.c   **** 
 183:motorctrl.c   **** 
 184:motorctrl.c   **** float getTiltMotorMinAngle(void){
 185:motorctrl.c   ****     return getMotorMinAngle(&motors[TILT_MOTOR]);
 186:motorctrl.c   **** }
 187:motorctrl.c   **** 
 188:motorctrl.c   **** float getAngleMotorMinAngle(void){
 189:motorctrl.c   ****      return getMotorMinAngle(&motors[ANGLE_MOTOR]);
 190:motorctrl.c   **** }
 191:motorctrl.c   **** 
 192:motorctrl.c   **** float getTiltMotorMaxAngle(void){
 193:motorctrl.c   ****      return getMotorMaxAngle(&motors[TILT_MOTOR]);
 194:motorctrl.c   **** }
 195:motorctrl.c   **** 
 196:motorctrl.c   **** float getAngleMotorMaxAngle(void){
 197:motorctrl.c   ****      return getMotorMaxAngle(&motors[ANGLE_MOTOR]);
 198:motorctrl.c   **** }
 199:motorctrl.c   **** 
 200:motorctrl.c   **** uint16_t getTiltActuatorCurrentLength(void){
 201:motorctrl.c   ****     return motors[TILT_MOTOR].current_length;
 202:motorctrl.c   **** }
 203:motorctrl.c   **** 
 204:motorctrl.c   **** uint16_t getAngleActuatorCurrentLength(void){
 205:motorctrl.c   ****     return motors[ANGLE_MOTOR].current_length;
 206:motorctrl.c   **** }
 207:motorctrl.c   **** 
 208:motorctrl.c   **** uint16_t getTiltActuatorSetLength(void){
 209:motorctrl.c   ****     return motors[TILT_MOTOR].set_length;
 210:motorctrl.c   **** }
 211:motorctrl.c   **** 
 212:motorctrl.c   **** uint16_t getAngleActuatorSetLength(void){
 213:motorctrl.c   ****     return motors[ANGLE_MOTOR].set_length;
 214:motorctrl.c   **** }
 215:motorctrl.c   **** 
 216:motorctrl.c   **** float getAngle(void){
 217:motorctrl.c   ****     return getMotorPosition(&motors[ANGLE_MOTOR]);
 218:motorctrl.c   **** }
 219:motorctrl.c   **** 
 220:motorctrl.c   **** float getTilt(void){
 221:motorctrl.c   ****     return getMotorPosition(&motors[TILT_MOTOR]);
 222:motorctrl.c   **** }
 223:motorctrl.c   **** 
 224:motorctrl.c   **** //Returns current Angle Set value
 225:motorctrl.c   **** float getSetAngle(void){
 226:motorctrl.c   ****     return getMotorSetPosition(&motors[ANGLE_MOTOR]);
 227:motorctrl.c   **** }
 228:motorctrl.c   **** 
 229:motorctrl.c   **** //Returns current Tilt Set value  
 230:motorctrl.c   **** float getSetTilt(void){
 231:motorctrl.c   ****     return getMotorSetPosition(&motors[TILT_MOTOR]);
 232:motorctrl.c   **** }
 233:motorctrl.c   **** 
 234:motorctrl.c   **** //This function is used to set wanted Angle value
 235:motorctrl.c   **** uint8_t setAngle(float angle){
 236:motorctrl.c   ****     return setMotorPosition(&motors[ANGLE_MOTOR], angle);
 237:motorctrl.c   **** }
 238:motorctrl.c   **** 
 239:motorctrl.c   **** //This function is used to set wanted TILT angle
 240:motorctrl.c   **** uint8_t setTilt(float tilt){
 241:motorctrl.c   ****     return setMotorPosition(&motors[TILT_MOTOR], tilt);
 242:motorctrl.c   **** }
 243:motorctrl.c   **** 
 244:motorctrl.c   **** uint8_t setTiltMotorLength(uint16_t length){
 245:motorctrl.c   ****     return setMotorLength(&motors[TILT_MOTOR], length);
 246:motorctrl.c   **** }
 247:motorctrl.c   **** 
 248:motorctrl.c   **** uint8_t setAngleMotorLength(uint16_t length){
 249:motorctrl.c   ****     return setMotorLength(&motors[ANGLE_MOTOR], length);
 250:motorctrl.c   **** }
 251:motorctrl.c   **** 
 252:motorctrl.c   **** //Returns Angle motor status  
 253:motorctrl.c   **** motor_status getAngleMotorStatus(void){
 254:motorctrl.c   ****     return motors[ANGLE_MOTOR].status;
 255:motorctrl.c   **** }
 256:motorctrl.c   **** 
 257:motorctrl.c   **** //Returns Tilt motor status,   
 258:motorctrl.c   **** motor_status getTiltMotorStatus(void){
 259:motorctrl.c   ****     return motors[TILT_MOTOR].status;
 260:motorctrl.c   **** }
 261:motorctrl.c   **** 
 262:motorctrl.c   **** float getTiltMotorAVGcurrent(void){
 263:motorctrl.c   ****     return getMotorAVGcurrent(&motors[TILT_MOTOR]);
 264:motorctrl.c   **** }
 265:motorctrl.c   **** 
 266:motorctrl.c   **** float getAngleMotorAVGcurrent(void){
 267:motorctrl.c   ****     return getMotorAVGcurrent(&motors[ANGLE_MOTOR]);
 268:motorctrl.c   **** }
 269:motorctrl.c   **** 
 270:motorctrl.c   **** float getTiltMotorMoveSpeed(void){
 271:motorctrl.c   ****     return getMotorMoveSpeed(&motors[TILT_MOTOR]);
 272:motorctrl.c   **** }
 273:motorctrl.c   **** 
 274:motorctrl.c   **** float getAngleMotorMoveSpeed(void){
 275:motorctrl.c   ****     return getMotorMoveSpeed(&motors[ANGLE_MOTOR]);
 276:motorctrl.c   **** }
 277:motorctrl.c   **** 
 278:motorctrl.c   **** uint16_t getTiltMoveLength(void){
 279:motorctrl.c   ****     return getMotorMoveLength(&motors[TILT_MOTOR]);
 280:motorctrl.c   **** }
 281:motorctrl.c   **** 
 282:motorctrl.c   **** uint16_t getAngleMoveLength(void){
 283:motorctrl.c   ****     return getMotorMoveLength(&motors[ANGLE_MOTOR]);
 284:motorctrl.c   **** }
 285:motorctrl.c   **** 
 286:motorctrl.c   **** float getMotorAVGcurrent(volatile motor *m){
 287:motorctrl.c   ****     return m->avg_move_current;
 288:motorctrl.c   **** }
 289:motorctrl.c   **** 
 290:motorctrl.c   **** float getMotorMoveSpeed(volatile motor *m){
 291:motorctrl.c   ****     return m->move_speed_mm;
 292:motorctrl.c   **** }
 293:motorctrl.c   **** 
 294:motorctrl.c   **** uint16_t getMotorMoveLength(volatile motor *m){
 295:motorctrl.c   ****     return m->move_length_mm;
 296:motorctrl.c   **** }
 297:motorctrl.c   **** 
 298:motorctrl.c   **** 
 299:motorctrl.c   **** //returns motor final calculated position in degrees
 300:motorctrl.c   **** float getMotorPosition(volatile motor *m){
 301:motorctrl.c   ****     float aoffset = m->angle_correction(m->current_length);
 302:motorctrl.c   ****     return m->angle_reference + aoffset;
 303:motorctrl.c   ****     /*
 304:motorctrl.c   ****         example reference angle motor = 180
 305:motorctrl.c   ****         aoffset between -90 to 90
 306:motorctrl.c   ****         -90 when actuator is minimum position
 307:motorctrl.c   ****         90 when actuator is at max position
 308:motorctrl.c   **** 
 309:motorctrl.c   ****         ie. 180 + offset => 180 + -90 = 90  degrees
 310:motorctrl.c   ****         ie. 180 +offset  => 180 + +90 = 270 degrees
 311:motorctrl.c   ****     */
 312:motorctrl.c   **** }
 313:motorctrl.c   **** 
 314:motorctrl.c   **** float getMotorSetPosition(volatile motor *m){
 315:motorctrl.c   ****     float aoffset = m->angle_correction(m->set_length);
 316:motorctrl.c   ****     return m->angle_reference + aoffset;
 317:motorctrl.c   **** }
 318:motorctrl.c   **** 
 319:motorctrl.c   **** void measureActuatorCurrent(volatile motor *m){
 320:motorctrl.c   ****     uint16_t voltage = AVGVoltage(m->actuator_current_adc_channel, 0x40, 2);
 321:motorctrl.c   ****     m->avg_move_current = (m->avg_move_current*9.0 + voltage) / 10.0; //one sample is effecting 1/5
 322:motorctrl.c   **** }
 323:motorctrl.c   **** 
 324:motorctrl.c   **** 
 325:motorctrl.c   **** //Returns motor actuator length in millimeters
 326:motorctrl.c   **** uint16_t getActuatorLength(volatile motor *m){
 327:motorctrl.c   ****     uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
 328:motorctrl.c   ****     
 329:motorctrl.c   ****     //in case of error (out of bounds) stop motor and reset length set
 330:motorctrl.c   ****     if (voltage < (m->voltage_low_offset) || voltage > (m->voltage_high_offset + 50)){
 331:motorctrl.c   ****         m->status = ACTUATOR_ERROR;
 332:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);
 333:motorctrl.c   ****         running_motor = -1;
 334:motorctrl.c   ****         m->set_length = m->current_length;
 335:motorctrl.c   ****         fprintf_P(port, PSTR("AERR\n"));
 336:motorctrl.c   ****         _delay_ms(500);
 337:motorctrl.c   ****         return m->current_length;
 338:motorctrl.c   ****     } 
 339:motorctrl.c   **** 
 340:motorctrl.c   ****     //uint32_t voltage = GetOverSampledVoltage(m->actuator_adc_channel, 0x40);
 341:motorctrl.c   ****     voltage = (voltage - m->voltage_low_offset); //Fix minimum position starting at zero
 342:motorctrl.c   ****     uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); /
 343:motorctrl.c   ****     
 344:motorctrl.c   ****     //Shutdown if we cross virtual limit
 345:motorctrl.c   ****     if (length > m->actuator_max_limit && m->status == RUNNING_FORWARD){
 346:motorctrl.c   ****         m->status = MAX_LIMIT;
 347:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 348:motorctrl.c   ****         running_motor = -1;
 349:motorctrl.c   ****         m->set_length = length;
 350:motorctrl.c   ****        // fprintf_P(port, PSTR("MAXLERR\n"));
 351:motorctrl.c   ****     }
 352:motorctrl.c   ****     else if(length < m->actuator_min_limit && m->status == RUNNING_BACKWARD){
 353:motorctrl.c   ****         m->status = MIN_LIMIT;
 354:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
 355:motorctrl.c   ****         running_motor = -1;
 356:motorctrl.c   ****         m->set_length = length;
 357:motorctrl.c   ****        // fprintf_P(port, PSTR("MINLERR\n"));
 358:motorctrl.c   ****     }
 359:motorctrl.c   ****     return length;
 360:motorctrl.c   **** }
 361:motorctrl.c   **** //Returns angle between -90.0 - 90.0, input value is in millimeters.
 362:motorctrl.c   **** float angleConversion(uint16_t f){
 130               	.LM0:
 131               	.LFBB1:
 132 0000 4F92      		push r4
 133 0002 5F92      		push r5
 134 0004 6F92      		push r6
 135 0006 7F92      		push r7
 136 0008 8F92      		push r8
 137 000a 9F92      		push r9
 138 000c AF92      		push r10
 139 000e BF92      		push r11
 140 0010 CF92      		push r12
 141 0012 DF92      		push r13
 142 0014 EF92      		push r14
 143 0016 FF92      		push r15
 144               	/* prologue: function */
 145               	/* frame size = 0 */
 146               	/* stack size = 12 */
 147               	.L__stack_usage = 12
 148 0018 AC01      		movw r20,r24
 363:motorctrl.c   ****     return -(360L*atan((2*ANGLE_C*ANGLE_X-sqrt((-ANGLE_C*ANGLE_C + 2*ANGLE_C*f - pow(f,2.0) + ANGLE
 150               	.LM1:
 151 001a 9C01      		movw r18,r24
 152 001c ACE7      		ldi r26,lo8(124)
 153 001e B1E0      		ldi r27,lo8(1)
 154 0020 0E94 0000 		call __umulhisi3
 155 0024 6B01      		movw r12,r22
 156 0026 7C01      		movw r14,r24
 157 0028 BA01      		movw r22,r20
 158 002a 80E0      		ldi r24,0
 159 002c 90E0      		ldi r25,0
 160 002e 0E94 0000 		call __floatunsisf
 161 0032 9B01      		movw r18,r22
 162 0034 AC01      		movw r20,r24
 163 0036 0E94 0000 		call __mulsf3
 164 003a 4B01      		movw r8,r22
 165 003c 5C01      		movw r10,r24
 166 003e C701      		movw r24,r14
 167 0040 B601      		movw r22,r12
 168 0042 6450      		subi r22,4
 169 0044 7D48      		sbci r23,-115
 170 0046 8109      		sbc r24,__zero_reg__
 171 0048 9109      		sbc r25,__zero_reg__
 364:motorctrl.c   ****             (ANGLE_C*ANGLE_C + 2*ANGLE_C*f + pow(f,2.0)- ANGLE_X*ANGLE_X - ANGLE_Y*ANGLE_Y)))/
 173               	.LM2:
 174 004a 24E0      		ldi r18,4
 175 004c C20E      		add r12,r18
 176 004e 2DE8      		ldi r18,-115
 177 0050 D21E      		adc r13,r18
 178 0052 E11C      		adc r14,__zero_reg__
 179 0054 F11C      		adc r15,__zero_reg__
 363:motorctrl.c   ****     return -(360L*atan((2*ANGLE_C*ANGLE_X-sqrt((-ANGLE_C*ANGLE_C + 2*ANGLE_C*f - pow(f,2.0) + ANGLE
 181               	.LM3:
 182 0056 0E94 0000 		call __floatsisf
 183 005a A501      		movw r20,r10
 184 005c 9401      		movw r18,r8
 185 005e 0E94 0000 		call __subsf3
 186 0062 20E0      		ldi r18,0
 187 0064 32E4      		ldi r19,lo8(66)
 188 0066 4FEE      		ldi r20,lo8(-17)
 189 0068 58E4      		ldi r21,lo8(72)
 190 006a 0E94 0000 		call __addsf3
 191 006e 20E0      		ldi r18,0
 192 0070 30E4      		ldi r19,lo8(64)
 193 0072 4CE1      		ldi r20,lo8(28)
 194 0074 55E4      		ldi r21,lo8(69)
 195 0076 0E94 0000 		call __addsf3
 196 007a 2B01      		movw r4,r22
 197 007c 3C01      		movw r6,r24
 199               	.LM4:
 200 007e C701      		movw r24,r14
 201 0080 B601      		movw r22,r12
 202 0082 0E94 0000 		call __floatsisf
 203 0086 A501      		movw r20,r10
 204 0088 9401      		movw r18,r8
 205 008a 0E94 0000 		call __addsf3
 206 008e 20E0      		ldi r18,0
 207 0090 32E4      		ldi r19,lo8(66)
 208 0092 4FEE      		ldi r20,lo8(-17)
 209 0094 58E4      		ldi r21,lo8(72)
 210 0096 0E94 0000 		call __subsf3
 211 009a 20E0      		ldi r18,0
 212 009c 30E4      		ldi r19,lo8(64)
 213 009e 4CE1      		ldi r20,lo8(28)
 214 00a0 55E4      		ldi r21,lo8(69)
 215 00a2 0E94 0000 		call __subsf3
 216 00a6 9B01      		movw r18,r22
 217 00a8 AC01      		movw r20,r24
 363:motorctrl.c   ****     return -(360L*atan((2*ANGLE_C*ANGLE_X-sqrt((-ANGLE_C*ANGLE_C + 2*ANGLE_C*f - pow(f,2.0) + ANGLE
 219               	.LM5:
 220 00aa C301      		movw r24,r6
 221 00ac B201      		movw r22,r4
 222 00ae 0E94 0000 		call __mulsf3
 223 00b2 0E94 0000 		call sqrt
 224 00b6 9B01      		movw r18,r22
 225 00b8 AC01      		movw r20,r24
 226 00ba 60E0      		ldi r22,0
 227 00bc 72EE      		ldi r23,lo8(-30)
 228 00be 81E8      		ldi r24,lo8(-127)
 229 00c0 98E4      		ldi r25,lo8(72)
 230 00c2 0E94 0000 		call __subsf3
 231 00c6 6B01      		movw r12,r22
 232 00c8 7C01      		movw r14,r24
 365:motorctrl.c   ****             (ANGLE_C*ANGLE_C + 2*ANGLE_C*ANGLE_Y - pow(f,2.0) + ANGLE_X*ANGLE_X + ANGLE_Y*ANGLE_Y))
 234               	.LM6:
 235 00ca A501      		movw r20,r10
 236 00cc 9401      		movw r18,r8
 237 00ce 60E0      		ldi r22,0
 238 00d0 7CE3      		ldi r23,lo8(60)
 239 00d2 87E5      		ldi r24,lo8(87)
 240 00d4 97E4      		ldi r25,lo8(71)
 241 00d6 0E94 0000 		call __subsf3
 242 00da 20E0      		ldi r18,0
 243 00dc 32E4      		ldi r19,lo8(66)
 244 00de 4FEE      		ldi r20,lo8(-17)
 245 00e0 58E4      		ldi r21,lo8(72)
 246 00e2 0E94 0000 		call __addsf3
 247 00e6 20E0      		ldi r18,0
 248 00e8 30E4      		ldi r19,lo8(64)
 249 00ea 4CE1      		ldi r20,lo8(28)
 250 00ec 55E4      		ldi r21,lo8(69)
 251 00ee 0E94 0000 		call __addsf3
 252 00f2 9B01      		movw r18,r22
 253 00f4 AC01      		movw r20,r24
 363:motorctrl.c   ****     return -(360L*atan((2*ANGLE_C*ANGLE_X-sqrt((-ANGLE_C*ANGLE_C + 2*ANGLE_C*f - pow(f,2.0) + ANGLE
 255               	.LM7:
 256 00f6 C701      		movw r24,r14
 257 00f8 B601      		movw r22,r12
 258 00fa 0E94 0000 		call __divsf3
 259 00fe 0E94 0000 		call atan
 260 0102 20E0      		ldi r18,0
 261 0104 30E0      		ldi r19,0
 262 0106 44EB      		ldi r20,lo8(-76)
 263 0108 53E4      		ldi r21,lo8(67)
 264 010a 0E94 0000 		call __mulsf3
 265 010e 9058      		subi r25,0x80
 266 0110 2BED      		ldi r18,lo8(-37)
 267 0112 3FE0      		ldi r19,lo8(15)
 268 0114 49E4      		ldi r20,lo8(73)
 269 0116 50E4      		ldi r21,lo8(64)
 270 0118 0E94 0000 		call __divsf3
 271               	/* epilogue start */
 366:motorctrl.c   **** }
 273               	.LM8:
 274 011c FF90      		pop r15
 275 011e EF90      		pop r14
 276 0120 DF90      		pop r13
 277 0122 CF90      		pop r12
 278 0124 BF90      		pop r11
 279 0126 AF90      		pop r10
 280 0128 9F90      		pop r9
 281 012a 8F90      		pop r8
 282 012c 7F90      		pop r7
 283 012e 6F90      		pop r6
 284 0130 5F90      		pop r5
 285 0132 4F90      		pop r4
 286 0134 0895      		ret
 288               	.Lscope1:
 291               	.global	tiltConversion
 293               	tiltConversion:
 367:motorctrl.c   **** 
 368:motorctrl.c   **** //Returns tilt angle between 0 to 90 degrees positive. input values in millimeters 
 369:motorctrl.c   **** float tiltConversion(uint16_t f){
 295               	.LM9:
 296               	.LFBB2:
 297 0136 4F92      		push r4
 298 0138 5F92      		push r5
 299 013a 6F92      		push r6
 300 013c 7F92      		push r7
 301 013e 8F92      		push r8
 302 0140 9F92      		push r9
 303 0142 AF92      		push r10
 304 0144 BF92      		push r11
 305 0146 CF92      		push r12
 306 0148 DF92      		push r13
 307 014a EF92      		push r14
 308 014c FF92      		push r15
 309               	/* prologue: function */
 310               	/* frame size = 0 */
 311               	/* stack size = 12 */
 312               	.L__stack_usage = 12
 313 014e AC01      		movw r20,r24
 370:motorctrl.c   ****     return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_
 315               	.LM10:
 316 0150 9C01      		movw r18,r24
 317 0152 A4E5      		ldi r26,lo8(84)
 318 0154 B1E0      		ldi r27,lo8(1)
 319 0156 0E94 0000 		call __umulhisi3
 320 015a 6B01      		movw r12,r22
 321 015c 7C01      		movw r14,r24
 322 015e BA01      		movw r22,r20
 323 0160 80E0      		ldi r24,0
 324 0162 90E0      		ldi r25,0
 325 0164 0E94 0000 		call __floatunsisf
 326 0168 9B01      		movw r18,r22
 327 016a AC01      		movw r20,r24
 328 016c 0E94 0000 		call __mulsf3
 329 0170 4B01      		movw r8,r22
 330 0172 5C01      		movw r10,r24
 331 0174 C701      		movw r24,r14
 332 0176 B601      		movw r22,r12
 333 0178 645E      		subi r22,-28
 334 017a 7047      		sbci r23,112
 335 017c 8109      		sbc r24,__zero_reg__
 336 017e 9109      		sbc r25,__zero_reg__
 371:motorctrl.c   ****               (TILT_C*TILT_C + 2L*TILT_C*f + pow(f,2.0)- TILT_X*TILT_X - TILT_Y*TILT_Y)))/
 338               	.LM11:
 339 0180 24EE      		ldi r18,-28
 340 0182 C20E      		add r12,r18
 341 0184 20E7      		ldi r18,112
 342 0186 D21E      		adc r13,r18
 343 0188 E11C      		adc r14,__zero_reg__
 344 018a F11C      		adc r15,__zero_reg__
 370:motorctrl.c   ****     return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_
 346               	.LM12:
 347 018c 0E94 0000 		call __floatsisf
 348 0190 A501      		movw r20,r10
 349 0192 9401      		movw r18,r8
 350 0194 0E94 0000 		call __subsf3
 351 0198 20E4      		ldi r18,lo8(64)
 352 019a 3CE0      		ldi r19,lo8(12)
 353 019c 49E7      		ldi r20,lo8(121)
 354 019e 58E4      		ldi r21,lo8(72)
 355 01a0 0E94 0000 		call __addsf3
 356 01a4 20E0      		ldi r18,0
 357 01a6 32E4      		ldi r19,lo8(66)
 358 01a8 44EA      		ldi r20,lo8(-92)
 359 01aa 56E4      		ldi r21,lo8(70)
 360 01ac 0E94 0000 		call __addsf3
 361 01b0 2B01      		movw r4,r22
 362 01b2 3C01      		movw r6,r24
 364               	.LM13:
 365 01b4 C701      		movw r24,r14
 366 01b6 B601      		movw r22,r12
 367 01b8 0E94 0000 		call __floatsisf
 368 01bc A501      		movw r20,r10
 369 01be 9401      		movw r18,r8
 370 01c0 0E94 0000 		call __addsf3
 371 01c4 20E4      		ldi r18,lo8(64)
 372 01c6 3CE0      		ldi r19,lo8(12)
 373 01c8 49E7      		ldi r20,lo8(121)
 374 01ca 58E4      		ldi r21,lo8(72)
 375 01cc 0E94 0000 		call __subsf3
 376 01d0 20E0      		ldi r18,0
 377 01d2 32E4      		ldi r19,lo8(66)
 378 01d4 44EA      		ldi r20,lo8(-92)
 379 01d6 56E4      		ldi r21,lo8(70)
 380 01d8 0E94 0000 		call __subsf3
 381 01dc 9B01      		movw r18,r22
 382 01de AC01      		movw r20,r24
 370:motorctrl.c   ****     return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_
 384               	.LM14:
 385 01e0 C301      		movw r24,r6
 386 01e2 B201      		movw r22,r4
 387 01e4 0E94 0000 		call __mulsf3
 388 01e8 0E94 0000 		call sqrt
 389 01ec 9B01      		movw r18,r22
 390 01ee AC01      		movw r20,r24
 391 01f0 60E0      		ldi r22,0
 392 01f2 7DEA      		ldi r23,lo8(-83)
 393 01f4 87E2      		ldi r24,lo8(39)
 394 01f6 98E4      		ldi r25,lo8(72)
 395 01f8 0E94 0000 		call __subsf3
 396 01fc 6B01      		movw r12,r22
 397 01fe 7C01      		movw r14,r24
 372:motorctrl.c   ****               (TILT_C*TILT_C + 2L*TILT_C*TILT_Y - pow(f,2.0) + TILT_X*TILT_X + TILT_Y*TILT_Y)))/M_P
 399               	.LM15:
 400 0200 A501      		movw r20,r10
 401 0202 9401      		movw r18,r8
 402 0204 60E0      		ldi r22,0
 403 0206 70E6      		ldi r23,lo8(96)
 404 0208 8FE9      		ldi r24,lo8(-97)
 405 020a 96EC      		ldi r25,lo8(-58)
 406 020c 0E94 0000 		call __subsf3
 407 0210 20E4      		ldi r18,lo8(64)
 408 0212 3CE0      		ldi r19,lo8(12)
 409 0214 49E7      		ldi r20,lo8(121)
 410 0216 58E4      		ldi r21,lo8(72)
 411 0218 0E94 0000 		call __addsf3
 412 021c 20E0      		ldi r18,0
 413 021e 32E4      		ldi r19,lo8(66)
 414 0220 44EA      		ldi r20,lo8(-92)
 415 0222 56E4      		ldi r21,lo8(70)
 416 0224 0E94 0000 		call __addsf3
 417 0228 9B01      		movw r18,r22
 418 022a AC01      		movw r20,r24
 370:motorctrl.c   ****     return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_
 420               	.LM16:
 421 022c C701      		movw r24,r14
 422 022e B601      		movw r22,r12
 423 0230 0E94 0000 		call __divsf3
 424 0234 0E94 0000 		call atan
 425 0238 20E0      		ldi r18,0
 426 023a 30E0      		ldi r19,0
 427 023c 44EB      		ldi r20,lo8(-76)
 428 023e 53E4      		ldi r21,lo8(67)
 429 0240 0E94 0000 		call __mulsf3
 431               	.LM17:
 432 0244 2BED      		ldi r18,lo8(-37)
 433 0246 3FE0      		ldi r19,lo8(15)
 434 0248 49E4      		ldi r20,lo8(73)
 435 024a 50E4      		ldi r21,lo8(64)
 436 024c 0E94 0000 		call __divsf3
 437 0250 9B01      		movw r18,r22
 438 0252 AC01      		movw r20,r24
 370:motorctrl.c   ****     return 90.0-(360L*atan((2L*TILT_C*TILT_X-sqrt((-TILT_C*TILT_C + 2*TILT_C*f - pow(f,2.0) + TILT_
 440               	.LM18:
 441 0254 60E0      		ldi r22,0
 442 0256 70E0      		ldi r23,0
 443 0258 84EB      		ldi r24,lo8(-76)
 444 025a 92E4      		ldi r25,lo8(66)
 445 025c 0E94 0000 		call __subsf3
 446               	/* epilogue start */
 373:motorctrl.c   **** }
 448               	.LM19:
 449 0260 FF90      		pop r15
 450 0262 EF90      		pop r14
 451 0264 DF90      		pop r13
 452 0266 CF90      		pop r12
 453 0268 BF90      		pop r11
 454 026a AF90      		pop r10
 455 026c 9F90      		pop r9
 456 026e 8F90      		pop r8
 457 0270 7F90      		pop r7
 458 0272 6F90      		pop r6
 459 0274 5F90      		pop r5
 460 0276 4F90      		pop r4
 461 0278 0895      		ret
 463               	.Lscope2:
 464               	.global	__fixunssfsi
 467               	.global	angleDegToLength
 469               	angleDegToLength:
 374:motorctrl.c   **** 
 375:motorctrl.c   **** uint16_t angleDegToLength(float angle){
 471               	.LM20:
 472               	.LFBB3:
 473 027a 8F92      		push r8
 474 027c 9F92      		push r9
 475 027e AF92      		push r10
 476 0280 BF92      		push r11
 477 0282 CF92      		push r12
 478 0284 DF92      		push r13
 479 0286 EF92      		push r14
 480 0288 FF92      		push r15
 481               	/* prologue: function */
 482               	/* frame size = 0 */
 483               	/* stack size = 8 */
 484               	.L__stack_usage = 8
 376:motorctrl.c   ****     float alfa = (angle+180)*DEG2RAD;
 486               	.LM21:
 487 028a 20E0      		ldi r18,0
 488 028c 30E0      		ldi r19,0
 489 028e 44E3      		ldi r20,lo8(52)
 490 0290 53E4      		ldi r21,lo8(67)
 491 0292 0E94 0000 		call __addsf3
 492 0296 2BED      		ldi r18,lo8(-37)
 493 0298 3FE0      		ldi r19,lo8(15)
 494 029a 49E4      		ldi r20,lo8(73)
 495 029c 50E4      		ldi r21,lo8(64)
 496 029e 0E94 0000 		call __mulsf3
 497 02a2 20E0      		ldi r18,0
 498 02a4 30E0      		ldi r19,0
 499 02a6 44E3      		ldi r20,lo8(52)
 500 02a8 53E4      		ldi r21,lo8(67)
 501 02aa 0E94 0000 		call __divsf3
 502 02ae 6B01      		movw r12,r22
 503 02b0 7C01      		movw r14,r24
 377:motorctrl.c   ****     return sqrt(pow((cos(alfa)*ANGLE_C+ANGLE_Y),2.0)+pow((ANGLE_X-sin(alfa)*ANGLE_C),2.0));
 505               	.LM22:
 506 02b2 0E94 0000 		call cos
 507 02b6 20E0      		ldi r18,0
 508 02b8 30E0      		ldi r19,0
 509 02ba 4EE3      		ldi r20,lo8(62)
 510 02bc 53E4      		ldi r21,lo8(67)
 511 02be 0E94 0000 		call __mulsf3
 512 02c2 20E0      		ldi r18,0
 513 02c4 30E0      		ldi r19,0
 514 02c6 48E4      		ldi r20,lo8(72)
 515 02c8 52E4      		ldi r21,lo8(66)
 516 02ca 0E94 0000 		call __addsf3
 517 02ce 4B01      		movw r8,r22
 518 02d0 5C01      		movw r10,r24
 519 02d2 C701      		movw r24,r14
 520 02d4 B601      		movw r22,r12
 521 02d6 0E94 0000 		call sin
 522 02da 20E0      		ldi r18,0
 523 02dc 30E0      		ldi r19,0
 524 02de 4EE3      		ldi r20,lo8(62)
 525 02e0 53E4      		ldi r21,lo8(67)
 526 02e2 0E94 0000 		call __mulsf3
 527 02e6 9B01      		movw r18,r22
 528 02e8 AC01      		movw r20,r24
 529 02ea 60E0      		ldi r22,0
 530 02ec 70E0      		ldi r23,0
 531 02ee 8FE2      		ldi r24,lo8(47)
 532 02f0 94E4      		ldi r25,lo8(68)
 533 02f2 0E94 0000 		call __subsf3
 534 02f6 6B01      		movw r12,r22
 535 02f8 7C01      		movw r14,r24
 536 02fa A501      		movw r20,r10
 537 02fc 9401      		movw r18,r8
 538 02fe C501      		movw r24,r10
 539 0300 B401      		movw r22,r8
 540 0302 0E94 0000 		call __mulsf3
 541 0306 4B01      		movw r8,r22
 542 0308 5C01      		movw r10,r24
 543 030a A701      		movw r20,r14
 544 030c 9601      		movw r18,r12
 545 030e C701      		movw r24,r14
 546 0310 B601      		movw r22,r12
 547 0312 0E94 0000 		call __mulsf3
 548 0316 9B01      		movw r18,r22
 549 0318 AC01      		movw r20,r24
 550 031a C501      		movw r24,r10
 551 031c B401      		movw r22,r8
 552 031e 0E94 0000 		call __addsf3
 553 0322 0E94 0000 		call sqrt
 554 0326 0E94 0000 		call __fixunssfsi
 378:motorctrl.c   **** }
 556               	.LM23:
 557 032a CB01      		movw r24,r22
 558               	/* epilogue start */
 559 032c FF90      		pop r15
 560 032e EF90      		pop r14
 561 0330 DF90      		pop r13
 562 0332 CF90      		pop r12
 563 0334 BF90      		pop r11
 564 0336 AF90      		pop r10
 565 0338 9F90      		pop r9
 566 033a 8F90      		pop r8
 567 033c 0895      		ret
 569               	.Lscope3:
 572               	.global	tiltDegToLength
 574               	tiltDegToLength:
 379:motorctrl.c   **** 
 380:motorctrl.c   **** uint16_t tiltDegToLength(float angle){
 576               	.LM24:
 577               	.LFBB4:
 578 033e 8F92      		push r8
 579 0340 9F92      		push r9
 580 0342 AF92      		push r10
 581 0344 BF92      		push r11
 582 0346 CF92      		push r12
 583 0348 DF92      		push r13
 584 034a EF92      		push r14
 585 034c FF92      		push r15
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 8 */
 589               	.L__stack_usage = 8
 381:motorctrl.c   ****     float alfa = (angle+90)*DEG2RAD;
 591               	.LM25:
 592 034e 20E0      		ldi r18,0
 593 0350 30E0      		ldi r19,0
 594 0352 44EB      		ldi r20,lo8(-76)
 595 0354 52E4      		ldi r21,lo8(66)
 596 0356 0E94 0000 		call __addsf3
 597 035a 2BED      		ldi r18,lo8(-37)
 598 035c 3FE0      		ldi r19,lo8(15)
 599 035e 49E4      		ldi r20,lo8(73)
 600 0360 50E4      		ldi r21,lo8(64)
 601 0362 0E94 0000 		call __mulsf3
 602 0366 20E0      		ldi r18,0
 603 0368 30E0      		ldi r19,0
 604 036a 44E3      		ldi r20,lo8(52)
 605 036c 53E4      		ldi r21,lo8(67)
 606 036e 0E94 0000 		call __divsf3
 607 0372 6B01      		movw r12,r22
 608 0374 7C01      		movw r14,r24
 382:motorctrl.c   ****     return sqrt(pow((cos(alfa)*TILT_C+TILT_Y),2.0)+pow((TILT_X-sin(alfa)*TILT_C),2.0));
 610               	.LM26:
 611 0376 0E94 0000 		call cos
 612 037a 20E0      		ldi r18,0
 613 037c 30E0      		ldi r19,0
 614 037e 4AE2      		ldi r20,lo8(42)
 615 0380 53E4      		ldi r21,lo8(67)
 616 0382 0E94 0000 		call __mulsf3
 617 0386 20E0      		ldi r18,0
 618 0388 30E0      		ldi r19,0
 619 038a 41E1      		ldi r20,lo8(17)
 620 038c 53E4      		ldi r21,lo8(67)
 621 038e 0E94 0000 		call __subsf3
 622 0392 4B01      		movw r8,r22
 623 0394 5C01      		movw r10,r24
 624 0396 C701      		movw r24,r14
 625 0398 B601      		movw r22,r12
 626 039a 0E94 0000 		call sin
 627 039e 20E0      		ldi r18,0
 628 03a0 30E0      		ldi r19,0
 629 03a2 4AE2      		ldi r20,lo8(42)
 630 03a4 53E4      		ldi r21,lo8(67)
 631 03a6 0E94 0000 		call __mulsf3
 632 03aa 9B01      		movw r18,r22
 633 03ac AC01      		movw r20,r24
 634 03ae 60E0      		ldi r22,0
 635 03b0 70E8      		ldi r23,lo8(-128)
 636 03b2 8CEF      		ldi r24,lo8(-4)
 637 03b4 93E4      		ldi r25,lo8(67)
 638 03b6 0E94 0000 		call __subsf3
 639 03ba 6B01      		movw r12,r22
 640 03bc 7C01      		movw r14,r24
 641 03be A501      		movw r20,r10
 642 03c0 9401      		movw r18,r8
 643 03c2 C501      		movw r24,r10
 644 03c4 B401      		movw r22,r8
 645 03c6 0E94 0000 		call __mulsf3
 646 03ca 4B01      		movw r8,r22
 647 03cc 5C01      		movw r10,r24
 648 03ce A701      		movw r20,r14
 649 03d0 9601      		movw r18,r12
 650 03d2 C701      		movw r24,r14
 651 03d4 B601      		movw r22,r12
 652 03d6 0E94 0000 		call __mulsf3
 653 03da 9B01      		movw r18,r22
 654 03dc AC01      		movw r20,r24
 655 03de C501      		movw r24,r10
 656 03e0 B401      		movw r22,r8
 657 03e2 0E94 0000 		call __addsf3
 658 03e6 0E94 0000 		call sqrt
 659 03ea 0E94 0000 		call __fixunssfsi
 383:motorctrl.c   **** }
 661               	.LM27:
 662 03ee CB01      		movw r24,r22
 663               	/* epilogue start */
 664 03f0 FF90      		pop r15
 665 03f2 EF90      		pop r14
 666 03f4 DF90      		pop r13
 667 03f6 CF90      		pop r12
 668 03f8 BF90      		pop r11
 669 03fa AF90      		pop r10
 670 03fc 9F90      		pop r9
 671 03fe 8F90      		pop r8
 672 0400 0895      		ret
 674               	.Lscope4:
 676               	.global	__vector_11
 678               	__vector_11:
 179:motorctrl.c   ****     systick ++;
 680               	.LM28:
 681               	.LFBB5:
 682 0402 1F92      		push r1
 683 0404 0F92      		push r0
 684 0406 0FB6      		in r0,__SREG__
 685 0408 0F92      		push r0
 686 040a 1124      		clr __zero_reg__
 687 040c 8F93      		push r24
 688 040e 9F93      		push r25
 689               	/* prologue: Signal */
 690               	/* frame size = 0 */
 691               	/* stack size = 5 */
 692               	.L__stack_usage = 5
 180:motorctrl.c   **** }
 694               	.LM29:
 695 0410 8091 0000 		lds r24,systick
 696 0414 9091 0000 		lds r25,systick+1
 697 0418 0196      		adiw r24,1
 698 041a 9093 0000 		sts systick+1,r25
 699 041e 8093 0000 		sts systick,r24
 700               	/* epilogue start */
 181:motorctrl.c   **** 
 702               	.LM30:
 703 0422 9F91      		pop r25
 704 0424 8F91      		pop r24
 705 0426 0F90      		pop r0
 706 0428 0FBE      		out __SREG__,r0
 707 042a 0F90      		pop r0
 708 042c 1F90      		pop r1
 709 042e 1895      		reti
 711               	.Lscope5:
 713               	.global	getTiltMotorMinAngle
 715               	getTiltMotorMinAngle:
 184:motorctrl.c   ****     return getMotorMinAngle(&motors[TILT_MOTOR]);
 717               	.LM31:
 718               	.LFBB6:
 719               	/* prologue: function */
 720               	/* frame size = 0 */
 721               	/* stack size = 0 */
 722               	.L__stack_usage = 0
 723               	.LBB96:
 724               	.LBB97:
 384:motorctrl.c   **** 
 385:motorctrl.c   **** 
 386:motorctrl.c   **** /*
 387:motorctrl.c   ****     Private function which sets a new position to given motor.
 388:motorctrl.c   ****     Motor min/max angles are checked and min,max values are used
 389:motorctrl.c   ****     if new angle is lower or higher
 390:motorctrl.c   **** */
 391:motorctrl.c   **** uint8_t setMotorPosition(volatile motor *m, float angle){
 392:motorctrl.c   ****     m->status = WAITING;
 393:motorctrl.c   ****     //vefify that angle is in between valid range
 394:motorctrl.c   ****     if (angle >= m->min_angle && angle <= (m->min_angle + m->angle_range)){
 395:motorctrl.c   ****         m->timeout_value = 0; //Clear timeout value on every angle change
 396:motorctrl.c   ****         uint16_t len = m->angle_to_length(angle - m->angle_reference);
 397:motorctrl.c   ****     
 398:motorctrl.c   ****         //fix hysteresis offset
 399:motorctrl.c   ****         if (len > m->set_length){ //Setting bigger angle
 400:motorctrl.c   ****             uint16_t newlen = len + (m->length_hysteresis);
 401:motorctrl.c   ****             if (newlen > m->actuator_max_limit){
 402:motorctrl.c   ****                 newlen = m->actuator_max_limit-1;
 403:motorctrl.c   ****             }
 404:motorctrl.c   ****             m->set_length = newlen;
 405:motorctrl.c   ****         }
 406:motorctrl.c   ****         else{ //Setting lower angle
 407:motorctrl.c   ****             uint16_t newlen = len - (m->length_hysteresis);
 408:motorctrl.c   ****             if (newlen < m->actuator_min_limit){
 409:motorctrl.c   ****                 newlen = m->actuator_min_limit+1;
 410:motorctrl.c   ****             }
 411:motorctrl.c   ****             m->set_length = newlen;
 412:motorctrl.c   ****         }
 413:motorctrl.c   **** 
 414:motorctrl.c   ****         calculateMoveLength(m);  
 415:motorctrl.c   ****             
 416:motorctrl.c   ****         return 0;
 417:motorctrl.c   ****     }
 418:motorctrl.c   **** 
 419:motorctrl.c   ****     //angle is bigger than allowed => use max angle
 420:motorctrl.c   ****     if (angle > (m->min_angle + m->angle_range)){
 421:motorctrl.c   ****         uint16_t newlen = m->angle_to_length((m->min_angle+m->angle_range) - m->angle_reference); 
 422:motorctrl.c   ****         if (newlen > m->actuator_max_limit){
 423:motorctrl.c   ****             newlen = m->actuator_max_limit - 1;
 424:motorctrl.c   ****         }
 425:motorctrl.c   ****         m->set_length = newlen; 
 426:motorctrl.c   ****     }
 427:motorctrl.c   ****     //angle is smaller than allowed => use minimum angle
 428:motorctrl.c   ****     else if (angle < m->min_angle){
 429:motorctrl.c   ****         uint16_t newlen = m->angle_to_length(m->min_angle - m->angle_reference); 
 430:motorctrl.c   ****         if (newlen < m->actuator_min_limit){
 431:motorctrl.c   ****             newlen = m->actuator_min_limit + 1; 
 432:motorctrl.c   ****         }
 433:motorctrl.c   ****         m->set_length = newlen;
 434:motorctrl.c   ****     }
 435:motorctrl.c   ****     m->timeout_value = 0;
 436:motorctrl.c   ****     
 437:motorctrl.c   ****     calculateMoveLength(m);
 438:motorctrl.c   ****     systick = 0;
 439:motorctrl.c   ****     return 1;
 440:motorctrl.c   **** }   
 441:motorctrl.c   **** 
 442:motorctrl.c   **** void calculateMoveLength(volatile motor *m){
 443:motorctrl.c   ****       //Store move length for speed calculations
 444:motorctrl.c   ****      if (m->current_length < m->set_length){
 445:motorctrl.c   ****          m->move_length_mm = m->set_length - m->current_length;
 446:motorctrl.c   ****      }
 447:motorctrl.c   ****      else if (m->current_length > m->set_length){
 448:motorctrl.c   ****          m->move_length_mm = m->current_length - m->set_length;
 449:motorctrl.c   ****      }
 450:motorctrl.c   **** }
 451:motorctrl.c   **** 
 452:motorctrl.c   **** float getMotorMinAngle(volatile motor *m){
 453:motorctrl.c   ****     return m->min_angle;
 726               	.LM32:
 727 0430 6091 0000 		lds r22,motors+147
 728 0434 7091 0000 		lds r23,motors+147+1
 729 0438 8091 0000 		lds r24,motors+147+2
 730 043c 9091 0000 		lds r25,motors+147+3
 731               	.LBE97:
 732               	.LBE96:
 186:motorctrl.c   **** 
 734               	.LM33:
 735 0440 0895      		ret
 737               	.Lscope6:
 739               	.global	getAngleMotorMinAngle
 741               	getAngleMotorMinAngle:
 188:motorctrl.c   ****      return getMotorMinAngle(&motors[ANGLE_MOTOR]);
 743               	.LM34:
 744               	.LFBB7:
 745               	/* prologue: function */
 746               	/* frame size = 0 */
 747               	/* stack size = 0 */
 748               	.L__stack_usage = 0
 749               	.LBB98:
 750               	.LBB99:
 752               	.LM35:
 753 0442 6091 0000 		lds r22,motors+47
 754 0446 7091 0000 		lds r23,motors+47+1
 755 044a 8091 0000 		lds r24,motors+47+2
 756 044e 9091 0000 		lds r25,motors+47+3
 757               	.LBE99:
 758               	.LBE98:
 190:motorctrl.c   **** 
 760               	.LM36:
 761 0452 0895      		ret
 763               	.Lscope7:
 765               	.global	getTiltMotorMaxAngle
 767               	getTiltMotorMaxAngle:
 192:motorctrl.c   ****      return getMotorMaxAngle(&motors[TILT_MOTOR]);
 769               	.LM37:
 770               	.LFBB8:
 771               	/* prologue: function */
 772               	/* frame size = 0 */
 773               	/* stack size = 0 */
 774               	.L__stack_usage = 0
 775               	.LBB100:
 776               	.LBB101:
 454:motorctrl.c   **** }
 455:motorctrl.c   **** 
 456:motorctrl.c   **** float getMotorMaxAngle(volatile motor *m){
 457:motorctrl.c   ****     return m->min_angle + m->angle_range;
 778               	.LM38:
 779 0454 6091 0000 		lds r22,motors+147
 780 0458 7091 0000 		lds r23,motors+147+1
 781 045c 8091 0000 		lds r24,motors+147+2
 782 0460 9091 0000 		lds r25,motors+147+3
 783 0464 2091 0000 		lds r18,motors+151
 784 0468 3091 0000 		lds r19,motors+151+1
 785 046c 4091 0000 		lds r20,motors+151+2
 786 0470 5091 0000 		lds r21,motors+151+3
 787 0474 0E94 0000 		call __addsf3
 788               	.LBE101:
 789               	.LBE100:
 194:motorctrl.c   **** 
 791               	.LM39:
 792 0478 0895      		ret
 794               	.Lscope8:
 796               	.global	getAngleMotorMaxAngle
 798               	getAngleMotorMaxAngle:
 196:motorctrl.c   ****      return getMotorMaxAngle(&motors[ANGLE_MOTOR]);
 800               	.LM40:
 801               	.LFBB9:
 802               	/* prologue: function */
 803               	/* frame size = 0 */
 804               	/* stack size = 0 */
 805               	.L__stack_usage = 0
 806               	.LBB102:
 807               	.LBB103:
 809               	.LM41:
 810 047a E0E0      		ldi r30,lo8(motors)
 811 047c F0E0      		ldi r31,hi8(motors)
 812 047e 67A5      		ldd r22,Z+47
 813 0480 70A9      		ldd r23,Z+48
 814 0482 81A9      		ldd r24,Z+49
 815 0484 92A9      		ldd r25,Z+50
 816 0486 23A9      		ldd r18,Z+51
 817 0488 34A9      		ldd r19,Z+52
 818 048a 45A9      		ldd r20,Z+53
 819 048c 56A9      		ldd r21,Z+54
 820 048e 0E94 0000 		call __addsf3
 821               	.LBE103:
 822               	.LBE102:
 198:motorctrl.c   **** 
 824               	.LM42:
 825 0492 0895      		ret
 827               	.Lscope9:
 829               	.global	getTiltActuatorCurrentLength
 831               	getTiltActuatorCurrentLength:
 200:motorctrl.c   ****     return motors[TILT_MOTOR].current_length;
 833               	.LM43:
 834               	.LFBB10:
 835               	/* prologue: function */
 836               	/* frame size = 0 */
 837               	/* stack size = 0 */
 838               	.L__stack_usage = 0
 201:motorctrl.c   **** }
 840               	.LM44:
 841 0494 8091 0000 		lds r24,motors+135
 842 0498 9091 0000 		lds r25,motors+135+1
 202:motorctrl.c   **** 
 844               	.LM45:
 845 049c 0895      		ret
 847               	.Lscope10:
 849               	.global	getAngleActuatorCurrentLength
 851               	getAngleActuatorCurrentLength:
 204:motorctrl.c   ****     return motors[ANGLE_MOTOR].current_length;
 853               	.LM46:
 854               	.LFBB11:
 855               	/* prologue: function */
 856               	/* frame size = 0 */
 857               	/* stack size = 0 */
 858               	.L__stack_usage = 0
 205:motorctrl.c   **** }
 860               	.LM47:
 861 049e 8091 0000 		lds r24,motors+35
 862 04a2 9091 0000 		lds r25,motors+35+1
 206:motorctrl.c   **** 
 864               	.LM48:
 865 04a6 0895      		ret
 867               	.Lscope11:
 869               	.global	getTiltActuatorSetLength
 871               	getTiltActuatorSetLength:
 208:motorctrl.c   ****     return motors[TILT_MOTOR].set_length;
 873               	.LM49:
 874               	.LFBB12:
 875               	/* prologue: function */
 876               	/* frame size = 0 */
 877               	/* stack size = 0 */
 878               	.L__stack_usage = 0
 209:motorctrl.c   **** }
 880               	.LM50:
 881 04a8 8091 0000 		lds r24,motors+137
 882 04ac 9091 0000 		lds r25,motors+137+1
 210:motorctrl.c   **** 
 884               	.LM51:
 885 04b0 0895      		ret
 887               	.Lscope12:
 889               	.global	getAngleActuatorSetLength
 891               	getAngleActuatorSetLength:
 212:motorctrl.c   ****     return motors[ANGLE_MOTOR].set_length;
 893               	.LM52:
 894               	.LFBB13:
 895               	/* prologue: function */
 896               	/* frame size = 0 */
 897               	/* stack size = 0 */
 898               	.L__stack_usage = 0
 213:motorctrl.c   **** }
 900               	.LM53:
 901 04b2 8091 0000 		lds r24,motors+37
 902 04b6 9091 0000 		lds r25,motors+37+1
 214:motorctrl.c   **** 
 904               	.LM54:
 905 04ba 0895      		ret
 907               	.Lscope13:
 909               	.global	getAngle
 911               	getAngle:
 216:motorctrl.c   ****     return getMotorPosition(&motors[ANGLE_MOTOR]);
 913               	.LM55:
 914               	.LFBB14:
 915 04bc CF93      		push r28
 916 04be DF93      		push r29
 917               	/* prologue: function */
 918               	/* frame size = 0 */
 919               	/* stack size = 2 */
 920               	.L__stack_usage = 2
 921               	.LBB104:
 922               	.LBB105:
 301:motorctrl.c   ****     return m->angle_reference + aoffset;
 924               	.LM56:
 925 04c0 C0E0      		ldi r28,lo8(motors)
 926 04c2 D0E0      		ldi r29,hi8(motors)
 927 04c4 E091 0000 		lds r30,motors+80
 928 04c8 F091 0000 		lds r31,motors+80+1
 929 04cc 8BA1      		ldd r24,Y+35
 930 04ce 9CA1      		ldd r25,Y+36
 931 04d0 0995      		icall
 302:motorctrl.c   ****     /*
 933               	.LM57:
 934 04d2 2FA9      		ldd r18,Y+55
 935 04d4 38AD      		ldd r19,Y+56
 936 04d6 49AD      		ldd r20,Y+57
 937 04d8 5AAD      		ldd r21,Y+58
 938 04da 0E94 0000 		call __addsf3
 939               	/* epilogue start */
 940               	.LBE105:
 941               	.LBE104:
 218:motorctrl.c   **** 
 943               	.LM58:
 944 04de DF91      		pop r29
 945 04e0 CF91      		pop r28
 946 04e2 0895      		ret
 951               	.Lscope14:
 953               	.global	getTilt
 955               	getTilt:
 220:motorctrl.c   ****     return getMotorPosition(&motors[TILT_MOTOR]);
 957               	.LM59:
 958               	.LFBB15:
 959               	/* prologue: function */
 960               	/* frame size = 0 */
 961               	/* stack size = 0 */
 962               	.L__stack_usage = 0
 963               	.LBB106:
 964               	.LBB107:
 301:motorctrl.c   ****     return m->angle_reference + aoffset;
 966               	.LM60:
 967 04e4 E091 0000 		lds r30,motors+180
 968 04e8 F091 0000 		lds r31,motors+180+1
 969 04ec 8091 0000 		lds r24,motors+135
 970 04f0 9091 0000 		lds r25,motors+135+1
 971 04f4 0995      		icall
 302:motorctrl.c   ****     /*
 973               	.LM61:
 974 04f6 2091 0000 		lds r18,motors+155
 975 04fa 3091 0000 		lds r19,motors+155+1
 976 04fe 4091 0000 		lds r20,motors+155+2
 977 0502 5091 0000 		lds r21,motors+155+3
 978 0506 0E94 0000 		call __addsf3
 979               	.LBE107:
 980               	.LBE106:
 222:motorctrl.c   **** 
 982               	.LM62:
 983 050a 0895      		ret
 988               	.Lscope15:
 990               	.global	getSetAngle
 992               	getSetAngle:
 225:motorctrl.c   ****     return getMotorSetPosition(&motors[ANGLE_MOTOR]);
 994               	.LM63:
 995               	.LFBB16:
 996 050c CF93      		push r28
 997 050e DF93      		push r29
 998               	/* prologue: function */
 999               	/* frame size = 0 */
 1000               	/* stack size = 2 */
 1001               	.L__stack_usage = 2
 1002               	.LBB108:
 1003               	.LBB109:
 315:motorctrl.c   ****     return m->angle_reference + aoffset;
 1005               	.LM64:
 1006 0510 C0E0      		ldi r28,lo8(motors)
 1007 0512 D0E0      		ldi r29,hi8(motors)
 1008 0514 E091 0000 		lds r30,motors+80
 1009 0518 F091 0000 		lds r31,motors+80+1
 1010 051c 8DA1      		ldd r24,Y+37
 1011 051e 9EA1      		ldd r25,Y+38
 1012 0520 0995      		icall
 316:motorctrl.c   **** }
 1014               	.LM65:
 1015 0522 2FA9      		ldd r18,Y+55
 1016 0524 38AD      		ldd r19,Y+56
 1017 0526 49AD      		ldd r20,Y+57
 1018 0528 5AAD      		ldd r21,Y+58
 1019 052a 0E94 0000 		call __addsf3
 1020               	/* epilogue start */
 1021               	.LBE109:
 1022               	.LBE108:
 227:motorctrl.c   **** 
 1024               	.LM66:
 1025 052e DF91      		pop r29
 1026 0530 CF91      		pop r28
 1027 0532 0895      		ret
 1032               	.Lscope16:
 1034               	.global	getSetTilt
 1036               	getSetTilt:
 230:motorctrl.c   ****     return getMotorSetPosition(&motors[TILT_MOTOR]);
 1038               	.LM67:
 1039               	.LFBB17:
 1040               	/* prologue: function */
 1041               	/* frame size = 0 */
 1042               	/* stack size = 0 */
 1043               	.L__stack_usage = 0
 1044               	.LBB110:
 1045               	.LBB111:
 315:motorctrl.c   ****     return m->angle_reference + aoffset;
 1047               	.LM68:
 1048 0534 E091 0000 		lds r30,motors+180
 1049 0538 F091 0000 		lds r31,motors+180+1
 1050 053c 8091 0000 		lds r24,motors+137
 1051 0540 9091 0000 		lds r25,motors+137+1
 1052 0544 0995      		icall
 316:motorctrl.c   **** }
 1054               	.LM69:
 1055 0546 2091 0000 		lds r18,motors+155
 1056 054a 3091 0000 		lds r19,motors+155+1
 1057 054e 4091 0000 		lds r20,motors+155+2
 1058 0552 5091 0000 		lds r21,motors+155+3
 1059 0556 0E94 0000 		call __addsf3
 1060               	.LBE111:
 1061               	.LBE110:
 232:motorctrl.c   **** 
 1063               	.LM70:
 1064 055a 0895      		ret
 1069               	.Lscope17:
 1070               	.global	__gesf2
 1071               	.global	__lesf2
 1072               	.global	__gtsf2
 1073               	.global	__ltsf2
 1076               	.global	setAngle
 1078               	setAngle:
 235:motorctrl.c   ****     return setMotorPosition(&motors[ANGLE_MOTOR], angle);
 1080               	.LM71:
 1081               	.LFBB18:
 1082 055c 8F92      		push r8
 1083 055e 9F92      		push r9
 1084 0560 AF92      		push r10
 1085 0562 BF92      		push r11
 1086 0564 CF92      		push r12
 1087 0566 DF92      		push r13
 1088 0568 EF92      		push r14
 1089 056a FF92      		push r15
 1090               	/* prologue: function */
 1091               	/* frame size = 0 */
 1092               	/* stack size = 8 */
 1093               	.L__stack_usage = 8
 1094 056c 6B01      		movw r12,r22
 1095 056e 7C01      		movw r14,r24
 1096               	.LBB127:
 1097               	.LBB128:
 392:motorctrl.c   ****     //vefify that angle is in between valid range
 1099               	.LM72:
 1100 0570 86E0      		ldi r24,lo8(6)
 1101 0572 8093 0000 		sts motors+79,r24
 394:motorctrl.c   ****         m->timeout_value = 0; //Clear timeout value on every angle change
 1103               	.LM73:
 1104 0576 2091 0000 		lds r18,motors+47
 1105 057a 3091 0000 		lds r19,motors+47+1
 1106 057e 4091 0000 		lds r20,motors+47+2
 1107 0582 5091 0000 		lds r21,motors+47+3
 1108 0586 C701      		movw r24,r14
 1109 0588 B601      		movw r22,r12
 1110 058a 0E94 0000 		call __gesf2
 1111 058e 87FD      		sbrc r24,7
 1112 0590 00C0      		rjmp .L19
 1113 0592 6091 0000 		lds r22,motors+47
 1114 0596 7091 0000 		lds r23,motors+47+1
 1115 059a 8091 0000 		lds r24,motors+47+2
 1116 059e 9091 0000 		lds r25,motors+47+3
 1117 05a2 2091 0000 		lds r18,motors+51
 1118 05a6 3091 0000 		lds r19,motors+51+1
 1119 05aa 4091 0000 		lds r20,motors+51+2
 1120 05ae 5091 0000 		lds r21,motors+51+3
 1121 05b2 0E94 0000 		call __addsf3
 1122 05b6 9B01      		movw r18,r22
 1123 05b8 AC01      		movw r20,r24
 1124 05ba C701      		movw r24,r14
 1125 05bc B601      		movw r22,r12
 1126 05be 0E94 0000 		call __lesf2
 1127 05c2 1816      		cp __zero_reg__,r24
 1128 05c4 04F0      		brlt .+2
 1129 05c6 00C0      		rjmp .L43
 1130               	.L19:
 420:motorctrl.c   ****         uint16_t newlen = m->angle_to_length((m->min_angle+m->angle_range) - m->angle_reference); 
 1132               	.LM74:
 1133 05c8 6091 0000 		lds r22,motors+47
 1134 05cc 7091 0000 		lds r23,motors+47+1
 1135 05d0 8091 0000 		lds r24,motors+47+2
 1136 05d4 9091 0000 		lds r25,motors+47+3
 1137 05d8 2091 0000 		lds r18,motors+51
 1138 05dc 3091 0000 		lds r19,motors+51+1
 1139 05e0 4091 0000 		lds r20,motors+51+2
 1140 05e4 5091 0000 		lds r21,motors+51+3
 1141 05e8 0E94 0000 		call __addsf3
 1142 05ec 9B01      		movw r18,r22
 1143 05ee AC01      		movw r20,r24
 1144 05f0 C701      		movw r24,r14
 1145 05f2 B601      		movw r22,r12
 1146 05f4 0E94 0000 		call __gtsf2
 1147 05f8 1816      		cp __zero_reg__,r24
 1148 05fa 04F4      		brge .+2
 1149 05fc 00C0      		rjmp .L44
 428:motorctrl.c   ****         uint16_t newlen = m->angle_to_length(m->min_angle - m->angle_reference); 
 1151               	.LM75:
 1152 05fe 2091 0000 		lds r18,motors+47
 1153 0602 3091 0000 		lds r19,motors+47+1
 1154 0606 4091 0000 		lds r20,motors+47+2
 1155 060a 5091 0000 		lds r21,motors+47+3
 1156 060e C701      		movw r24,r14
 1157 0610 B601      		movw r22,r12
 1158 0612 0E94 0000 		call __ltsf2
 1159 0616 87FD      		sbrc r24,7
 1160 0618 00C0      		rjmp .L45
 1161               	.L31:
 435:motorctrl.c   ****     
 1163               	.LM76:
 1164 061a 1092 0000 		sts motors+75,__zero_reg__
 1165 061e 1092 0000 		sts motors+75+1,__zero_reg__
 1166 0622 1092 0000 		sts motors+75+2,__zero_reg__
 1167 0626 1092 0000 		sts motors+75+3,__zero_reg__
 1168               	.LBB129:
 1169               	.LBB130:
 444:motorctrl.c   ****          m->move_length_mm = m->set_length - m->current_length;
 1171               	.LM77:
 1172 062a 2091 0000 		lds r18,motors+35
 1173 062e 3091 0000 		lds r19,motors+35+1
 1174 0632 8091 0000 		lds r24,motors+37
 1175 0636 9091 0000 		lds r25,motors+37+1
 1176 063a 2817      		cp r18,r24
 1177 063c 3907      		cpc r19,r25
 1178 063e 00F0      		brlo .L46
 447:motorctrl.c   ****          m->move_length_mm = m->current_length - m->set_length;
 1180               	.LM78:
 1181 0640 2091 0000 		lds r18,motors+35
 1182 0644 3091 0000 		lds r19,motors+35+1
 1183 0648 8091 0000 		lds r24,motors+37
 1184 064c 9091 0000 		lds r25,motors+37+1
 1185 0650 8217      		cp r24,r18
 1186 0652 9307      		cpc r25,r19
 1187 0654 00F4      		brsh .L35
 1188               	.LBB131:
 1189               	.LBB132:
 448:motorctrl.c   ****      }
 1191               	.LM79:
 1192 0656 8091 0000 		lds r24,motors+35
 1193 065a 9091 0000 		lds r25,motors+35+1
 1194 065e 2091 0000 		lds r18,motors+37
 1195 0662 3091 0000 		lds r19,motors+37+1
 1196 0666 821B      		sub r24,r18
 1197 0668 930B      		sbc r25,r19
 1198 066a 9093 0000 		sts motors+98+1,r25
 1199 066e 8093 0000 		sts motors+98,r24
 1200               	.L35:
 1201               	.LBE132:
 1202               	.LBE131:
 1203               	.LBE130:
 1204               	.LBE129:
 438:motorctrl.c   ****     return 1;
 1206               	.LM80:
 1207 0672 1092 0000 		sts systick+1,__zero_reg__
 1208 0676 1092 0000 		sts systick,__zero_reg__
 439:motorctrl.c   **** }   
 1210               	.LM81:
 1211 067a 81E0      		ldi r24,lo8(1)
 1212               	.L27:
 1213               	/* epilogue start */
 1214               	.LBE128:
 1215               	.LBE127:
 237:motorctrl.c   **** 
 1217               	.LM82:
 1218 067c FF90      		pop r15
 1219 067e EF90      		pop r14
 1220 0680 DF90      		pop r13
 1221 0682 CF90      		pop r12
 1222 0684 BF90      		pop r11
 1223 0686 AF90      		pop r10
 1224 0688 9F90      		pop r9
 1225 068a 8F90      		pop r8
 1226 068c 0895      		ret
 1227               	.L46:
 1228               	.LBB149:
 1229               	.LBB148:
 1230               	.LBB134:
 1231               	.LBB133:
 445:motorctrl.c   ****      }
 1233               	.LM83:
 1234 068e 8091 0000 		lds r24,motors+37
 1235 0692 9091 0000 		lds r25,motors+37+1
 1236 0696 2091 0000 		lds r18,motors+35
 1237 069a 3091 0000 		lds r19,motors+35+1
 1238 069e 821B      		sub r24,r18
 1239 06a0 930B      		sbc r25,r19
 1240 06a2 9093 0000 		sts motors+98+1,r25
 1241 06a6 8093 0000 		sts motors+98,r24
 1242 06aa 00C0      		rjmp .L35
 1243               	.L44:
 1244               	.LBE133:
 1245               	.LBE134:
 1246               	.LBB135:
 421:motorctrl.c   ****         if (newlen > m->actuator_max_limit){
 1248               	.LM84:
 1249 06ac E090 0000 		lds r14,motors+88
 1250 06b0 F090 0000 		lds r15,motors+88+1
 1251 06b4 6091 0000 		lds r22,motors+47
 1252 06b8 7091 0000 		lds r23,motors+47+1
 1253 06bc 8091 0000 		lds r24,motors+47+2
 1254 06c0 9091 0000 		lds r25,motors+47+3
 1255 06c4 2091 0000 		lds r18,motors+51
 1256 06c8 3091 0000 		lds r19,motors+51+1
 1257 06cc 4091 0000 		lds r20,motors+51+2
 1258 06d0 5091 0000 		lds r21,motors+51+3
 1259 06d4 8090 0000 		lds r8,motors+55
 1260 06d8 9090 0000 		lds r9,motors+55+1
 1261 06dc A090 0000 		lds r10,motors+55+2
 1262 06e0 B090 0000 		lds r11,motors+55+3
 1263 06e4 0E94 0000 		call __addsf3
 1264 06e8 A501      		movw r20,r10
 1265 06ea 9401      		movw r18,r8
 1266 06ec 0E94 0000 		call __subsf3
 1267 06f0 F701      		movw r30,r14
 1268 06f2 0995      		icall
 422:motorctrl.c   ****             newlen = m->actuator_max_limit - 1;
 1270               	.LM85:
 1271 06f4 2091 0000 		lds r18,motors+69
 1272 06f8 3091 0000 		lds r19,motors+69+1
 1273 06fc 2817      		cp r18,r24
 1274 06fe 3907      		cpc r19,r25
 1275 0700 00F4      		brsh .L33
 423:motorctrl.c   ****         }
 1277               	.LM86:
 1278 0702 8091 0000 		lds r24,motors+69
 1279 0706 9091 0000 		lds r25,motors+69+1
 1280 070a 0197      		sbiw r24,1
 1281               	.L33:
 1282               	.LBE135:
 1283               	.LBB136:
 433:motorctrl.c   ****     }
 1285               	.LM87:
 1286 070c 9093 0000 		sts motors+37+1,r25
 1287 0710 8093 0000 		sts motors+37,r24
 1288 0714 00C0      		rjmp .L31
 1289               	.L45:
 429:motorctrl.c   ****         if (newlen < m->actuator_min_limit){
 1291               	.LM88:
 1292 0716 E090 0000 		lds r14,motors+88
 1293 071a F090 0000 		lds r15,motors+88+1
 1294 071e 6091 0000 		lds r22,motors+47
 1295 0722 7091 0000 		lds r23,motors+47+1
 1296 0726 8091 0000 		lds r24,motors+47+2
 1297 072a 9091 0000 		lds r25,motors+47+3
 1298 072e 2091 0000 		lds r18,motors+55
 1299 0732 3091 0000 		lds r19,motors+55+1
 1300 0736 4091 0000 		lds r20,motors+55+2
 1301 073a 5091 0000 		lds r21,motors+55+3
 1302 073e 0E94 0000 		call __subsf3
 1303 0742 F701      		movw r30,r14
 1304 0744 0995      		icall
 430:motorctrl.c   ****             newlen = m->actuator_min_limit + 1; 
 1306               	.LM89:
 1307 0746 2091 0000 		lds r18,motors+67
 1308 074a 3091 0000 		lds r19,motors+67+1
 1309 074e 8217      		cp r24,r18
 1310 0750 9307      		cpc r25,r19
 1311 0752 00F4      		brsh .L33
 431:motorctrl.c   ****         }
 1313               	.LM90:
 1314 0754 8091 0000 		lds r24,motors+67
 1315 0758 9091 0000 		lds r25,motors+67+1
 1316 075c 0196      		adiw r24,1
 1317 075e 00C0      		rjmp .L33
 1318               	.L43:
 1319               	.LBE136:
 1320               	.LBB137:
 395:motorctrl.c   ****         uint16_t len = m->angle_to_length(angle - m->angle_reference);
 1322               	.LM91:
 1323 0760 1092 0000 		sts motors+75,__zero_reg__
 1324 0764 1092 0000 		sts motors+75+1,__zero_reg__
 1325 0768 1092 0000 		sts motors+75+2,__zero_reg__
 1326 076c 1092 0000 		sts motors+75+3,__zero_reg__
 396:motorctrl.c   ****     
 1328               	.LM92:
 1329 0770 A090 0000 		lds r10,motors+88
 1330 0774 B090 0000 		lds r11,motors+88+1
 1331 0778 2091 0000 		lds r18,motors+55
 1332 077c 3091 0000 		lds r19,motors+55+1
 1333 0780 4091 0000 		lds r20,motors+55+2
 1334 0784 5091 0000 		lds r21,motors+55+3
 1335 0788 C701      		movw r24,r14
 1336 078a B601      		movw r22,r12
 1337 078c 0E94 0000 		call __subsf3
 1338 0790 F501      		movw r30,r10
 1339 0792 0995      		icall
 399:motorctrl.c   ****             uint16_t newlen = len + (m->length_hysteresis);
 1341               	.LM93:
 1342 0794 2091 0000 		lds r18,motors+37
 1343 0798 3091 0000 		lds r19,motors+37+1
 1344 079c 2817      		cp r18,r24
 1345 079e 3907      		cpc r19,r25
 1346 07a0 00F4      		brsh .L22
 1347               	.LBB138:
 400:motorctrl.c   ****             if (newlen > m->actuator_max_limit){
 1349               	.LM94:
 1350 07a2 2091 0000 		lds r18,motors+45
 1351 07a6 820F      		add r24,r18
 1352 07a8 911D      		adc r25,__zero_reg__
 401:motorctrl.c   ****                 newlen = m->actuator_max_limit-1;
 1354               	.LM95:
 1355 07aa 2091 0000 		lds r18,motors+69
 1356 07ae 3091 0000 		lds r19,motors+69+1
 1357 07b2 2817      		cp r18,r24
 1358 07b4 3907      		cpc r19,r25
 1359 07b6 00F4      		brsh .+2
 1360 07b8 00C0      		rjmp .L47
 1361               	.L25:
 1362               	.LBE138:
 1363               	.LBB139:
 411:motorctrl.c   ****         }
 1365               	.LM96:
 1366 07ba 9093 0000 		sts motors+37+1,r25
 1367 07be 8093 0000 		sts motors+37,r24
 1368               	.LBE139:
 1369               	.LBB140:
 1370               	.LBB141:
 444:motorctrl.c   ****          m->move_length_mm = m->set_length - m->current_length;
 1372               	.LM97:
 1373 07c2 2091 0000 		lds r18,motors+35
 1374 07c6 3091 0000 		lds r19,motors+35+1
 1375 07ca 8091 0000 		lds r24,motors+37
 1376 07ce 9091 0000 		lds r25,motors+37+1
 1377 07d2 2817      		cp r18,r24
 1378 07d4 3907      		cpc r19,r25
 1379 07d6 00F0      		brlo .L48
 447:motorctrl.c   ****          m->move_length_mm = m->current_length - m->set_length;
 1381               	.LM98:
 1382 07d8 2091 0000 		lds r18,motors+35
 1383 07dc 3091 0000 		lds r19,motors+35+1
 1384 07e0 8091 0000 		lds r24,motors+37
 1385 07e4 9091 0000 		lds r25,motors+37+1
 1386 07e8 8217      		cp r24,r18
 1387 07ea 9307      		cpc r25,r19
 1388 07ec 00F4      		brsh .L36
 1389               	.LBB142:
 1390               	.LBB143:
 448:motorctrl.c   ****      }
 1392               	.LM99:
 1393 07ee 8091 0000 		lds r24,motors+35
 1394 07f2 9091 0000 		lds r25,motors+35+1
 1395 07f6 2091 0000 		lds r18,motors+37
 1396 07fa 3091 0000 		lds r19,motors+37+1
 1397 07fe 821B      		sub r24,r18
 1398 0800 930B      		sbc r25,r19
 1399 0802 9093 0000 		sts motors+98+1,r25
 1400 0806 8093 0000 		sts motors+98,r24
 1401               	.LBE143:
 1402               	.LBE142:
 1403               	.LBE141:
 1404               	.LBE140:
 416:motorctrl.c   ****     }
 1406               	.LM100:
 1407 080a 80E0      		ldi r24,0
 1408 080c 00C0      		rjmp .L27
 1409               	.L22:
 1410               	.LBB145:
 407:motorctrl.c   ****             if (newlen < m->actuator_min_limit){
 1412               	.LM101:
 1413 080e 2091 0000 		lds r18,motors+45
 1414 0812 821B      		sub r24,r18
 1415 0814 9109      		sbc r25,__zero_reg__
 408:motorctrl.c   ****                 newlen = m->actuator_min_limit+1;
 1417               	.LM102:
 1418 0816 2091 0000 		lds r18,motors+67
 1419 081a 3091 0000 		lds r19,motors+67+1
 1420 081e 8217      		cp r24,r18
 1421 0820 9307      		cpc r25,r19
 1422 0822 00F4      		brsh .L25
 409:motorctrl.c   ****             }
 1424               	.LM103:
 1425 0824 8091 0000 		lds r24,motors+67
 1426 0828 9091 0000 		lds r25,motors+67+1
 1427 082c 0196      		adiw r24,1
 1428 082e 00C0      		rjmp .L25
 1429               	.L48:
 1430               	.LBE145:
 1431               	.LBB146:
 1432               	.LBB144:
 445:motorctrl.c   ****      }
 1434               	.LM104:
 1435 0830 8091 0000 		lds r24,motors+37
 1436 0834 9091 0000 		lds r25,motors+37+1
 1437 0838 2091 0000 		lds r18,motors+35
 1438 083c 3091 0000 		lds r19,motors+35+1
 1439 0840 821B      		sub r24,r18
 1440 0842 930B      		sbc r25,r19
 1441 0844 9093 0000 		sts motors+98+1,r25
 1442 0848 8093 0000 		sts motors+98,r24
 1443               	.LBE144:
 1444               	.LBE146:
 416:motorctrl.c   ****     }
 1446               	.LM105:
 1447 084c 80E0      		ldi r24,0
 1448 084e 00C0      		rjmp .L27
 1449               	.L47:
 1450               	.LBB147:
 402:motorctrl.c   ****             }
 1452               	.LM106:
 1453 0850 8091 0000 		lds r24,motors+69
 1454 0854 9091 0000 		lds r25,motors+69+1
 1455 0858 0197      		sbiw r24,1
 1456 085a 00C0      		rjmp .L25
 1457               	.L36:
 1458               	.LBE147:
 416:motorctrl.c   ****     }
 1460               	.LM107:
 1461 085c 80E0      		ldi r24,0
 1462 085e 00C0      		rjmp .L27
 1463               	.LBE137:
 1464               	.LBE148:
 1465               	.LBE149:
 1488               	.Lscope18:
 1491               	.global	setTilt
 1493               	setTilt:
 240:motorctrl.c   ****     return setMotorPosition(&motors[TILT_MOTOR], tilt);
 1495               	.LM108:
 1496               	.LFBB19:
 1497 0860 8F92      		push r8
 1498 0862 9F92      		push r9
 1499 0864 AF92      		push r10
 1500 0866 BF92      		push r11
 1501 0868 CF92      		push r12
 1502 086a DF92      		push r13
 1503 086c EF92      		push r14
 1504 086e FF92      		push r15
 1505               	/* prologue: function */
 1506               	/* frame size = 0 */
 1507               	/* stack size = 8 */
 1508               	.L__stack_usage = 8
 1509 0870 6B01      		movw r12,r22
 1510 0872 7C01      		movw r14,r24
 1511               	.LBB165:
 1512               	.LBB166:
 392:motorctrl.c   ****     //vefify that angle is in between valid range
 1514               	.LM109:
 1515 0874 86E0      		ldi r24,lo8(6)
 1516 0876 8093 0000 		sts motors+179,r24
 394:motorctrl.c   ****         m->timeout_value = 0; //Clear timeout value on every angle change
 1518               	.LM110:
 1519 087a 2091 0000 		lds r18,motors+147
 1520 087e 3091 0000 		lds r19,motors+147+1
 1521 0882 4091 0000 		lds r20,motors+147+2
 1522 0886 5091 0000 		lds r21,motors+147+3
 1523 088a C701      		movw r24,r14
 1524 088c B601      		movw r22,r12
 1525 088e 0E94 0000 		call __gesf2
 1526 0892 87FD      		sbrc r24,7
 1527 0894 00C0      		rjmp .L50
 1528 0896 6091 0000 		lds r22,motors+147
 1529 089a 7091 0000 		lds r23,motors+147+1
 1530 089e 8091 0000 		lds r24,motors+147+2
 1531 08a2 9091 0000 		lds r25,motors+147+3
 1532 08a6 2091 0000 		lds r18,motors+151
 1533 08aa 3091 0000 		lds r19,motors+151+1
 1534 08ae 4091 0000 		lds r20,motors+151+2
 1535 08b2 5091 0000 		lds r21,motors+151+3
 1536 08b6 0E94 0000 		call __addsf3
 1537 08ba 9B01      		movw r18,r22
 1538 08bc AC01      		movw r20,r24
 1539 08be C701      		movw r24,r14
 1540 08c0 B601      		movw r22,r12
 1541 08c2 0E94 0000 		call __lesf2
 1542 08c6 1816      		cp __zero_reg__,r24
 1543 08c8 04F0      		brlt .+2
 1544 08ca 00C0      		rjmp .L73
 1545               	.L50:
 420:motorctrl.c   ****         uint16_t newlen = m->angle_to_length((m->min_angle+m->angle_range) - m->angle_reference); 
 1547               	.LM111:
 1548 08cc 6091 0000 		lds r22,motors+147
 1549 08d0 7091 0000 		lds r23,motors+147+1
 1550 08d4 8091 0000 		lds r24,motors+147+2
 1551 08d8 9091 0000 		lds r25,motors+147+3
 1552 08dc 2091 0000 		lds r18,motors+151
 1553 08e0 3091 0000 		lds r19,motors+151+1
 1554 08e4 4091 0000 		lds r20,motors+151+2
 1555 08e8 5091 0000 		lds r21,motors+151+3
 1556 08ec 0E94 0000 		call __addsf3
 1557 08f0 9B01      		movw r18,r22
 1558 08f2 AC01      		movw r20,r24
 1559 08f4 C701      		movw r24,r14
 1560 08f6 B601      		movw r22,r12
 1561 08f8 0E94 0000 		call __gtsf2
 1562 08fc 1816      		cp __zero_reg__,r24
 1563 08fe 04F4      		brge .+2
 1564 0900 00C0      		rjmp .L74
 428:motorctrl.c   ****         uint16_t newlen = m->angle_to_length(m->min_angle - m->angle_reference); 
 1566               	.LM112:
 1567 0902 2091 0000 		lds r18,motors+147
 1568 0906 3091 0000 		lds r19,motors+147+1
 1569 090a 4091 0000 		lds r20,motors+147+2
 1570 090e 5091 0000 		lds r21,motors+147+3
 1571 0912 C701      		movw r24,r14
 1572 0914 B601      		movw r22,r12
 1573 0916 0E94 0000 		call __ltsf2
 1574 091a 87FD      		sbrc r24,7
 1575 091c 00C0      		rjmp .L75
 1576               	.L62:
 435:motorctrl.c   ****     
 1578               	.LM113:
 1579 091e 1092 0000 		sts motors+175,__zero_reg__
 1580 0922 1092 0000 		sts motors+175+1,__zero_reg__
 1581 0926 1092 0000 		sts motors+175+2,__zero_reg__
 1582 092a 1092 0000 		sts motors+175+3,__zero_reg__
 1583               	.LBB167:
 1584               	.LBB168:
 444:motorctrl.c   ****          m->move_length_mm = m->set_length - m->current_length;
 1586               	.LM114:
 1587 092e 2091 0000 		lds r18,motors+135
 1588 0932 3091 0000 		lds r19,motors+135+1
 1589 0936 8091 0000 		lds r24,motors+137
 1590 093a 9091 0000 		lds r25,motors+137+1
 1591 093e 2817      		cp r18,r24
 1592 0940 3907      		cpc r19,r25
 1593 0942 00F0      		brlo .L76
 447:motorctrl.c   ****          m->move_length_mm = m->current_length - m->set_length;
 1595               	.LM115:
 1596 0944 2091 0000 		lds r18,motors+135
 1597 0948 3091 0000 		lds r19,motors+135+1
 1598 094c 8091 0000 		lds r24,motors+137
 1599 0950 9091 0000 		lds r25,motors+137+1
 1600 0954 8217      		cp r24,r18
 1601 0956 9307      		cpc r25,r19
 1602 0958 00F4      		brsh .L66
 1603               	.LBB169:
 1604               	.LBB170:
 448:motorctrl.c   ****      }
 1606               	.LM116:
 1607 095a 8091 0000 		lds r24,motors+135
 1608 095e 9091 0000 		lds r25,motors+135+1
 1609 0962 2091 0000 		lds r18,motors+137
 1610 0966 3091 0000 		lds r19,motors+137+1
 1611 096a 821B      		sub r24,r18
 1612 096c 930B      		sbc r25,r19
 1613 096e 9093 0000 		sts motors+198+1,r25
 1614 0972 8093 0000 		sts motors+198,r24
 1615               	.L66:
 1616               	.LBE170:
 1617               	.LBE169:
 1618               	.LBE168:
 1619               	.LBE167:
 438:motorctrl.c   ****     return 1;
 1621               	.LM117:
 1622 0976 1092 0000 		sts systick+1,__zero_reg__
 1623 097a 1092 0000 		sts systick,__zero_reg__
 439:motorctrl.c   **** }   
 1625               	.LM118:
 1626 097e 81E0      		ldi r24,lo8(1)
 1627               	.L58:
 1628               	/* epilogue start */
 1629               	.LBE166:
 1630               	.LBE165:
 242:motorctrl.c   **** 
 1632               	.LM119:
 1633 0980 FF90      		pop r15
 1634 0982 EF90      		pop r14
 1635 0984 DF90      		pop r13
 1636 0986 CF90      		pop r12
 1637 0988 BF90      		pop r11
 1638 098a AF90      		pop r10
 1639 098c 9F90      		pop r9
 1640 098e 8F90      		pop r8
 1641 0990 0895      		ret
 1642               	.L76:
 1643               	.LBB187:
 1644               	.LBB186:
 1645               	.LBB172:
 1646               	.LBB171:
 445:motorctrl.c   ****      }
 1648               	.LM120:
 1649 0992 8091 0000 		lds r24,motors+137
 1650 0996 9091 0000 		lds r25,motors+137+1
 1651 099a 2091 0000 		lds r18,motors+135
 1652 099e 3091 0000 		lds r19,motors+135+1
 1653 09a2 821B      		sub r24,r18
 1654 09a4 930B      		sbc r25,r19
 1655 09a6 9093 0000 		sts motors+198+1,r25
 1656 09aa 8093 0000 		sts motors+198,r24
 1657 09ae 00C0      		rjmp .L66
 1658               	.L74:
 1659               	.LBE171:
 1660               	.LBE172:
 1661               	.LBB173:
 421:motorctrl.c   ****         if (newlen > m->actuator_max_limit){
 1663               	.LM121:
 1664 09b0 E090 0000 		lds r14,motors+188
 1665 09b4 F090 0000 		lds r15,motors+188+1
 1666 09b8 6091 0000 		lds r22,motors+147
 1667 09bc 7091 0000 		lds r23,motors+147+1
 1668 09c0 8091 0000 		lds r24,motors+147+2
 1669 09c4 9091 0000 		lds r25,motors+147+3
 1670 09c8 2091 0000 		lds r18,motors+151
 1671 09cc 3091 0000 		lds r19,motors+151+1
 1672 09d0 4091 0000 		lds r20,motors+151+2
 1673 09d4 5091 0000 		lds r21,motors+151+3
 1674 09d8 8090 0000 		lds r8,motors+155
 1675 09dc 9090 0000 		lds r9,motors+155+1
 1676 09e0 A090 0000 		lds r10,motors+155+2
 1677 09e4 B090 0000 		lds r11,motors+155+3
 1678 09e8 0E94 0000 		call __addsf3
 1679 09ec A501      		movw r20,r10
 1680 09ee 9401      		movw r18,r8
 1681 09f0 0E94 0000 		call __subsf3
 1682 09f4 F701      		movw r30,r14
 1683 09f6 0995      		icall
 422:motorctrl.c   ****             newlen = m->actuator_max_limit - 1;
 1685               	.LM122:
 1686 09f8 2091 0000 		lds r18,motors+169
 1687 09fc 3091 0000 		lds r19,motors+169+1
 1688 0a00 2817      		cp r18,r24
 1689 0a02 3907      		cpc r19,r25
 1690 0a04 00F4      		brsh .L64
 423:motorctrl.c   ****         }
 1692               	.LM123:
 1693 0a06 8091 0000 		lds r24,motors+169
 1694 0a0a 9091 0000 		lds r25,motors+169+1
 1695 0a0e 0197      		sbiw r24,1
 1696               	.L64:
 1697               	.LBE173:
 1698               	.LBB174:
 433:motorctrl.c   ****     }
 1700               	.LM124:
 1701 0a10 9093 0000 		sts motors+137+1,r25
 1702 0a14 8093 0000 		sts motors+137,r24
 1703 0a18 00C0      		rjmp .L62
 1704               	.L75:
 429:motorctrl.c   ****         if (newlen < m->actuator_min_limit){
 1706               	.LM125:
 1707 0a1a E090 0000 		lds r14,motors+188
 1708 0a1e F090 0000 		lds r15,motors+188+1
 1709 0a22 6091 0000 		lds r22,motors+147
 1710 0a26 7091 0000 		lds r23,motors+147+1
 1711 0a2a 8091 0000 		lds r24,motors+147+2
 1712 0a2e 9091 0000 		lds r25,motors+147+3
 1713 0a32 2091 0000 		lds r18,motors+155
 1714 0a36 3091 0000 		lds r19,motors+155+1
 1715 0a3a 4091 0000 		lds r20,motors+155+2
 1716 0a3e 5091 0000 		lds r21,motors+155+3
 1717 0a42 0E94 0000 		call __subsf3
 1718 0a46 F701      		movw r30,r14
 1719 0a48 0995      		icall
 430:motorctrl.c   ****             newlen = m->actuator_min_limit + 1; 
 1721               	.LM126:
 1722 0a4a 2091 0000 		lds r18,motors+167
 1723 0a4e 3091 0000 		lds r19,motors+167+1
 1724 0a52 8217      		cp r24,r18
 1725 0a54 9307      		cpc r25,r19
 1726 0a56 00F4      		brsh .L64
 431:motorctrl.c   ****         }
 1728               	.LM127:
 1729 0a58 8091 0000 		lds r24,motors+167
 1730 0a5c 9091 0000 		lds r25,motors+167+1
 1731 0a60 0196      		adiw r24,1
 1732 0a62 00C0      		rjmp .L64
 1733               	.L73:
 1734               	.LBE174:
 1735               	.LBB175:
 395:motorctrl.c   ****         uint16_t len = m->angle_to_length(angle - m->angle_reference);
 1737               	.LM128:
 1738 0a64 1092 0000 		sts motors+175,__zero_reg__
 1739 0a68 1092 0000 		sts motors+175+1,__zero_reg__
 1740 0a6c 1092 0000 		sts motors+175+2,__zero_reg__
 1741 0a70 1092 0000 		sts motors+175+3,__zero_reg__
 396:motorctrl.c   ****     
 1743               	.LM129:
 1744 0a74 A090 0000 		lds r10,motors+188
 1745 0a78 B090 0000 		lds r11,motors+188+1
 1746 0a7c 2091 0000 		lds r18,motors+155
 1747 0a80 3091 0000 		lds r19,motors+155+1
 1748 0a84 4091 0000 		lds r20,motors+155+2
 1749 0a88 5091 0000 		lds r21,motors+155+3
 1750 0a8c C701      		movw r24,r14
 1751 0a8e B601      		movw r22,r12
 1752 0a90 0E94 0000 		call __subsf3
 1753 0a94 F501      		movw r30,r10
 1754 0a96 0995      		icall
 399:motorctrl.c   ****             uint16_t newlen = len + (m->length_hysteresis);
 1756               	.LM130:
 1757 0a98 2091 0000 		lds r18,motors+137
 1758 0a9c 3091 0000 		lds r19,motors+137+1
 1759 0aa0 2817      		cp r18,r24
 1760 0aa2 3907      		cpc r19,r25
 1761 0aa4 00F4      		brsh .L53
 1762               	.LBB176:
 400:motorctrl.c   ****             if (newlen > m->actuator_max_limit){
 1764               	.LM131:
 1765 0aa6 2091 0000 		lds r18,motors+145
 1766 0aaa 820F      		add r24,r18
 1767 0aac 911D      		adc r25,__zero_reg__
 401:motorctrl.c   ****                 newlen = m->actuator_max_limit-1;
 1769               	.LM132:
 1770 0aae 2091 0000 		lds r18,motors+169
 1771 0ab2 3091 0000 		lds r19,motors+169+1
 1772 0ab6 2817      		cp r18,r24
 1773 0ab8 3907      		cpc r19,r25
 1774 0aba 00F4      		brsh .+2
 1775 0abc 00C0      		rjmp .L77
 1776               	.L56:
 1777               	.LBE176:
 1778               	.LBB177:
 411:motorctrl.c   ****         }
 1780               	.LM133:
 1781 0abe 9093 0000 		sts motors+137+1,r25
 1782 0ac2 8093 0000 		sts motors+137,r24
 1783               	.LBE177:
 1784               	.LBB178:
 1785               	.LBB179:
 444:motorctrl.c   ****          m->move_length_mm = m->set_length - m->current_length;
 1787               	.LM134:
 1788 0ac6 2091 0000 		lds r18,motors+135
 1789 0aca 3091 0000 		lds r19,motors+135+1
 1790 0ace 8091 0000 		lds r24,motors+137
 1791 0ad2 9091 0000 		lds r25,motors+137+1
 1792 0ad6 2817      		cp r18,r24
 1793 0ad8 3907      		cpc r19,r25
 1794 0ada 00F0      		brlo .L78
 447:motorctrl.c   ****          m->move_length_mm = m->current_length - m->set_length;
 1796               	.LM135:
 1797 0adc 2091 0000 		lds r18,motors+135
 1798 0ae0 3091 0000 		lds r19,motors+135+1
 1799 0ae4 8091 0000 		lds r24,motors+137
 1800 0ae8 9091 0000 		lds r25,motors+137+1
 1801 0aec 8217      		cp r24,r18
 1802 0aee 9307      		cpc r25,r19
 1803 0af0 00F4      		brsh .L67
 1804               	.LBB180:
 1805               	.LBB181:
 448:motorctrl.c   ****      }
 1807               	.LM136:
 1808 0af2 8091 0000 		lds r24,motors+135
 1809 0af6 9091 0000 		lds r25,motors+135+1
 1810 0afa 2091 0000 		lds r18,motors+137
 1811 0afe 3091 0000 		lds r19,motors+137+1
 1812 0b02 821B      		sub r24,r18
 1813 0b04 930B      		sbc r25,r19
 1814 0b06 9093 0000 		sts motors+198+1,r25
 1815 0b0a 8093 0000 		sts motors+198,r24
 1816               	.LBE181:
 1817               	.LBE180:
 1818               	.LBE179:
 1819               	.LBE178:
 416:motorctrl.c   ****     }
 1821               	.LM137:
 1822 0b0e 80E0      		ldi r24,0
 1823 0b10 00C0      		rjmp .L58
 1824               	.L53:
 1825               	.LBB183:
 407:motorctrl.c   ****             if (newlen < m->actuator_min_limit){
 1827               	.LM138:
 1828 0b12 2091 0000 		lds r18,motors+145
 1829 0b16 821B      		sub r24,r18
 1830 0b18 9109      		sbc r25,__zero_reg__
 408:motorctrl.c   ****                 newlen = m->actuator_min_limit+1;
 1832               	.LM139:
 1833 0b1a 2091 0000 		lds r18,motors+167
 1834 0b1e 3091 0000 		lds r19,motors+167+1
 1835 0b22 8217      		cp r24,r18
 1836 0b24 9307      		cpc r25,r19
 1837 0b26 00F4      		brsh .L56
 409:motorctrl.c   ****             }
 1839               	.LM140:
 1840 0b28 8091 0000 		lds r24,motors+167
 1841 0b2c 9091 0000 		lds r25,motors+167+1
 1842 0b30 0196      		adiw r24,1
 1843 0b32 00C0      		rjmp .L56
 1844               	.L78:
 1845               	.LBE183:
 1846               	.LBB184:
 1847               	.LBB182:
 445:motorctrl.c   ****      }
 1849               	.LM141:
 1850 0b34 8091 0000 		lds r24,motors+137
 1851 0b38 9091 0000 		lds r25,motors+137+1
 1852 0b3c 2091 0000 		lds r18,motors+135
 1853 0b40 3091 0000 		lds r19,motors+135+1
 1854 0b44 821B      		sub r24,r18
 1855 0b46 930B      		sbc r25,r19
 1856 0b48 9093 0000 		sts motors+198+1,r25
 1857 0b4c 8093 0000 		sts motors+198,r24
 1858               	.LBE182:
 1859               	.LBE184:
 416:motorctrl.c   ****     }
 1861               	.LM142:
 1862 0b50 80E0      		ldi r24,0
 1863 0b52 00C0      		rjmp .L58
 1864               	.L77:
 1865               	.LBB185:
 402:motorctrl.c   ****             }
 1867               	.LM143:
 1868 0b54 8091 0000 		lds r24,motors+169
 1869 0b58 9091 0000 		lds r25,motors+169+1
 1870 0b5c 0197      		sbiw r24,1
 1871 0b5e 00C0      		rjmp .L56
 1872               	.L67:
 1873               	.LBE185:
 416:motorctrl.c   ****     }
 1875               	.LM144:
 1876 0b60 80E0      		ldi r24,0
 1877 0b62 00C0      		rjmp .L58
 1878               	.LBE175:
 1879               	.LBE186:
 1880               	.LBE187:
 1903               	.Lscope19:
 1906               	.global	setTiltMotorLength
 1908               	setTiltMotorLength:
 244:motorctrl.c   ****     return setMotorLength(&motors[TILT_MOTOR], length);
 1910               	.LM145:
 1911               	.LFBB20:
 1912               	/* prologue: function */
 1913               	/* frame size = 0 */
 1914               	/* stack size = 0 */
 1915               	.L__stack_usage = 0
 1916               	.LBB196:
 1917               	.LBB197:
 458:motorctrl.c   **** }
 459:motorctrl.c   ****  
 460:motorctrl.c   **** /*
 461:motorctrl.c   ****     Shutdown all motors, this is used to activate manual mode
 462:motorctrl.c   **** */
 463:motorctrl.c   **** void shutdownMotors(void){
 464:motorctrl.c   ****     for (uint8_t i = 0; i<NUM_OF_MOTORS; i++){
 465:motorctrl.c   ****         disableMotorPWM(&motors[i]);
 466:motorctrl.c   ****         motors[i].set_length = motors[i].current_length;
 467:motorctrl.c   ****     }
 468:motorctrl.c   **** }
 469:motorctrl.c   **** 
 470:motorctrl.c   **** uint8_t setMotorLength(volatile motor *m, uint16_t length){
 471:motorctrl.c   ****     if (length >= m->actuator_min_limit && length <= m->actuator_max_limit){
 1919               	.LM146:
 1920 0b64 2091 0000 		lds r18,motors+167
 1921 0b68 3091 0000 		lds r19,motors+167+1
 1922 0b6c 8217      		cp r24,r18
 1923 0b6e 9307      		cpc r25,r19
 1924 0b70 00F0      		brlo .L85
 1925 0b72 2091 0000 		lds r18,motors+169
 1926 0b76 3091 0000 		lds r19,motors+169+1
 1927 0b7a 2817      		cp r18,r24
 1928 0b7c 3907      		cpc r19,r25
 1929 0b7e 00F0      		brlo .L85
 472:motorctrl.c   ****         //Execute move only if it is outside of hysteresis window
 473:motorctrl.c   ****         if (m->current_length > m->set_length + m->length_hysteresis){
 1931               	.LM147:
 1932 0b80 4091 0000 		lds r20,motors+135
 1933 0b84 5091 0000 		lds r21,motors+135+1
 1934 0b88 2091 0000 		lds r18,motors+137
 1935 0b8c 3091 0000 		lds r19,motors+137+1
 1936 0b90 6091 0000 		lds r22,motors+145
 1937 0b94 260F      		add r18,r22
 1938 0b96 311D      		adc r19,__zero_reg__
 1939 0b98 2417      		cp r18,r20
 1940 0b9a 3507      		cpc r19,r21
 1941 0b9c 00F4      		brsh .L86
 1942               	.LBB198:
 1943               	.LBB199:
 474:motorctrl.c   ****             if (m->current_length < m->set_length - m->length_hysteresis){ 
 1945               	.LM148:
 1946 0b9e 4091 0000 		lds r20,motors+135
 1947 0ba2 5091 0000 		lds r21,motors+135+1
 1948 0ba6 2091 0000 		lds r18,motors+137
 1949 0baa 3091 0000 		lds r19,motors+137+1
 1950 0bae 6091 0000 		lds r22,motors+145
 1951 0bb2 261B      		sub r18,r22
 1952 0bb4 3109      		sbc r19,__zero_reg__
 1953 0bb6 4217      		cp r20,r18
 1954 0bb8 5307      		cpc r21,r19
 1955 0bba 00F0      		brlo .L87
 1956               	.L86:
 1957               	.LBB200:
 1958               	.LBB201:
 1959               	.LBB202:
 1960               	.LBB203:
 448:motorctrl.c   ****      }
 1962               	.LM149:
 1963 0bbc 80E0      		ldi r24,0
 1964 0bbe 0895      		ret
 1965               	.L85:
 1966               	.LBE203:
 1967               	.LBE202:
 1968               	.LBE201:
 1969               	.LBE200:
 1970               	.LBE199:
 1971               	.LBE198:
 475:motorctrl.c   ****                 m->set_length = length;
 476:motorctrl.c   ****                 m->status = WAITING;
 477:motorctrl.c   **** 
 478:motorctrl.c   ****                 calculateMoveLength(m);
 479:motorctrl.c   ****             }
 480:motorctrl.c   ****         }
 481:motorctrl.c   ****         return 0;
 482:motorctrl.c   ****     }
 483:motorctrl.c   ****     else{
 484:motorctrl.c   ****         return 1;
 1973               	.LM150:
 1974 0bc0 81E0      		ldi r24,lo8(1)
 1975               	.LBE197:
 1976               	.LBE196:
 246:motorctrl.c   **** 
 1978               	.LM151:
 1979 0bc2 0895      		ret
 1980               	.L87:
 1981               	.LBB211:
 1982               	.LBB210:
 1983               	.LBB209:
 1984               	.LBB208:
 475:motorctrl.c   ****                 m->set_length = length;
 1986               	.LM152:
 1987 0bc4 9093 0000 		sts motors+137+1,r25
 1988 0bc8 8093 0000 		sts motors+137,r24
 476:motorctrl.c   **** 
 1990               	.LM153:
 1991 0bcc 86E0      		ldi r24,lo8(6)
 1992 0bce 8093 0000 		sts motors+179,r24
 1993               	.LBB207:
 1994               	.LBB206:
 444:motorctrl.c   ****          m->move_length_mm = m->set_length - m->current_length;
 1996               	.LM154:
 1997 0bd2 2091 0000 		lds r18,motors+135
 1998 0bd6 3091 0000 		lds r19,motors+135+1
 1999 0bda 8091 0000 		lds r24,motors+137
 2000 0bde 9091 0000 		lds r25,motors+137+1
 2001 0be2 2817      		cp r18,r24
 2002 0be4 3907      		cpc r19,r25
 2003 0be6 00F0      		brlo .L88
 447:motorctrl.c   ****          m->move_length_mm = m->current_length - m->set_length;
 2005               	.LM155:
 2006 0be8 2091 0000 		lds r18,motors+135
 2007 0bec 3091 0000 		lds r19,motors+135+1
 2008 0bf0 8091 0000 		lds r24,motors+137
 2009 0bf4 9091 0000 		lds r25,motors+137+1
 2010 0bf8 8217      		cp r24,r18
 2011 0bfa 9307      		cpc r25,r19
 2012 0bfc 00F4      		brsh .L86
 2013               	.LBB205:
 2014               	.LBB204:
 448:motorctrl.c   ****      }
 2016               	.LM156:
 2017 0bfe 8091 0000 		lds r24,motors+135
 2018 0c02 9091 0000 		lds r25,motors+135+1
 2019 0c06 2091 0000 		lds r18,motors+137
 2020 0c0a 3091 0000 		lds r19,motors+137+1
 2021 0c0e 821B      		sub r24,r18
 2022 0c10 930B      		sbc r25,r19
 2023 0c12 9093 0000 		sts motors+198+1,r25
 2024 0c16 8093 0000 		sts motors+198,r24
 2025 0c1a 00C0      		rjmp .L86
 2026               	.L88:
 2027               	.LBE204:
 2028               	.LBE205:
 445:motorctrl.c   ****      }
 2030               	.LM157:
 2031 0c1c 8091 0000 		lds r24,motors+137
 2032 0c20 9091 0000 		lds r25,motors+137+1
 2033 0c24 2091 0000 		lds r18,motors+135
 2034 0c28 3091 0000 		lds r19,motors+135+1
 2035 0c2c 821B      		sub r24,r18
 2036 0c2e 930B      		sbc r25,r19
 2037 0c30 9093 0000 		sts motors+198+1,r25
 2038 0c34 8093 0000 		sts motors+198,r24
 2039 0c38 80E0      		ldi r24,0
 2040 0c3a 0895      		ret
 2041               	.LBE206:
 2042               	.LBE207:
 2043               	.LBE208:
 2044               	.LBE209:
 2045               	.LBE210:
 2046               	.LBE211:
 2048               	.Lscope20:
 2051               	.global	setAngleMotorLength
 2053               	setAngleMotorLength:
 248:motorctrl.c   ****     return setMotorLength(&motors[ANGLE_MOTOR], length);
 2055               	.LM158:
 2056               	.LFBB21:
 2057               	/* prologue: function */
 2058               	/* frame size = 0 */
 2059               	/* stack size = 0 */
 2060               	.L__stack_usage = 0
 2061               	.LBB220:
 2062               	.LBB221:
 471:motorctrl.c   ****         //Execute move only if it is outside of hysteresis window
 2064               	.LM159:
 2065 0c3c 2091 0000 		lds r18,motors+67
 2066 0c40 3091 0000 		lds r19,motors+67+1
 2067 0c44 8217      		cp r24,r18
 2068 0c46 9307      		cpc r25,r19
 2069 0c48 00F0      		brlo .L95
 2070 0c4a 2091 0000 		lds r18,motors+69
 2071 0c4e 3091 0000 		lds r19,motors+69+1
 2072 0c52 2817      		cp r18,r24
 2073 0c54 3907      		cpc r19,r25
 2074 0c56 00F0      		brlo .L95
 473:motorctrl.c   ****             if (m->current_length < m->set_length - m->length_hysteresis){ 
 2076               	.LM160:
 2077 0c58 4091 0000 		lds r20,motors+35
 2078 0c5c 5091 0000 		lds r21,motors+35+1
 2079 0c60 2091 0000 		lds r18,motors+37
 2080 0c64 3091 0000 		lds r19,motors+37+1
 2081 0c68 6091 0000 		lds r22,motors+45
 2082 0c6c 260F      		add r18,r22
 2083 0c6e 311D      		adc r19,__zero_reg__
 2084 0c70 2417      		cp r18,r20
 2085 0c72 3507      		cpc r19,r21
 2086 0c74 00F4      		brsh .L96
 2087               	.LBB222:
 2088               	.LBB223:
 474:motorctrl.c   ****                 m->set_length = length;
 2090               	.LM161:
 2091 0c76 4091 0000 		lds r20,motors+35
 2092 0c7a 5091 0000 		lds r21,motors+35+1
 2093 0c7e 2091 0000 		lds r18,motors+37
 2094 0c82 3091 0000 		lds r19,motors+37+1
 2095 0c86 6091 0000 		lds r22,motors+45
 2096 0c8a 261B      		sub r18,r22
 2097 0c8c 3109      		sbc r19,__zero_reg__
 2098 0c8e 4217      		cp r20,r18
 2099 0c90 5307      		cpc r21,r19
 2100 0c92 00F0      		brlo .L97
 2101               	.L96:
 2102               	.LBB224:
 2103               	.LBB225:
 2104               	.LBB226:
 2105               	.LBB227:
 448:motorctrl.c   ****      }
 2107               	.LM162:
 2108 0c94 80E0      		ldi r24,0
 2109 0c96 0895      		ret
 2110               	.L95:
 2111               	.LBE227:
 2112               	.LBE226:
 2113               	.LBE225:
 2114               	.LBE224:
 2115               	.LBE223:
 2116               	.LBE222:
 2118               	.LM163:
 2119 0c98 81E0      		ldi r24,lo8(1)
 2120               	.LBE221:
 2121               	.LBE220:
 250:motorctrl.c   **** 
 2123               	.LM164:
 2124 0c9a 0895      		ret
 2125               	.L97:
 2126               	.LBB235:
 2127               	.LBB234:
 2128               	.LBB233:
 2129               	.LBB232:
 475:motorctrl.c   ****                 m->status = WAITING;
 2131               	.LM165:
 2132 0c9c 9093 0000 		sts motors+37+1,r25
 2133 0ca0 8093 0000 		sts motors+37,r24
 476:motorctrl.c   **** 
 2135               	.LM166:
 2136 0ca4 86E0      		ldi r24,lo8(6)
 2137 0ca6 8093 0000 		sts motors+79,r24
 2138               	.LBB231:
 2139               	.LBB230:
 444:motorctrl.c   ****          m->move_length_mm = m->set_length - m->current_length;
 2141               	.LM167:
 2142 0caa 2091 0000 		lds r18,motors+35
 2143 0cae 3091 0000 		lds r19,motors+35+1
 2144 0cb2 8091 0000 		lds r24,motors+37
 2145 0cb6 9091 0000 		lds r25,motors+37+1
 2146 0cba 2817      		cp r18,r24
 2147 0cbc 3907      		cpc r19,r25
 2148 0cbe 00F0      		brlo .L98
 447:motorctrl.c   ****          m->move_length_mm = m->current_length - m->set_length;
 2150               	.LM168:
 2151 0cc0 2091 0000 		lds r18,motors+35
 2152 0cc4 3091 0000 		lds r19,motors+35+1
 2153 0cc8 8091 0000 		lds r24,motors+37
 2154 0ccc 9091 0000 		lds r25,motors+37+1
 2155 0cd0 8217      		cp r24,r18
 2156 0cd2 9307      		cpc r25,r19
 2157 0cd4 00F4      		brsh .L96
 2158               	.LBB229:
 2159               	.LBB228:
 448:motorctrl.c   ****      }
 2161               	.LM169:
 2162 0cd6 8091 0000 		lds r24,motors+35
 2163 0cda 9091 0000 		lds r25,motors+35+1
 2164 0cde 2091 0000 		lds r18,motors+37
 2165 0ce2 3091 0000 		lds r19,motors+37+1
 2166 0ce6 821B      		sub r24,r18
 2167 0ce8 930B      		sbc r25,r19
 2168 0cea 9093 0000 		sts motors+98+1,r25
 2169 0cee 8093 0000 		sts motors+98,r24
 2170 0cf2 00C0      		rjmp .L96
 2171               	.L98:
 2172               	.LBE228:
 2173               	.LBE229:
 445:motorctrl.c   ****      }
 2175               	.LM170:
 2176 0cf4 8091 0000 		lds r24,motors+37
 2177 0cf8 9091 0000 		lds r25,motors+37+1
 2178 0cfc 2091 0000 		lds r18,motors+35
 2179 0d00 3091 0000 		lds r19,motors+35+1
 2180 0d04 821B      		sub r24,r18
 2181 0d06 930B      		sbc r25,r19
 2182 0d08 9093 0000 		sts motors+98+1,r25
 2183 0d0c 8093 0000 		sts motors+98,r24
 2184 0d10 80E0      		ldi r24,0
 2185 0d12 0895      		ret
 2186               	.LBE230:
 2187               	.LBE231:
 2188               	.LBE232:
 2189               	.LBE233:
 2190               	.LBE234:
 2191               	.LBE235:
 2193               	.Lscope21:
 2195               	.global	getAngleMotorStatus
 2197               	getAngleMotorStatus:
 253:motorctrl.c   ****     return motors[ANGLE_MOTOR].status;
 2199               	.LM171:
 2200               	.LFBB22:
 2201               	/* prologue: function */
 2202               	/* frame size = 0 */
 2203               	/* stack size = 0 */
 2204               	.L__stack_usage = 0
 254:motorctrl.c   **** }
 2206               	.LM172:
 2207 0d14 8091 0000 		lds r24,motors+79
 255:motorctrl.c   **** 
 2209               	.LM173:
 2210 0d18 0895      		ret
 2212               	.Lscope22:
 2214               	.global	getTiltMotorStatus
 2216               	getTiltMotorStatus:
 258:motorctrl.c   ****     return motors[TILT_MOTOR].status;
 2218               	.LM174:
 2219               	.LFBB23:
 2220               	/* prologue: function */
 2221               	/* frame size = 0 */
 2222               	/* stack size = 0 */
 2223               	.L__stack_usage = 0
 259:motorctrl.c   **** }
 2225               	.LM175:
 2226 0d1a 8091 0000 		lds r24,motors+179
 260:motorctrl.c   **** 
 2228               	.LM176:
 2229 0d1e 0895      		ret
 2231               	.Lscope23:
 2233               	.global	getTiltMotorAVGcurrent
 2235               	getTiltMotorAVGcurrent:
 262:motorctrl.c   ****     return getMotorAVGcurrent(&motors[TILT_MOTOR]);
 2237               	.LM177:
 2238               	.LFBB24:
 2239               	/* prologue: function */
 2240               	/* frame size = 0 */
 2241               	/* stack size = 0 */
 2242               	.L__stack_usage = 0
 2243               	.LBB236:
 2244               	.LBB237:
 287:motorctrl.c   **** }
 2246               	.LM178:
 2247 0d20 6091 0000 		lds r22,motors+190
 2248 0d24 7091 0000 		lds r23,motors+190+1
 2249 0d28 8091 0000 		lds r24,motors+190+2
 2250 0d2c 9091 0000 		lds r25,motors+190+3
 2251               	.LBE237:
 2252               	.LBE236:
 264:motorctrl.c   **** 
 2254               	.LM179:
 2255 0d30 0895      		ret
 2257               	.Lscope24:
 2259               	.global	getAngleMotorAVGcurrent
 2261               	getAngleMotorAVGcurrent:
 266:motorctrl.c   ****     return getMotorAVGcurrent(&motors[ANGLE_MOTOR]);
 2263               	.LM180:
 2264               	.LFBB25:
 2265               	/* prologue: function */
 2266               	/* frame size = 0 */
 2267               	/* stack size = 0 */
 2268               	.L__stack_usage = 0
 2269               	.LBB238:
 2270               	.LBB239:
 287:motorctrl.c   **** }
 2272               	.LM181:
 2273 0d32 6091 0000 		lds r22,motors+90
 2274 0d36 7091 0000 		lds r23,motors+90+1
 2275 0d3a 8091 0000 		lds r24,motors+90+2
 2276 0d3e 9091 0000 		lds r25,motors+90+3
 2277               	.LBE239:
 2278               	.LBE238:
 268:motorctrl.c   **** 
 2280               	.LM182:
 2281 0d42 0895      		ret
 2283               	.Lscope25:
 2285               	.global	getTiltMotorMoveSpeed
 2287               	getTiltMotorMoveSpeed:
 270:motorctrl.c   ****     return getMotorMoveSpeed(&motors[TILT_MOTOR]);
 2289               	.LM183:
 2290               	.LFBB26:
 2291               	/* prologue: function */
 2292               	/* frame size = 0 */
 2293               	/* stack size = 0 */
 2294               	.L__stack_usage = 0
 2295               	.LBB240:
 2296               	.LBB241:
 291:motorctrl.c   **** }
 2298               	.LM184:
 2299 0d44 6091 0000 		lds r22,motors+194
 2300 0d48 7091 0000 		lds r23,motors+194+1
 2301 0d4c 8091 0000 		lds r24,motors+194+2
 2302 0d50 9091 0000 		lds r25,motors+194+3
 2303               	.LBE241:
 2304               	.LBE240:
 272:motorctrl.c   **** 
 2306               	.LM185:
 2307 0d54 0895      		ret
 2309               	.Lscope26:
 2311               	.global	getAngleMotorMoveSpeed
 2313               	getAngleMotorMoveSpeed:
 274:motorctrl.c   ****     return getMotorMoveSpeed(&motors[ANGLE_MOTOR]);
 2315               	.LM186:
 2316               	.LFBB27:
 2317               	/* prologue: function */
 2318               	/* frame size = 0 */
 2319               	/* stack size = 0 */
 2320               	.L__stack_usage = 0
 2321               	.LBB242:
 2322               	.LBB243:
 291:motorctrl.c   **** }
 2324               	.LM187:
 2325 0d56 6091 0000 		lds r22,motors+94
 2326 0d5a 7091 0000 		lds r23,motors+94+1
 2327 0d5e 8091 0000 		lds r24,motors+94+2
 2328 0d62 9091 0000 		lds r25,motors+94+3
 2329               	.LBE243:
 2330               	.LBE242:
 276:motorctrl.c   **** 
 2332               	.LM188:
 2333 0d66 0895      		ret
 2335               	.Lscope27:
 2337               	.global	getTiltMoveLength
 2339               	getTiltMoveLength:
 278:motorctrl.c   ****     return getMotorMoveLength(&motors[TILT_MOTOR]);
 2341               	.LM189:
 2342               	.LFBB28:
 2343               	/* prologue: function */
 2344               	/* frame size = 0 */
 2345               	/* stack size = 0 */
 2346               	.L__stack_usage = 0
 2347               	.LBB244:
 2348               	.LBB245:
 295:motorctrl.c   **** }
 2350               	.LM190:
 2351 0d68 8091 0000 		lds r24,motors+198
 2352 0d6c 9091 0000 		lds r25,motors+198+1
 2353               	.LBE245:
 2354               	.LBE244:
 280:motorctrl.c   **** 
 2356               	.LM191:
 2357 0d70 0895      		ret
 2359               	.Lscope28:
 2361               	.global	getAngleMoveLength
 2363               	getAngleMoveLength:
 282:motorctrl.c   ****     return getMotorMoveLength(&motors[ANGLE_MOTOR]);
 2365               	.LM192:
 2366               	.LFBB29:
 2367               	/* prologue: function */
 2368               	/* frame size = 0 */
 2369               	/* stack size = 0 */
 2370               	.L__stack_usage = 0
 2371               	.LBB246:
 2372               	.LBB247:
 295:motorctrl.c   **** }
 2374               	.LM193:
 2375 0d72 8091 0000 		lds r24,motors+98
 2376 0d76 9091 0000 		lds r25,motors+98+1
 2377               	.LBE247:
 2378               	.LBE246:
 284:motorctrl.c   **** 
 2380               	.LM194:
 2381 0d7a 0895      		ret
 2383               	.Lscope29:
 2386               	.global	getMotorAVGcurrent
 2388               	getMotorAVGcurrent:
 286:motorctrl.c   ****     return m->avg_move_current;
 2390               	.LM195:
 2391               	.LFBB30:
 2392               	/* prologue: function */
 2393               	/* frame size = 0 */
 2394               	/* stack size = 0 */
 2395               	.L__stack_usage = 0
 287:motorctrl.c   **** }
 2397               	.LM196:
 2398 0d7c FC01      		movw r30,r24
 2399 0d7e E65A      		subi r30,-90
 2400 0d80 FF4F      		sbci r31,-1
 2401 0d82 6081      		ld r22,Z
 2402 0d84 7181      		ldd r23,Z+1
 2403 0d86 8281      		ldd r24,Z+2
 2404 0d88 9381      		ldd r25,Z+3
 288:motorctrl.c   **** 
 2406               	.LM197:
 2407 0d8a 0895      		ret
 2409               	.Lscope30:
 2412               	.global	getMotorMoveSpeed
 2414               	getMotorMoveSpeed:
 290:motorctrl.c   ****     return m->move_speed_mm;
 2416               	.LM198:
 2417               	.LFBB31:
 2418               	/* prologue: function */
 2419               	/* frame size = 0 */
 2420               	/* stack size = 0 */
 2421               	.L__stack_usage = 0
 291:motorctrl.c   **** }
 2423               	.LM199:
 2424 0d8c FC01      		movw r30,r24
 2425 0d8e E25A      		subi r30,-94
 2426 0d90 FF4F      		sbci r31,-1
 2427 0d92 6081      		ld r22,Z
 2428 0d94 7181      		ldd r23,Z+1
 2429 0d96 8281      		ldd r24,Z+2
 2430 0d98 9381      		ldd r25,Z+3
 292:motorctrl.c   **** 
 2432               	.LM200:
 2433 0d9a 0895      		ret
 2435               	.Lscope31:
 2438               	.global	getMotorMoveLength
 2440               	getMotorMoveLength:
 294:motorctrl.c   ****     return m->move_length_mm;
 2442               	.LM201:
 2443               	.LFBB32:
 2444               	/* prologue: function */
 2445               	/* frame size = 0 */
 2446               	/* stack size = 0 */
 2447               	.L__stack_usage = 0
 295:motorctrl.c   **** }
 2449               	.LM202:
 2450 0d9c FC01      		movw r30,r24
 2451 0d9e EE59      		subi r30,-98
 2452 0da0 FF4F      		sbci r31,-1
 2453 0da2 8081      		ld r24,Z
 2454 0da4 9181      		ldd r25,Z+1
 296:motorctrl.c   **** 
 2456               	.LM203:
 2457 0da6 0895      		ret
 2459               	.Lscope32:
 2462               	.global	getMotorPosition
 2464               	getMotorPosition:
 300:motorctrl.c   ****     float aoffset = m->angle_correction(m->current_length);
 2466               	.LM204:
 2467               	.LFBB33:
 2468 0da8 CF93      		push r28
 2469 0daa DF93      		push r29
 2470               	/* prologue: function */
 2471               	/* frame size = 0 */
 2472               	/* stack size = 2 */
 2473               	.L__stack_usage = 2
 2474 0dac EC01      		movw r28,r24
 301:motorctrl.c   ****     return m->angle_reference + aoffset;
 2476               	.LM205:
 2477 0dae FC01      		movw r30,r24
 2478 0db0 E05B      		subi r30,-80
 2479 0db2 FF4F      		sbci r31,-1
 2480 0db4 0190      		ld __tmp_reg__,Z+
 2481 0db6 F081      		ld r31,Z
 2482 0db8 E02D      		mov r30,__tmp_reg__
 2483 0dba 8BA1      		ldd r24,Y+35
 2484 0dbc 9CA1      		ldd r25,Y+36
 2485 0dbe 0995      		icall
 2486 0dc0 9B01      		movw r18,r22
 2487 0dc2 AC01      		movw r20,r24
 302:motorctrl.c   ****     /*
 2489               	.LM206:
 2490 0dc4 6FA9      		ldd r22,Y+55
 2491 0dc6 78AD      		ldd r23,Y+56
 2492 0dc8 89AD      		ldd r24,Y+57
 2493 0dca 9AAD      		ldd r25,Y+58
 2494 0dcc 0E94 0000 		call __addsf3
 2495               	/* epilogue start */
 312:motorctrl.c   **** 
 2497               	.LM207:
 2498 0dd0 DF91      		pop r29
 2499 0dd2 CF91      		pop r28
 2500 0dd4 0895      		ret
 2505               	.Lscope33:
 2508               	.global	getMotorSetPosition
 2510               	getMotorSetPosition:
 314:motorctrl.c   ****     float aoffset = m->angle_correction(m->set_length);
 2512               	.LM208:
 2513               	.LFBB34:
 2514 0dd6 CF93      		push r28
 2515 0dd8 DF93      		push r29
 2516               	/* prologue: function */
 2517               	/* frame size = 0 */
 2518               	/* stack size = 2 */
 2519               	.L__stack_usage = 2
 2520 0dda EC01      		movw r28,r24
 315:motorctrl.c   ****     return m->angle_reference + aoffset;
 2522               	.LM209:
 2523 0ddc FC01      		movw r30,r24
 2524 0dde E05B      		subi r30,-80
 2525 0de0 FF4F      		sbci r31,-1
 2526 0de2 0190      		ld __tmp_reg__,Z+
 2527 0de4 F081      		ld r31,Z
 2528 0de6 E02D      		mov r30,__tmp_reg__
 2529 0de8 8DA1      		ldd r24,Y+37
 2530 0dea 9EA1      		ldd r25,Y+38
 2531 0dec 0995      		icall
 2532 0dee 9B01      		movw r18,r22
 2533 0df0 AC01      		movw r20,r24
 316:motorctrl.c   **** }
 2535               	.LM210:
 2536 0df2 6FA9      		ldd r22,Y+55
 2537 0df4 78AD      		ldd r23,Y+56
 2538 0df6 89AD      		ldd r24,Y+57
 2539 0df8 9AAD      		ldd r25,Y+58
 2540 0dfa 0E94 0000 		call __addsf3
 2541               	/* epilogue start */
 317:motorctrl.c   **** 
 2543               	.LM211:
 2544 0dfe DF91      		pop r29
 2545 0e00 CF91      		pop r28
 2546 0e02 0895      		ret
 2551               	.Lscope34:
 2554               	.global	measureActuatorCurrent
 2556               	measureActuatorCurrent:
 319:motorctrl.c   ****     uint16_t voltage = AVGVoltage(m->actuator_current_adc_channel, 0x40, 2);
 2558               	.LM212:
 2559               	.LFBB35:
 2560 0e04 A0E0      		ldi r26,0
 2561 0e06 B0E0      		ldi r27,0
 2562 0e08 E0E0      		ldi r30,lo8(gs(1f))
 2563 0e0a F0E0      		ldi r31,hi8(gs(1f))
 2564 0e0c 0C94 0000 		jmp __prologue_saves__+((18 - 8) * 2)
 2565               	1:
 2566               	/* prologue: function */
 2567               	/* frame size = 0 */
 2568               	/* stack size = 8 */
 2569               	.L__stack_usage = 8
 2570 0e10 EC01      		movw r28,r24
 320:motorctrl.c   ****     m->avg_move_current = (m->avg_move_current*9.0 + voltage) / 10.0; //one sample is effecting 1/5
 2572               	.LM213:
 2573 0e12 88A1      		ldd r24,Y+32
 2574 0e14 42E0      		ldi r20,lo8(2)
 2575 0e16 60E4      		ldi r22,lo8(64)
 2576 0e18 0E94 0000 		call AVGVoltage
 2577 0e1c 8C01      		movw r16,r24
 321:motorctrl.c   **** }
 2579               	.LM214:
 2580 0e1e C65A      		subi r28,-90
 2581 0e20 DF4F      		sbci r29,-1
 2582 0e22 6881      		ld r22,Y
 2583 0e24 7981      		ldd r23,Y+1
 2584 0e26 8A81      		ldd r24,Y+2
 2585 0e28 9B81      		ldd r25,Y+3
 2586 0e2a 20E0      		ldi r18,0
 2587 0e2c 30E0      		ldi r19,0
 2588 0e2e 40E1      		ldi r20,lo8(16)
 2589 0e30 51E4      		ldi r21,lo8(65)
 2590 0e32 0E94 0000 		call __mulsf3
 2591 0e36 6B01      		movw r12,r22
 2592 0e38 7C01      		movw r14,r24
 2593 0e3a B801      		movw r22,r16
 2594 0e3c 80E0      		ldi r24,0
 2595 0e3e 90E0      		ldi r25,0
 2596 0e40 0E94 0000 		call __floatunsisf
 2597 0e44 9B01      		movw r18,r22
 2598 0e46 AC01      		movw r20,r24
 2599 0e48 C701      		movw r24,r14
 2600 0e4a B601      		movw r22,r12
 2601 0e4c 0E94 0000 		call __addsf3
 2602 0e50 20E0      		ldi r18,0
 2603 0e52 30E0      		ldi r19,0
 2604 0e54 40E2      		ldi r20,lo8(32)
 2605 0e56 51E4      		ldi r21,lo8(65)
 2606 0e58 0E94 0000 		call __divsf3
 2607 0e5c 6883      		st Y,r22
 2608 0e5e 7983      		std Y+1,r23
 2609 0e60 8A83      		std Y+2,r24
 2610 0e62 9B83      		std Y+3,r25
 2611               	/* epilogue start */
 322:motorctrl.c   **** 
 2613               	.LM215:
 2614 0e64 CDB7      		in r28,__SP_L__
 2615 0e66 DEB7      		in r29,__SP_H__
 2616 0e68 E8E0      		ldi r30, lo8(8)
 2617 0e6a 0C94 0000 		jmp __epilogue_restores__ + ((18 - 8) * 2)
 2622               	.Lscope35:
 2626               	.global	setMotorPosition
 2628               	setMotorPosition:
 391:motorctrl.c   ****     m->status = WAITING;
 2630               	.LM216:
 2631               	.LFBB36:
 2632 0e6e 8F92      		push r8
 2633 0e70 9F92      		push r9
 2634 0e72 AF92      		push r10
 2635 0e74 BF92      		push r11
 2636 0e76 CF92      		push r12
 2637 0e78 DF92      		push r13
 2638 0e7a EF92      		push r14
 2639 0e7c FF92      		push r15
 2640 0e7e CF93      		push r28
 2641 0e80 DF93      		push r29
 2642               	/* prologue: function */
 2643               	/* frame size = 0 */
 2644               	/* stack size = 10 */
 2645               	.L__stack_usage = 10
 2646 0e82 EC01      		movw r28,r24
 2647 0e84 6A01      		movw r12,r20
 2648 0e86 7B01      		movw r14,r22
 392:motorctrl.c   ****     //vefify that angle is in between valid range
 2650               	.LM217:
 2651 0e88 FC01      		movw r30,r24
 2652 0e8a E15B      		subi r30,-79
 2653 0e8c FF4F      		sbci r31,-1
 2654 0e8e 86E0      		ldi r24,lo8(6)
 2655 0e90 8083      		st Z,r24
 394:motorctrl.c   ****         m->timeout_value = 0; //Clear timeout value on every angle change
 2657               	.LM218:
 2658 0e92 6FA5      		ldd r22,Y+47
 2659 0e94 78A9      		ldd r23,Y+48
 2660 0e96 89A9      		ldd r24,Y+49
 2661 0e98 9AA9      		ldd r25,Y+50
 2662 0e9a A701      		movw r20,r14
 2663 0e9c 9601      		movw r18,r12
 2664 0e9e 0E94 0000 		call __lesf2
 2665 0ea2 1816      		cp __zero_reg__,r24
 2666 0ea4 04F0      		brlt .L114
 394:motorctrl.c   ****         m->timeout_value = 0; //Clear timeout value on every angle change
 2668               	.LM219:
 2669 0ea6 6FA5      		ldd r22,Y+47
 2670 0ea8 78A9      		ldd r23,Y+48
 2671 0eaa 89A9      		ldd r24,Y+49
 2672 0eac 9AA9      		ldd r25,Y+50
 2673 0eae 2BA9      		ldd r18,Y+51
 2674 0eb0 3CA9      		ldd r19,Y+52
 2675 0eb2 4DA9      		ldd r20,Y+53
 2676 0eb4 5EA9      		ldd r21,Y+54
 2677 0eb6 0E94 0000 		call __addsf3
 2678 0eba 9B01      		movw r18,r22
 2679 0ebc AC01      		movw r20,r24
 2680 0ebe C701      		movw r24,r14
 2681 0ec0 B601      		movw r22,r12
 2682 0ec2 0E94 0000 		call __lesf2
 2683 0ec6 1816      		cp __zero_reg__,r24
 2684 0ec8 04F0      		brlt .+2
 2685 0eca 00C0      		rjmp .L137
 2686               	.L114:
 420:motorctrl.c   ****         uint16_t newlen = m->angle_to_length((m->min_angle+m->angle_range) - m->angle_reference); 
 2688               	.LM220:
 2689 0ecc 6FA5      		ldd r22,Y+47
 2690 0ece 78A9      		ldd r23,Y+48
 2691 0ed0 89A9      		ldd r24,Y+49
 2692 0ed2 9AA9      		ldd r25,Y+50
 2693 0ed4 2BA9      		ldd r18,Y+51
 2694 0ed6 3CA9      		ldd r19,Y+52
 2695 0ed8 4DA9      		ldd r20,Y+53
 2696 0eda 5EA9      		ldd r21,Y+54
 2697 0edc 0E94 0000 		call __addsf3
 2698 0ee0 9B01      		movw r18,r22
 2699 0ee2 AC01      		movw r20,r24
 2700 0ee4 C701      		movw r24,r14
 2701 0ee6 B601      		movw r22,r12
 2702 0ee8 0E94 0000 		call __gtsf2
 2703 0eec 1816      		cp __zero_reg__,r24
 2704 0eee 04F4      		brge .+2
 2705 0ef0 00C0      		rjmp .L138
 428:motorctrl.c   ****         uint16_t newlen = m->angle_to_length(m->min_angle - m->angle_reference); 
 2707               	.LM221:
 2708 0ef2 2FA5      		ldd r18,Y+47
 2709 0ef4 38A9      		ldd r19,Y+48
 2710 0ef6 49A9      		ldd r20,Y+49
 2711 0ef8 5AA9      		ldd r21,Y+50
 2712 0efa C701      		movw r24,r14
 2713 0efc B601      		movw r22,r12
 2714 0efe 0E94 0000 		call __ltsf2
 2715 0f02 87FD      		sbrc r24,7
 2716 0f04 00C0      		rjmp .L139
 2717               	.L126:
 435:motorctrl.c   ****     
 2719               	.LM222:
 2720 0f06 FE01      		movw r30,r28
 2721 0f08 E55B      		subi r30,-75
 2722 0f0a FF4F      		sbci r31,-1
 2723 0f0c 1082      		st Z,__zero_reg__
 2724 0f0e 1182      		std Z+1,__zero_reg__
 2725 0f10 1282      		std Z+2,__zero_reg__
 2726 0f12 1382      		std Z+3,__zero_reg__
 2727               	.LBB261:
 2728               	.LBB262:
 444:motorctrl.c   ****          m->move_length_mm = m->set_length - m->current_length;
 2730               	.LM223:
 2731 0f14 2BA1      		ldd r18,Y+35
 2732 0f16 3CA1      		ldd r19,Y+36
 2733 0f18 8DA1      		ldd r24,Y+37
 2734 0f1a 9EA1      		ldd r25,Y+38
 2735 0f1c 2817      		cp r18,r24
 2736 0f1e 3907      		cpc r19,r25
 2737 0f20 00F0      		brlo .L140
 447:motorctrl.c   ****          m->move_length_mm = m->current_length - m->set_length;
 2739               	.LM224:
 2740 0f22 2BA1      		ldd r18,Y+35
 2741 0f24 3CA1      		ldd r19,Y+36
 2742 0f26 8DA1      		ldd r24,Y+37
 2743 0f28 9EA1      		ldd r25,Y+38
 2744 0f2a 8217      		cp r24,r18
 2745 0f2c 9307      		cpc r25,r19
 2746 0f2e 00F4      		brsh .L130
 2747               	.LBB263:
 2748               	.LBB264:
 448:motorctrl.c   ****      }
 2750               	.LM225:
 2751 0f30 8BA1      		ldd r24,Y+35
 2752 0f32 9CA1      		ldd r25,Y+36
 2753 0f34 2DA1      		ldd r18,Y+37
 2754 0f36 3EA1      		ldd r19,Y+38
 2755 0f38 821B      		sub r24,r18
 2756 0f3a 930B      		sbc r25,r19
 2757 0f3c CE59      		subi r28,-98
 2758 0f3e DF4F      		sbci r29,-1
 2759 0f40 9983      		std Y+1,r25
 2760 0f42 8883      		st Y,r24
 2761               	.L130:
 2762               	.LBE264:
 2763               	.LBE263:
 2764               	.LBE262:
 2765               	.LBE261:
 438:motorctrl.c   ****     return 1;
 2767               	.LM226:
 2768 0f44 1092 0000 		sts systick+1,__zero_reg__
 2769 0f48 1092 0000 		sts systick,__zero_reg__
 439:motorctrl.c   **** }   
 2771               	.LM227:
 2772 0f4c 81E0      		ldi r24,lo8(1)
 2773               	.L122:
 2774               	/* epilogue start */
 440:motorctrl.c   **** 
 2776               	.LM228:
 2777 0f4e DF91      		pop r29
 2778 0f50 CF91      		pop r28
 2779 0f52 FF90      		pop r15
 2780 0f54 EF90      		pop r14
 2781 0f56 DF90      		pop r13
 2782 0f58 CF90      		pop r12
 2783 0f5a BF90      		pop r11
 2784 0f5c AF90      		pop r10
 2785 0f5e 9F90      		pop r9
 2786 0f60 8F90      		pop r8
 2787 0f62 0895      		ret
 2788               	.L140:
 2789               	.LBB266:
 2790               	.LBB265:
 445:motorctrl.c   ****      }
 2792               	.LM229:
 2793 0f64 8DA1      		ldd r24,Y+37
 2794 0f66 9EA1      		ldd r25,Y+38
 2795 0f68 2BA1      		ldd r18,Y+35
 2796 0f6a 3CA1      		ldd r19,Y+36
 2797 0f6c 821B      		sub r24,r18
 2798 0f6e 930B      		sbc r25,r19
 2799 0f70 CE59      		subi r28,-98
 2800 0f72 DF4F      		sbci r29,-1
 2801 0f74 9983      		std Y+1,r25
 2802 0f76 8883      		st Y,r24
 2803 0f78 00C0      		rjmp .L130
 2804               	.L138:
 2805               	.LBE265:
 2806               	.LBE266:
 2807               	.LBB267:
 421:motorctrl.c   ****         if (newlen > m->actuator_max_limit){
 2809               	.LM230:
 2810 0f7a FE01      		movw r30,r28
 2811 0f7c E85A      		subi r30,-88
 2812 0f7e FF4F      		sbci r31,-1
 2813 0f80 E080      		ld r14,Z
 2814 0f82 F180      		ldd r15,Z+1
 2815 0f84 6FA5      		ldd r22,Y+47
 2816 0f86 78A9      		ldd r23,Y+48
 2817 0f88 89A9      		ldd r24,Y+49
 2818 0f8a 9AA9      		ldd r25,Y+50
 2819 0f8c 2BA9      		ldd r18,Y+51
 2820 0f8e 3CA9      		ldd r19,Y+52
 2821 0f90 4DA9      		ldd r20,Y+53
 2822 0f92 5EA9      		ldd r21,Y+54
 2823 0f94 8FA8      		ldd r8,Y+55
 2824 0f96 98AC      		ldd r9,Y+56
 2825 0f98 A9AC      		ldd r10,Y+57
 2826 0f9a BAAC      		ldd r11,Y+58
 2827 0f9c 0E94 0000 		call __addsf3
 2828 0fa0 A501      		movw r20,r10
 2829 0fa2 9401      		movw r18,r8
 2830 0fa4 0E94 0000 		call __subsf3
 2831 0fa8 F701      		movw r30,r14
 2832 0faa 0995      		icall
 422:motorctrl.c   ****             newlen = m->actuator_max_limit - 1;
 2834               	.LM231:
 2835 0fac FE01      		movw r30,r28
 2836 0fae EB5B      		subi r30,-69
 2837 0fb0 FF4F      		sbci r31,-1
 2838 0fb2 2081      		ld r18,Z
 2839 0fb4 3181      		ldd r19,Z+1
 2840 0fb6 2817      		cp r18,r24
 2841 0fb8 3907      		cpc r19,r25
 2842 0fba 00F4      		brsh .L128
 423:motorctrl.c   ****         }
 2844               	.LM232:
 2845 0fbc 8081      		ld r24,Z
 2846 0fbe 9181      		ldd r25,Z+1
 2847 0fc0 0197      		sbiw r24,1
 2848               	.L128:
 2849               	.LBE267:
 2850               	.LBB268:
 433:motorctrl.c   ****     }
 2852               	.LM233:
 2853 0fc2 9EA3      		std Y+38,r25
 2854 0fc4 8DA3      		std Y+37,r24
 2855 0fc6 00C0      		rjmp .L126
 2856               	.L139:
 429:motorctrl.c   ****         if (newlen < m->actuator_min_limit){
 2858               	.LM234:
 2859 0fc8 FE01      		movw r30,r28
 2860 0fca E85A      		subi r30,-88
 2861 0fcc FF4F      		sbci r31,-1
 2862 0fce E080      		ld r14,Z
 2863 0fd0 F180      		ldd r15,Z+1
 2864 0fd2 6FA5      		ldd r22,Y+47
 2865 0fd4 78A9      		ldd r23,Y+48
 2866 0fd6 89A9      		ldd r24,Y+49
 2867 0fd8 9AA9      		ldd r25,Y+50
 2868 0fda 2FA9      		ldd r18,Y+55
 2869 0fdc 38AD      		ldd r19,Y+56
 2870 0fde 49AD      		ldd r20,Y+57
 2871 0fe0 5AAD      		ldd r21,Y+58
 2872 0fe2 0E94 0000 		call __subsf3
 2873 0fe6 F701      		movw r30,r14
 2874 0fe8 0995      		icall
 430:motorctrl.c   ****             newlen = m->actuator_min_limit + 1; 
 2876               	.LM235:
 2877 0fea FE01      		movw r30,r28
 2878 0fec ED5B      		subi r30,-67
 2879 0fee FF4F      		sbci r31,-1
 2880 0ff0 2081      		ld r18,Z
 2881 0ff2 3181      		ldd r19,Z+1
 2882 0ff4 8217      		cp r24,r18
 2883 0ff6 9307      		cpc r25,r19
 2884 0ff8 00F4      		brsh .L128
 431:motorctrl.c   ****         }
 2886               	.LM236:
 2887 0ffa 8081      		ld r24,Z
 2888 0ffc 9181      		ldd r25,Z+1
 2889 0ffe 0196      		adiw r24,1
 2890 1000 00C0      		rjmp .L128
 2891               	.L137:
 2892               	.LBE268:
 2893               	.LBB269:
 395:motorctrl.c   ****         uint16_t len = m->angle_to_length(angle - m->angle_reference);
 2895               	.LM237:
 2896 1002 FE01      		movw r30,r28
 2897 1004 E55B      		subi r30,-75
 2898 1006 FF4F      		sbci r31,-1
 2899 1008 1082      		st Z,__zero_reg__
 2900 100a 1182      		std Z+1,__zero_reg__
 2901 100c 1282      		std Z+2,__zero_reg__
 2902 100e 1382      		std Z+3,__zero_reg__
 396:motorctrl.c   ****     
 2904               	.LM238:
 2905 1010 3D96      		adiw r30,13
 2906 1012 A080      		ld r10,Z
 2907 1014 B180      		ldd r11,Z+1
 2908 1016 2FA9      		ldd r18,Y+55
 2909 1018 38AD      		ldd r19,Y+56
 2910 101a 49AD      		ldd r20,Y+57
 2911 101c 5AAD      		ldd r21,Y+58
 2912 101e C701      		movw r24,r14
 2913 1020 B601      		movw r22,r12
 2914 1022 0E94 0000 		call __subsf3
 2915 1026 F501      		movw r30,r10
 2916 1028 0995      		icall
 399:motorctrl.c   ****             uint16_t newlen = len + (m->length_hysteresis);
 2918               	.LM239:
 2919 102a 2DA1      		ldd r18,Y+37
 2920 102c 3EA1      		ldd r19,Y+38
 2921 102e 2817      		cp r18,r24
 2922 1030 3907      		cpc r19,r25
 2923 1032 00F4      		brsh .L117
 2924               	.LBB270:
 400:motorctrl.c   ****             if (newlen > m->actuator_max_limit){
 2926               	.LM240:
 2927 1034 2DA5      		ldd r18,Y+45
 2928 1036 820F      		add r24,r18
 2929 1038 911D      		adc r25,__zero_reg__
 401:motorctrl.c   ****                 newlen = m->actuator_max_limit-1;
 2931               	.LM241:
 2932 103a FE01      		movw r30,r28
 2933 103c EB5B      		subi r30,-69
 2934 103e FF4F      		sbci r31,-1
 2935 1040 2081      		ld r18,Z
 2936 1042 3181      		ldd r19,Z+1
 2937 1044 2817      		cp r18,r24
 2938 1046 3907      		cpc r19,r25
 2939 1048 00F0      		brlo .L141
 2940               	.L120:
 2941               	.LBE270:
 2942               	.LBB271:
 411:motorctrl.c   ****         }
 2944               	.LM242:
 2945 104a 9EA3      		std Y+38,r25
 2946 104c 8DA3      		std Y+37,r24
 2947               	.LBE271:
 2948               	.LBB272:
 2949               	.LBB273:
 444:motorctrl.c   ****          m->move_length_mm = m->set_length - m->current_length;
 2951               	.LM243:
 2952 104e 2BA1      		ldd r18,Y+35
 2953 1050 3CA1      		ldd r19,Y+36
 2954 1052 8DA1      		ldd r24,Y+37
 2955 1054 9EA1      		ldd r25,Y+38
 2956 1056 2817      		cp r18,r24
 2957 1058 3907      		cpc r19,r25
 2958 105a 00F0      		brlo .L142
 447:motorctrl.c   ****          m->move_length_mm = m->current_length - m->set_length;
 2960               	.LM244:
 2961 105c 2BA1      		ldd r18,Y+35
 2962 105e 3CA1      		ldd r19,Y+36
 2963 1060 8DA1      		ldd r24,Y+37
 2964 1062 9EA1      		ldd r25,Y+38
 2965 1064 8217      		cp r24,r18
 2966 1066 9307      		cpc r25,r19
 2967 1068 00F4      		brsh .L131
 2968               	.LBB274:
 2969               	.LBB275:
 448:motorctrl.c   ****      }
 2971               	.LM245:
 2972 106a 8BA1      		ldd r24,Y+35
 2973 106c 9CA1      		ldd r25,Y+36
 2974 106e 2DA1      		ldd r18,Y+37
 2975 1070 3EA1      		ldd r19,Y+38
 2976 1072 821B      		sub r24,r18
 2977 1074 930B      		sbc r25,r19
 2978 1076 CE59      		subi r28,-98
 2979 1078 DF4F      		sbci r29,-1
 2980 107a 9983      		std Y+1,r25
 2981 107c 8883      		st Y,r24
 2982               	.LBE275:
 2983               	.LBE274:
 2984               	.LBE273:
 2985               	.LBE272:
 416:motorctrl.c   ****     }
 2987               	.LM246:
 2988 107e 80E0      		ldi r24,0
 2989 1080 00C0      		rjmp .L122
 2990               	.L117:
 2991               	.LBB277:
 407:motorctrl.c   ****             if (newlen < m->actuator_min_limit){
 2993               	.LM247:
 2994 1082 2DA5      		ldd r18,Y+45
 2995 1084 821B      		sub r24,r18
 2996 1086 9109      		sbc r25,__zero_reg__
 408:motorctrl.c   ****                 newlen = m->actuator_min_limit+1;
 2998               	.LM248:
 2999 1088 FE01      		movw r30,r28
 3000 108a ED5B      		subi r30,-67
 3001 108c FF4F      		sbci r31,-1
 3002 108e 2081      		ld r18,Z
 3003 1090 3181      		ldd r19,Z+1
 3004 1092 8217      		cp r24,r18
 3005 1094 9307      		cpc r25,r19
 3006 1096 00F4      		brsh .L120
 409:motorctrl.c   ****             }
 3008               	.LM249:
 3009 1098 8081      		ld r24,Z
 3010 109a 9181      		ldd r25,Z+1
 3011 109c 0196      		adiw r24,1
 3012 109e 00C0      		rjmp .L120
 3013               	.L142:
 3014               	.LBE277:
 3015               	.LBB278:
 3016               	.LBB276:
 445:motorctrl.c   ****      }
 3018               	.LM250:
 3019 10a0 8DA1      		ldd r24,Y+37
 3020 10a2 9EA1      		ldd r25,Y+38
 3021 10a4 2BA1      		ldd r18,Y+35
 3022 10a6 3CA1      		ldd r19,Y+36
 3023 10a8 821B      		sub r24,r18
 3024 10aa 930B      		sbc r25,r19
 3025 10ac CE59      		subi r28,-98
 3026 10ae DF4F      		sbci r29,-1
 3027 10b0 9983      		std Y+1,r25
 3028 10b2 8883      		st Y,r24
 3029               	.LBE276:
 3030               	.LBE278:
 416:motorctrl.c   ****     }
 3032               	.LM251:
 3033 10b4 80E0      		ldi r24,0
 3034 10b6 00C0      		rjmp .L122
 3035               	.L141:
 3036               	.LBB279:
 402:motorctrl.c   ****             }
 3038               	.LM252:
 3039 10b8 8081      		ld r24,Z
 3040 10ba 9181      		ldd r25,Z+1
 3041 10bc 0197      		sbiw r24,1
 3042 10be 00C0      		rjmp .L120
 3043               	.L131:
 3044               	.LBE279:
 416:motorctrl.c   ****     }
 3046               	.LM253:
 3047 10c0 80E0      		ldi r24,0
 3048 10c2 00C0      		rjmp .L122
 3049               	.LBE269:
 3072               	.Lscope36:
 3075               	.global	calculateMoveLength
 3077               	calculateMoveLength:
 442:motorctrl.c   ****       //Store move length for speed calculations
 3079               	.LM254:
 3080               	.LFBB37:
 3081               	/* prologue: function */
 3082               	/* frame size = 0 */
 3083               	/* stack size = 0 */
 3084               	.L__stack_usage = 0
 3085 10c4 FC01      		movw r30,r24
 444:motorctrl.c   ****          m->move_length_mm = m->set_length - m->current_length;
 3087               	.LM255:
 3088 10c6 23A1      		ldd r18,Z+35
 3089 10c8 34A1      		ldd r19,Z+36
 3090 10ca 85A1      		ldd r24,Z+37
 3091 10cc 96A1      		ldd r25,Z+38
 3092 10ce 2817      		cp r18,r24
 3093 10d0 3907      		cpc r19,r25
 3094 10d2 00F0      		brlo .L146
 447:motorctrl.c   ****          m->move_length_mm = m->current_length - m->set_length;
 3096               	.LM256:
 3097 10d4 23A1      		ldd r18,Z+35
 3098 10d6 34A1      		ldd r19,Z+36
 3099 10d8 85A1      		ldd r24,Z+37
 3100 10da 96A1      		ldd r25,Z+38
 3101 10dc 8217      		cp r24,r18
 3102 10de 9307      		cpc r25,r19
 3103 10e0 00F4      		brsh .L143
 3104               	.LBB282:
 3105               	.LBB283:
 448:motorctrl.c   ****      }
 3107               	.LM257:
 3108 10e2 83A1      		ldd r24,Z+35
 3109 10e4 94A1      		ldd r25,Z+36
 3110 10e6 25A1      		ldd r18,Z+37
 3111 10e8 36A1      		ldd r19,Z+38
 3112 10ea 821B      		sub r24,r18
 3113 10ec 930B      		sbc r25,r19
 3114 10ee EE59      		subi r30,-98
 3115 10f0 FF4F      		sbci r31,-1
 3116 10f2 9183      		std Z+1,r25
 3117 10f4 8083      		st Z,r24
 3118               	.L143:
 3119 10f6 0895      		ret
 3120               	.L146:
 3121               	.LBE283:
 3122               	.LBE282:
 445:motorctrl.c   ****      }
 3124               	.LM258:
 3125 10f8 25A1      		ldd r18,Z+37
 3126 10fa 36A1      		ldd r19,Z+38
 3127 10fc 83A1      		ldd r24,Z+35
 3128 10fe 94A1      		ldd r25,Z+36
 3129 1100 281B      		sub r18,r24
 3130 1102 390B      		sbc r19,r25
 3131 1104 EE59      		subi r30,-98
 3132 1106 FF4F      		sbci r31,-1
 3133 1108 3183      		std Z+1,r19
 3134 110a 2083      		st Z,r18
 3135 110c 0895      		ret
 3137               	.Lscope37:
 3140               	.global	getMotorMinAngle
 3142               	getMotorMinAngle:
 452:motorctrl.c   ****     return m->min_angle;
 3144               	.LM259:
 3145               	.LFBB38:
 3146               	/* prologue: function */
 3147               	/* frame size = 0 */
 3148               	/* stack size = 0 */
 3149               	.L__stack_usage = 0
 453:motorctrl.c   **** }
 3151               	.LM260:
 3152 110e FC01      		movw r30,r24
 3153 1110 67A5      		ldd r22,Z+47
 3154 1112 70A9      		ldd r23,Z+48
 3155 1114 81A9      		ldd r24,Z+49
 3156 1116 92A9      		ldd r25,Z+50
 454:motorctrl.c   **** 
 3158               	.LM261:
 3159 1118 0895      		ret
 3161               	.Lscope38:
 3164               	.global	getMotorMaxAngle
 3166               	getMotorMaxAngle:
 456:motorctrl.c   ****     return m->min_angle + m->angle_range;
 3168               	.LM262:
 3169               	.LFBB39:
 3170               	/* prologue: function */
 3171               	/* frame size = 0 */
 3172               	/* stack size = 0 */
 3173               	.L__stack_usage = 0
 3174 111a FC01      		movw r30,r24
 457:motorctrl.c   **** }
 3176               	.LM263:
 3177 111c 67A5      		ldd r22,Z+47
 3178 111e 70A9      		ldd r23,Z+48
 3179 1120 81A9      		ldd r24,Z+49
 3180 1122 92A9      		ldd r25,Z+50
 3181 1124 23A9      		ldd r18,Z+51
 3182 1126 34A9      		ldd r19,Z+52
 3183 1128 45A9      		ldd r20,Z+53
 3184 112a 56A9      		ldd r21,Z+54
 3185 112c 0E94 0000 		call __addsf3
 458:motorctrl.c   ****  
 3187               	.LM264:
 3188 1130 0895      		ret
 3190               	.Lscope39:
 3192               	.global	shutdownMotors
 3194               	shutdownMotors:
 463:motorctrl.c   ****     for (uint8_t i = 0; i<NUM_OF_MOTORS; i++){
 3196               	.LM265:
 3197               	.LFBB40:
 3198               	/* prologue: function */
 3199               	/* frame size = 0 */
 3200               	/* stack size = 0 */
 3201               	.L__stack_usage = 0
 3202               	.LBB287:
 3203               	.LBB288:
 3204               	.LBB289:
 485:motorctrl.c   ****     }
 486:motorctrl.c   **** }
 487:motorctrl.c   **** 
 488:motorctrl.c   **** 
 489:motorctrl.c   **** void setLengthLoop(void){
 490:motorctrl.c   ****     //uint8_t status = 0;
 491:motorctrl.c   ****     for (uint8_t i = 0; i < NUM_OF_MOTORS; i++){
 492:motorctrl.c   ****         volatile motor *m = &motors[i];
 493:motorctrl.c   ****         m->current_length = getActuatorLength(m);
 494:motorctrl.c   **** 
 495:motorctrl.c   ****         //Check if we have been running too long
 496:motorctrl.c   ****         if ((running_motor == i || running_motor == -1) && (m->status != STATUS_OK)){ //IF this mot
 497:motorctrl.c   ****             if (m->timeout_value >= m->timeout_setting){
 498:motorctrl.c   ****                 motorControl(m, m->current_dir, SHUTDOWN); //Shutdown motor if it has been running 
 499:motorctrl.c   ****                 m->status = TIMEOUT_ERROR;
 500:motorctrl.c   ****                 fprintf_P(port, PSTR("timeout\n"));
 501:motorctrl.c   ****                 m->set_length = m->current_length; //REset movement
 502:motorctrl.c   ****                 running_motor = -1;
 503:motorctrl.c   ****             } 
 504:motorctrl.c   ****             else{
 505:motorctrl.c   ****                 if (m->current_length > m->set_length + m->length_hysteresis){
 506:motorctrl.c   ****                     motorControl(m, BACKWARD, m->max_pwm);
 507:motorctrl.c   ****                     m->timeout_value ++; //update timeout variables
 508:motorctrl.c   ****                     m->status = RUNNING_BACKWARD;
 509:motorctrl.c   ****                     running_motor = i;
 510:motorctrl.c   ****                     if (m->timeout_value%100 == 0){
 511:motorctrl.c   ****                         measureActuatorCurrent(m);
 512:motorctrl.c   ****                     }
 513:motorctrl.c   ****                 }
 514:motorctrl.c   ****                 else if (m->current_length < m->set_length - m->length_hysteresis){
 515:motorctrl.c   ****                     motorControl(m, FORWARD, m->max_pwm);
 516:motorctrl.c   ****                     m->timeout_value ++; //update timeout variables
 517:motorctrl.c   ****                     m->status = RUNNING_FORWARD;
 518:motorctrl.c   ****                     running_motor = i;
 519:motorctrl.c   ****                     if (m->timeout_value%100 == 0){
 520:motorctrl.c   ****                         measureActuatorCurrent(m);
 521:motorctrl.c   ****                     }
 522:motorctrl.c   ****                 }
 523:motorctrl.c   ****                 else{
 524:motorctrl.c   ****                     measureActuatorCurrent(m);
 525:motorctrl.c   ****                     for(; m->current_pwm > 0; m->current_pwm--){
 526:motorctrl.c   ****                         setMotor(m, m->current_dir, m->current_pwm);
 527:motorctrl.c   ****                         delayLoop_us(m->deacceleration_time);
 528:motorctrl.c   ****                     }
 529:motorctrl.c   ****                     m->timeout_value = 0; //Clear timeout
 530:motorctrl.c   ****                     m->status = STATUS_OK;
 531:motorctrl.c   ****                     disableMotorPWM(m);
 532:motorctrl.c   ****                     calculateMoveSpeed(m, systick);       
 533:motorctrl.c   ****                     _delay_ms(25);  
 534:motorctrl.c   ****                     running_motor = -1;    
 535:motorctrl.c   ****                     systick = 0;
 536:motorctrl.c   ****                 }
 537:motorctrl.c   ****             }
 538:motorctrl.c   ****         }
 539:motorctrl.c   ****     }
 540:motorctrl.c   **** }
 541:motorctrl.c   **** 
 542:motorctrl.c   **** void calculateMoveSpeed(volatile motor *m, uint16_t tick){
 543:motorctrl.c   ****     if (tick > 0 && m->move_length_mm > 0){
 544:motorctrl.c   ****         float milliseconds = tick;
 545:motorctrl.c   ****         float mlen = m->move_length_mm;
 546:motorctrl.c   ****         m->move_speed_mm = mlen / (milliseconds/100);
 547:motorctrl.c   ****     }
 548:motorctrl.c   ****     else{
 549:motorctrl.c   ****         m->move_speed_mm = 0.0;
 550:motorctrl.c   ****     }
 551:motorctrl.c   **** }
 552:motorctrl.c   **** 
 553:motorctrl.c   **** 
 554:motorctrl.c   **** void forceMotors(uint8_t dir, uint8_t time){
 555:motorctrl.c   ****     if (dir != FORWARD && dir != BACKWARD){
 556:motorctrl.c   ****         fprintf_P(port, PSTR("ERR,dir\n"));
 557:motorctrl.c   ****         return;
 558:motorctrl.c   ****     }
 559:motorctrl.c   ****     fprintf_P(port, PSTR("Running motor "));
 560:motorctrl.c   ****     fprintf(port, "%ds\n",time);
 561:motorctrl.c   ****     for (uint8_t i=0; i< 1; i++){
 562:motorctrl.c   ****         volatile motor *m = &motors[i];
 563:motorctrl.c   ****         setMotor(m, dir, m->max_pwm);
 564:motorctrl.c   ****     }
 565:motorctrl.c   ****     for (uint16_t i=0;i<time*20;i++){
 566:motorctrl.c   ****         for (uint8_t j=0;j<2;j++){
 567:motorctrl.c   ****             volatile motor *m = &motors[j];
 568:motorctrl.c   ****             uint16_t value = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
 569:motorctrl.c   ****             fprintf_P(port, PSTR("motor:"));
 570:motorctrl.c   ****             fprintf(port, "%d", j);
 571:motorctrl.c   ****             fprintf_P(port, PSTR(" ADC_value:"));
 572:motorctrl.c   ****             fprintf(port,"%d\n",value);
 573:motorctrl.c   ****         }
 574:motorctrl.c   ****         _delay_ms(50);
 575:motorctrl.c   ****     }
 576:motorctrl.c   ****     fprintf_P(port, PSTR("Shutdown\n"));
 577:motorctrl.c   ****     for (uint8_t i=0; i< 1; i++){
 578:motorctrl.c   ****         volatile motor *m = &motors[i];
 579:motorctrl.c   ****         setMotor(m, dir, 0);
 580:motorctrl.c   ****     }
 581:motorctrl.c   **** }
 582:motorctrl.c   **** 
 583:motorctrl.c   **** void calibrateMotors(void){
 584:motorctrl.c   ****     //return;
 585:motorctrl.c   ****     for(uint8_t i=0; i<NUM_OF_MOTORS;i++){
 586:motorctrl.c   ****         fprintf_P(port, PSTR("calibrating motor:"));
 587:motorctrl.c   ****         fprintf(port, "%d\n",i);
 588:motorctrl.c   ****         volatile motor *m = &motors[i];
 589:motorctrl.c   ****         uint16_t minval = 1024;
 590:motorctrl.c   ****         uint16_t maxval = 0;
 591:motorctrl.c   ****         setMotor(m, FORWARD, m->max_pwm);
 592:motorctrl.c   ****         uint16_t lastval = 0; // AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
 593:motorctrl.c   ****         _delay_ms(500);
 594:motorctrl.c   ****         for(uint8_t wait = 0; wait < 100; wait++){
 595:motorctrl.c   ****             uint16_t value = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
 596:motorctrl.c   ****             if (value > lastval - CALIBRATION_HYSTERESIS && value < lastval + CALIBRATION_HYSTERESI
 597:motorctrl.c   ****                 fprintf_P(port, PSTR("FW min: "));
 598:motorctrl.c   ****                 fprintf(port, "%d\n",value);
 599:motorctrl.c   ****                 minval = value;
 600:motorctrl.c   ****                 break;
 601:motorctrl.c   ****             }
 602:motorctrl.c   ****             lastval = value;
 603:motorctrl.c   ****             _delay_ms(500);
 604:motorctrl.c   ****         }
 605:motorctrl.c   ****         setMotor(m, BACKWARD, m->max_pwm);
 606:motorctrl.c   ****         lastval = 0; //AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
 607:motorctrl.c   ****         _delay_ms(500);
 608:motorctrl.c   ****         for(uint8_t wait = 0; wait < 100; wait++){
 609:motorctrl.c   ****             uint16_t value = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
 610:motorctrl.c   ****             if (value > lastval - CALIBRATION_HYSTERESIS && value < lastval + CALIBRATION_HYSTERESI
 611:motorctrl.c   ****                 fprintf_P(port, PSTR("RW max: "));
 612:motorctrl.c   ****                 fprintf(port, "%d\n", value);
 613:motorctrl.c   ****                 maxval = value;
 614:motorctrl.c   ****                 break;
 615:motorctrl.c   ****             }
 616:motorctrl.c   ****             lastval = value;
 617:motorctrl.c   ****             _delay_ms(500);
 618:motorctrl.c   ****         }
 619:motorctrl.c   ****         fprintf_P(port, PSTR("calibration ready\n"));
 620:motorctrl.c   ****         float min = minval;
 621:motorctrl.c   ****         float max = maxval;
 622:motorctrl.c   ****         fprintf_P(port, PSTR("Voltage Min:"));
 623:motorctrl.c   ****         fprintf(port, "%f Max:%f\n",(4700.0/1024.0)*min,(4700.0/1024.0)*max);
 624:motorctrl.c   ****     }
 625:motorctrl.c   **** }
 626:motorctrl.c   **** 
 627:motorctrl.c   **** void delayLoop_us(uint16_t delay){
 628:motorctrl.c   ****     for (uint16_t i = 0; i < delay/50; i++){
 629:motorctrl.c   ****         _delay_us(47);
 630:motorctrl.c   ****     }
 631:motorctrl.c   **** }
 632:motorctrl.c   **** 
 633:motorctrl.c   **** void motorControl(volatile motor *m, uint8_t dir, uint8_t pwm){
 634:motorctrl.c   ****     if (pwm > m->max_pwm){
 635:motorctrl.c   ****         pwm = m->max_pwm;
 636:motorctrl.c   ****     }
 637:motorctrl.c   ****     
 638:motorctrl.c   ****     //Set motor control
 639:motorctrl.c   ****     if (m->current_pwm < pwm){ //Need to accelerate
 640:motorctrl.c   ****         for(; m->current_pwm < pwm; m->current_pwm++){
 641:motorctrl.c   ****             setMotor(m, dir, m->current_pwm);
 642:motorctrl.c   ****             delayLoop_us(m->acceleration_time);
 643:motorctrl.c   ****         }
 644:motorctrl.c   ****         setMotor(m, dir, m->current_pwm);
 645:motorctrl.c   ****     }
 646:motorctrl.c   ****     else if (m->current_pwm > pwm){
 647:motorctrl.c   ****         for(; m->current_pwm > pwm; m->current_pwm--){
 648:motorctrl.c   ****             setMotor(m, dir, m->current_pwm);
 649:motorctrl.c   ****             delayLoop_us(m->deacceleration_time);
 650:motorctrl.c   ****         } 
 651:motorctrl.c   ****         setMotor(m, dir, m->current_pwm);
 652:motorctrl.c   ****     }
 653:motorctrl.c   ****     m->current_dir = dir;
 654:motorctrl.c   **** }
 655:motorctrl.c   **** 
 656:motorctrl.c   **** 
 657:motorctrl.c   **** void initMotor(FILE *debugport){
 658:motorctrl.c   ****     port = debugport;
 659:motorctrl.c   **** 
 660:motorctrl.c   ****     for(uint8_t i = 0; i<NUM_OF_MOTORS; i++){
 661:motorctrl.c   ****         volatile motor *m = &motors[i];
 662:motorctrl.c   ****         //Set direction and enable to output pins
 663:motorctrl.c   ****         *m->fwd_dir_addr |= 1<<m->fwd_pin;
 664:motorctrl.c   ****         *m->rev_dir_addr |= 1<<m->rev_pin;
 665:motorctrl.c   ****         *m->enable_dir_addr |= 1<<m->enable_pin;
 666:motorctrl.c   ****         
 667:motorctrl.c   ****         //Set pullups correctly
 668:motorctrl.c   ****         *m->fwd_port_addr &= ~(1<<m->fwd_pin);
 669:motorctrl.c   ****         *m->rev_port_addr &= ~(1<<m->rev_pin);
 670:motorctrl.c   ****         *m->enable_port_addr &= ~(1<<m->enable_pin);
 671:motorctrl.c   ****         
 672:motorctrl.c   ****         //Init forward PWM settings
 673:motorctrl.c   ****         *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 674:motorctrl.c   ****         *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 675:motorctrl.c   ****         *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 676:motorctrl.c   ****         
 677:motorctrl.c   ****         //Init reverse PWM settings
 678:motorctrl.c   ****         *m->rev_TCCRA_addr = 0x00;//m.rev_TCCRA_value;
 679:motorctrl.c   ****         *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 680:motorctrl.c   ****         *m->rev_OCR_addr = 0x00; //Init PWM to zero
 681:motorctrl.c   ****         
 682:motorctrl.c   ****         //init Actuator +5 and GND pins
 683:motorctrl.c   ****         _delay_ms(10); //wait 10ms so ADC pins settle.
 684:motorctrl.c   **** 
 685:motorctrl.c   ****         m->current_length = getActuatorLength(m);
 686:motorctrl.c   ****         m->set_length = m->current_length;
 687:motorctrl.c   ****    }
 688:motorctrl.c   **** 
 689:motorctrl.c   ****    //Init timeout counter TIMER1
 690:motorctrl.c   ****    TCCR1A = 0x00; // WGM11 = 0, WGM10 = 0   => CTC mode
 691:motorctrl.c   ****    //clock frequency = 16MHz / 1024 = 15625Hz
 692:motorctrl.c   ****    TCCR1B = 0x08 + 0x05; //WGM12 = 1, WGM 13 = 0        => CTC mode, Clock divider 1024 = 0x05
 693:motorctrl.c   ****    OCR1AH = 0x00; //Zero this when tests are done
 694:motorctrl.c   ****    OCR1AL = 0x9C;  // interrupt 100 times per second 15625/156~about 100 
 695:motorctrl.c   ****    //Set interrupt to TIMER1 COMPA
 696:motorctrl.c   ****    TIMSK1 = 0x02; //OCIEA enabled
 697:motorctrl.c   ****   
 698:motorctrl.c   ****    // GTCCR = 0x00;//Counter is started at the main loop Start Counter
 699:motorctrl.c   **** }
 700:motorctrl.c   **** void disableMotorPWM(volatile motor *m){
 701:motorctrl.c   **** 
 702:motorctrl.c   ****     *m->enable_port_addr &= ~(1<<m->enable_pin); //Disable motor => clear enable port
 3206               	.LM266:
 3207 1132 E0E0      		ldi r30,lo8(motors)
 3208 1134 F0E0      		ldi r31,hi8(motors)
 3209 1136 268D      		ldd r18,Z+30
 3210 1138 A28D      		ldd r26,Z+26
 3211 113a B38D      		ldd r27,Z+27
 3212 113c 4C91      		ld r20,X
 3213 113e 81E0      		ldi r24,lo8(1)
 3214 1140 90E0      		ldi r25,0
 3215 1142 BC01      		movw r22,r24
 3216 1144 00C0      		rjmp 2f
 3217               		1:
 3218 1146 660F      		lsl r22
 3219 1148 771F      		rol r23
 3220               		2:
 3221 114a 2A95      		dec r18
 3222 114c 02F4      		brpl 1b
 3223 114e 9B01      		movw r18,r22
 3224 1150 2095      		com r18
 3225 1152 3095      		com r19
 3226 1154 2423      		and r18,r20
 3227 1156 2C93      		st X,r18
 703:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 3229               	.LM267:
 3230 1158 A581      		ldd r26,Z+5
 3231 115a B681      		ldd r27,Z+6
 3232 115c 1C92      		st X,__zero_reg__
 704:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 3234               	.LM268:
 3235 115e A085      		ldd r26,Z+8
 3236 1160 B185      		ldd r27,Z+9
 3237 1162 1C92      		st X,__zero_reg__
 705:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 3239               	.LM269:
 3240 1164 A385      		ldd r26,Z+11
 3241 1166 B485      		ldd r27,Z+12
 3242 1168 1C92      		st X,__zero_reg__
 706:motorctrl.c   ****     
 707:motorctrl.c   ****     //Init reverse PWM settings
 708:motorctrl.c   ****     *m->rev_TCCRA_addr = 0x00;//m.rev_TCCRA_value;
 3244               	.LM270:
 3245 116a A289      		ldd r26,Z+18
 3246 116c B389      		ldd r27,Z+19
 3247 116e 1C92      		st X,__zero_reg__
 709:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 3249               	.LM271:
 3250 1170 A589      		ldd r26,Z+21
 3251 1172 B689      		ldd r27,Z+22
 3252 1174 1C92      		st X,__zero_reg__
 710:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 3254               	.LM272:
 3255 1176 A08D      		ldd r26,Z+24
 3256 1178 B18D      		ldd r27,Z+25
 3257 117a 1C92      		st X,__zero_reg__
 711:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 3259               	.LM273:
 3260 117c 11A2      		std Z+33,__zero_reg__
 712:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 3262               	.LM274:
 3263 117e 1092 0000 		sts motors+75,__zero_reg__
 3264 1182 1092 0000 		sts motors+75+1,__zero_reg__
 3265 1186 1092 0000 		sts motors+75+2,__zero_reg__
 3266 118a 1092 0000 		sts motors+75+3,__zero_reg__
 3267               	.LBE289:
 3268               	.LBE288:
 466:motorctrl.c   ****     }
 3270               	.LM275:
 3271 118e 23A1      		ldd r18,Z+35
 3272 1190 34A1      		ldd r19,Z+36
 3273 1192 36A3      		std Z+38,r19
 3274 1194 25A3      		std Z+37,r18
 3275               	.LBB291:
 3276               	.LBB290:
 702:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 3278               	.LM276:
 3279 1196 3091 0000 		lds r19,motors+130
 3280 119a E091 0000 		lds r30,motors+126
 3281 119e F091 0000 		lds r31,motors+126+1
 3282 11a2 2081      		ld r18,Z
 3283 11a4 00C0      		rjmp 2f
 3284               		1:
 3285 11a6 880F      		lsl r24
 3286 11a8 991F      		rol r25
 3287               		2:
 3288 11aa 3A95      		dec r19
 3289 11ac 02F4      		brpl 1b
 3290 11ae 8095      		com r24
 3291 11b0 9095      		com r25
 3292 11b2 8223      		and r24,r18
 3293 11b4 8083      		st Z,r24
 703:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 3295               	.LM277:
 3296 11b6 E091 0000 		lds r30,motors+105
 3297 11ba F091 0000 		lds r31,motors+105+1
 3298 11be 1082      		st Z,__zero_reg__
 704:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 3300               	.LM278:
 3301 11c0 E091 0000 		lds r30,motors+108
 3302 11c4 F091 0000 		lds r31,motors+108+1
 3303 11c8 1082      		st Z,__zero_reg__
 705:motorctrl.c   ****     
 3305               	.LM279:
 3306 11ca E091 0000 		lds r30,motors+111
 3307 11ce F091 0000 		lds r31,motors+111+1
 3308 11d2 1082      		st Z,__zero_reg__
 708:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 3310               	.LM280:
 3311 11d4 E091 0000 		lds r30,motors+118
 3312 11d8 F091 0000 		lds r31,motors+118+1
 3313 11dc 1082      		st Z,__zero_reg__
 709:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 3315               	.LM281:
 3316 11de E091 0000 		lds r30,motors+121
 3317 11e2 F091 0000 		lds r31,motors+121+1
 3318 11e6 1082      		st Z,__zero_reg__
 710:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 3320               	.LM282:
 3321 11e8 E091 0000 		lds r30,motors+124
 3322 11ec F091 0000 		lds r31,motors+124+1
 3323 11f0 1082      		st Z,__zero_reg__
 711:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 3325               	.LM283:
 3326 11f2 1092 0000 		sts motors+133,__zero_reg__
 3328               	.LM284:
 3329 11f6 1092 0000 		sts motors+175,__zero_reg__
 3330 11fa 1092 0000 		sts motors+175+1,__zero_reg__
 3331 11fe 1092 0000 		sts motors+175+2,__zero_reg__
 3332 1202 1092 0000 		sts motors+175+3,__zero_reg__
 3333               	.LBE290:
 3334               	.LBE291:
 466:motorctrl.c   ****     }
 3336               	.LM285:
 3337 1206 8091 0000 		lds r24,motors+135
 3338 120a 9091 0000 		lds r25,motors+135+1
 3339 120e 9093 0000 		sts motors+137+1,r25
 3340 1212 8093 0000 		sts motors+137,r24
 3341 1216 0895      		ret
 3342               	.LBE287:
 3344               	.Lscope40:
 3348               	.global	setMotorLength
 3350               	setMotorLength:
 470:motorctrl.c   ****     if (length >= m->actuator_min_limit && length <= m->actuator_max_limit){
 3352               	.LM286:
 3353               	.LFBB41:
 3354               	/* prologue: function */
 3355               	/* frame size = 0 */
 3356               	/* stack size = 0 */
 3357               	.L__stack_usage = 0
 3358 1218 FC01      		movw r30,r24
 471:motorctrl.c   ****         //Execute move only if it is outside of hysteresis window
 3360               	.LM287:
 3361 121a DC01      		movw r26,r24
 3362 121c AD5B      		subi r26,-67
 3363 121e BF4F      		sbci r27,-1
 3364 1220 8D91      		ld r24,X+
 3365 1222 9C91      		ld r25,X
 3366 1224 1197      		sbiw r26,1
 3367 1226 6817      		cp r22,r24
 3368 1228 7907      		cpc r23,r25
 3369 122a 00F0      		brlo .L156
 471:motorctrl.c   ****         //Execute move only if it is outside of hysteresis window
 3371               	.LM288:
 3372 122c 1296      		adiw r26,2
 3373 122e 8D91      		ld r24,X+
 3374 1230 9C91      		ld r25,X
 3375 1232 8617      		cp r24,r22
 3376 1234 9707      		cpc r25,r23
 3377 1236 00F0      		brlo .L156
 473:motorctrl.c   ****             if (m->current_length < m->set_length - m->length_hysteresis){ 
 3379               	.LM289:
 3380 1238 23A1      		ldd r18,Z+35
 3381 123a 34A1      		ldd r19,Z+36
 3382 123c 85A1      		ldd r24,Z+37
 3383 123e 96A1      		ldd r25,Z+38
 3384 1240 45A5      		ldd r20,Z+45
 3385 1242 840F      		add r24,r20
 3386 1244 911D      		adc r25,__zero_reg__
 3387 1246 8217      		cp r24,r18
 3388 1248 9307      		cpc r25,r19
 3389 124a 00F4      		brsh .L157
 3390               	.LBB298:
 3391               	.LBB299:
 474:motorctrl.c   ****                 m->set_length = length;
 3393               	.LM290:
 3394 124c 23A1      		ldd r18,Z+35
 3395 124e 34A1      		ldd r19,Z+36
 3396 1250 85A1      		ldd r24,Z+37
 3397 1252 96A1      		ldd r25,Z+38
 3398 1254 45A5      		ldd r20,Z+45
 3399 1256 841B      		sub r24,r20
 3400 1258 9109      		sbc r25,__zero_reg__
 3401 125a 2817      		cp r18,r24
 3402 125c 3907      		cpc r19,r25
 3403 125e 00F0      		brlo .L158
 3404               	.L157:
 3405               	.LBB300:
 3406               	.LBB301:
 445:motorctrl.c   ****      }
 3408               	.LM291:
 3409 1260 80E0      		ldi r24,0
 3410 1262 0895      		ret
 3411               	.L156:
 3412               	.LBE301:
 3413               	.LBE300:
 3414               	.LBE299:
 3415               	.LBE298:
 484:motorctrl.c   ****     }
 3417               	.LM292:
 3418 1264 81E0      		ldi r24,lo8(1)
 486:motorctrl.c   **** 
 3420               	.LM293:
 3421 1266 0895      		ret
 3422               	.L158:
 3423               	.LBB307:
 3424               	.LBB306:
 475:motorctrl.c   ****                 m->status = WAITING;
 3426               	.LM294:
 3427 1268 76A3      		std Z+38,r23
 3428 126a 65A3      		std Z+37,r22
 476:motorctrl.c   **** 
 3430               	.LM295:
 3431 126c 86E0      		ldi r24,lo8(6)
 3432 126e DF01      		movw r26,r30
 3433 1270 A15B      		subi r26,-79
 3434 1272 BF4F      		sbci r27,-1
 3435 1274 8C93      		st X,r24
 3436               	.LBB305:
 3437               	.LBB304:
 444:motorctrl.c   ****          m->move_length_mm = m->set_length - m->current_length;
 3439               	.LM296:
 3440 1276 23A1      		ldd r18,Z+35
 3441 1278 34A1      		ldd r19,Z+36
 3442 127a 85A1      		ldd r24,Z+37
 3443 127c 96A1      		ldd r25,Z+38
 3444 127e 2817      		cp r18,r24
 3445 1280 3907      		cpc r19,r25
 3446 1282 00F0      		brlo .L159
 447:motorctrl.c   ****          m->move_length_mm = m->current_length - m->set_length;
 3448               	.LM297:
 3449 1284 23A1      		ldd r18,Z+35
 3450 1286 34A1      		ldd r19,Z+36
 3451 1288 85A1      		ldd r24,Z+37
 3452 128a 96A1      		ldd r25,Z+38
 3453 128c 8217      		cp r24,r18
 3454 128e 9307      		cpc r25,r19
 3455 1290 00F4      		brsh .L157
 3456               	.LBB302:
 3457               	.LBB303:
 448:motorctrl.c   ****      }
 3459               	.LM298:
 3460 1292 83A1      		ldd r24,Z+35
 3461 1294 94A1      		ldd r25,Z+36
 3462 1296 25A1      		ldd r18,Z+37
 3463 1298 36A1      		ldd r19,Z+38
 3464 129a 821B      		sub r24,r18
 3465 129c 930B      		sbc r25,r19
 3466 129e EE59      		subi r30,-98
 3467 12a0 FF4F      		sbci r31,-1
 3468 12a2 9183      		std Z+1,r25
 3469 12a4 8083      		st Z,r24
 3470 12a6 80E0      		ldi r24,0
 3471 12a8 0895      		ret
 3472               	.L159:
 3473               	.LBE303:
 3474               	.LBE302:
 445:motorctrl.c   ****      }
 3476               	.LM299:
 3477 12aa 25A1      		ldd r18,Z+37
 3478 12ac 36A1      		ldd r19,Z+38
 3479 12ae 83A1      		ldd r24,Z+35
 3480 12b0 94A1      		ldd r25,Z+36
 3481 12b2 281B      		sub r18,r24
 3482 12b4 390B      		sbc r19,r25
 3483 12b6 EE59      		subi r30,-98
 3484 12b8 FF4F      		sbci r31,-1
 3485 12ba 3183      		std Z+1,r19
 3486 12bc 2083      		st Z,r18
 3487 12be 00C0      		rjmp .L157
 3488               	.LBE304:
 3489               	.LBE305:
 3490               	.LBE306:
 3491               	.LBE307:
 3493               	.Lscope41:
 3497               	.global	calculateMoveSpeed
 3499               	calculateMoveSpeed:
 542:motorctrl.c   ****     if (tick > 0 && m->move_length_mm > 0){
 3501               	.LM300:
 3502               	.LFBB42:
 3503 12c0 A0E0      		ldi r26,0
 3504 12c2 B0E0      		ldi r27,0
 3505 12c4 E0E0      		ldi r30,lo8(gs(1f))
 3506 12c6 F0E0      		ldi r31,hi8(gs(1f))
 3507 12c8 0C94 0000 		jmp __prologue_saves__+((18 - 8) * 2)
 3508               	1:
 3509               	/* prologue: function */
 3510               	/* frame size = 0 */
 3511               	/* stack size = 8 */
 3512               	.L__stack_usage = 8
 543:motorctrl.c   ****         float milliseconds = tick;
 3514               	.LM301:
 3515 12cc 6115      		cp r22,__zero_reg__
 3516 12ce 7105      		cpc r23,__zero_reg__
 3517 12d0 01F0      		breq .L161
 543:motorctrl.c   ****         float milliseconds = tick;
 3519               	.LM302:
 3520 12d2 FC01      		movw r30,r24
 3521 12d4 EE59      		subi r30,-98
 3522 12d6 FF4F      		sbci r31,-1
 3523 12d8 2081      		ld r18,Z
 3524 12da 3181      		ldd r19,Z+1
 3525 12dc 232B      		or r18,r19
 3526 12de 01F4      		brne .L169
 3527               	.L161:
 549:motorctrl.c   ****     }
 3529               	.LM303:
 3530 12e0 FC01      		movw r30,r24
 3531 12e2 E25A      		subi r30,-94
 3532 12e4 FF4F      		sbci r31,-1
 3533 12e6 1082      		st Z,__zero_reg__
 3534 12e8 1182      		std Z+1,__zero_reg__
 3535 12ea 1282      		std Z+2,__zero_reg__
 3536 12ec 1382      		std Z+3,__zero_reg__
 3537               	/* epilogue start */
 551:motorctrl.c   **** 
 3539               	.LM304:
 3540 12ee CDB7      		in r28,__SP_L__
 3541 12f0 DEB7      		in r29,__SP_H__
 3542 12f2 E8E0      		ldi r30, lo8(8)
 3543 12f4 0C94 0000 		jmp __epilogue_restores__ + ((18 - 8) * 2)
 3544 12f8 00C0      		rjmp .L170
 3545               	.L169:
 3546 12fa 8B01      		movw r16,r22
 3547 12fc EC01      		movw r28,r24
 3548               	.LBB311:
 3549               	.LBB312:
 545:motorctrl.c   ****         m->move_speed_mm = mlen / (milliseconds/100);
 3551               	.LM305:
 3552 12fe 6081      		ld r22,Z
 3553 1300 7181      		ldd r23,Z+1
 3554 1302 80E0      		ldi r24,0
 3555 1304 90E0      		ldi r25,0
 3556 1306 0E94 0000 		call __floatunsisf
 3557 130a 6B01      		movw r12,r22
 3558 130c 7C01      		movw r14,r24
 544:motorctrl.c   ****         float mlen = m->move_length_mm;
 3560               	.LM306:
 3561 130e B801      		movw r22,r16
 3562 1310 80E0      		ldi r24,0
 3563 1312 90E0      		ldi r25,0
 3564 1314 0E94 0000 		call __floatunsisf
 546:motorctrl.c   ****     }
 3566               	.LM307:
 3567 1318 20E0      		ldi r18,0
 3568 131a 30E0      		ldi r19,0
 3569 131c 48EC      		ldi r20,lo8(-56)
 3570 131e 52E4      		ldi r21,lo8(66)
 3571 1320 0E94 0000 		call __divsf3
 3572 1324 9B01      		movw r18,r22
 3573 1326 AC01      		movw r20,r24
 3574 1328 C701      		movw r24,r14
 3575 132a B601      		movw r22,r12
 3576 132c 0E94 0000 		call __divsf3
 3577 1330 C25A      		subi r28,-94
 3578 1332 DF4F      		sbci r29,-1
 3579 1334 6883      		st Y,r22
 3580 1336 7983      		std Y+1,r23
 3581 1338 8A83      		std Y+2,r24
 3582 133a 9B83      		std Y+3,r25
 3583               	/* epilogue start */
 3584               	.LBE312:
 3585               	.LBE311:
 551:motorctrl.c   **** 
 3587               	.LM308:
 3588 133c CDB7      		in r28,__SP_L__
 3589 133e DEB7      		in r29,__SP_H__
 3590 1340 E8E0      		ldi r30, lo8(8)
 3591 1342 0C94 0000 		jmp __epilogue_restores__ + ((18 - 8) * 2)
 3592               	.L170:
 3594               	.Lscope42:
 3595               		.section	.rodata.str1.1,"aMS",@progbits,1
 3596               	.LC0:
 3597 0000 2564 0A00 		.string	"%d\n"
 3598               	.LC1:
 3599 0004 2566 204D 		.string	"%f Max:%f\n"
 3599      6178 3A25 
 3599      660A 00
 3600               		.text
 3602               	.global	calibrateMotors
 3604               	calibrateMotors:
 583:motorctrl.c   ****     //return;
 3606               	.LM309:
 3607               	.LFBB43:
 3608 1346 A0E0      		ldi r26,0
 3609 1348 B0E0      		ldi r27,0
 3610 134a E0E0      		ldi r30,lo8(gs(1f))
 3611 134c F0E0      		ldi r31,hi8(gs(1f))
 3612 134e 0C94 0000 		jmp __prologue_saves__+((18 - 18) * 2)
 3613               	1:
 3614               	/* prologue: function */
 3615               	/* frame size = 0 */
 3616               	/* stack size = 18 */
 3617               	.L__stack_usage = 18
 3618               	.LBB340:
 3619 1352 E12C      		mov r14,__zero_reg__
 3620 1354 F12C      		mov r15,__zero_reg__
 3621               	.LBB341:
 586:motorctrl.c   ****         fprintf(port, "%d\n",i);
 3623               	.LM310:
 3624 1356 30E0      		ldi r19,lo8(__c.2321)
 3625 1358 832E      		mov r8,r19
 3626 135a 30E0      		ldi r19,hi8(__c.2321)
 3627 135c 932E      		mov r9,r19
 587:motorctrl.c   ****         volatile motor *m = &motors[i];
 3629               	.LM311:
 3630 135e 40E0      		ldi r20,lo8(.LC0)
 3631 1360 C42E      		mov r12,r20
 3632 1362 40E0      		ldi r20,hi8(.LC0)
 3633 1364 D42E      		mov r13,r20
 591:motorctrl.c   ****         uint16_t lastval = 0; // AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
 3635               	.LM312:
 3636 1366 54E6      		ldi r21,lo8(100)
 3637 1368 552E      		mov r5,r21
 3638               	.LBB342:
 3639               	.LBB343:
 3640               	.LBB344:
 3641               	.LBB345:
 702:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 3643               	.LM313:
 3644 136a AA24      		clr r10
 3645 136c A394      		inc r10
 3646 136e B12C      		mov r11,__zero_reg__
 3647               	.LBE345:
 3648               	.LBE344:
 3649               	.LBE343:
 3650               	.LBE342:
 619:motorctrl.c   ****         float min = minval;
 3652               	.LM314:
 3653 1370 70E0      		ldi r23,lo8(__c.2341)
 3654 1372 272E      		mov r2,r23
 3655 1374 70E0      		ldi r23,hi8(__c.2341)
 3656 1376 372E      		mov r3,r23
 3657               	.L182:
 586:motorctrl.c   ****         fprintf(port, "%d\n",i);
 3659               	.LM315:
 3660 1378 9F92      		push r9
 3661 137a 8F92      		push r8
 3662 137c 8091 0000 		lds r24,port+1
 3663 1380 8F93      		push r24
 3664 1382 8091 0000 		lds r24,port
 3665 1386 8F93      		push r24
 3666 1388 0E94 0000 		call fprintf_P
 587:motorctrl.c   ****         volatile motor *m = &motors[i];
 3668               	.LM316:
 3669 138c FF92      		push r15
 3670 138e EF92      		push r14
 3671 1390 DF92      		push r13
 3672 1392 CF92      		push r12
 3673 1394 8091 0000 		lds r24,port+1
 3674 1398 8F93      		push r24
 3675 139a 8091 0000 		lds r24,port
 3676 139e 8F93      		push r24
 3677 13a0 0E94 0000 		call fprintf
 591:motorctrl.c   ****         uint16_t lastval = 0; // AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
 3679               	.LM317:
 3680 13a4 5E9C      		mul r5,r14
 3681 13a6 F001      		movw r30,r0
 3682 13a8 5F9C      		mul r5,r15
 3683 13aa F00D      		add r31,r0
 3684 13ac 1124      		clr __zero_reg__
 3685 13ae E050      		subi r30,lo8(-(motors))
 3686 13b0 F040      		sbci r31,hi8(-(motors))
 3687 13b2 86A5      		ldd r24,Z+46
 3688               	.LBB350:
 3689               	.LBB348:
 713:motorctrl.c   **** } 
 714:motorctrl.c   **** //volatile uint8_t *OCRC_ADDR[] = {&OCR1CL, &OCR4AL }
 715:motorctrl.c   **** //volatile uint8_t *OCRB_ADDR[] = {&OCR1BL, &OCR4BL }
 716:motorctrl.c   **** 
 717:motorctrl.c   **** void setMotor(volatile motor *m, uint8_t dir, uint8_t pwm){
 718:motorctrl.c   ****     m->current_pwm = pwm;
 3691               	.LM318:
 3692 13b4 81A3      		std Z+33,r24
 719:motorctrl.c   ****     if (pwm > 0){
 3694               	.LM319:
 3695 13b6 2DB7      		in r18,__SP_L__
 3696 13b8 3EB7      		in r19,__SP_H__
 3697 13ba 265F      		subi r18,-10
 3698 13bc 3F4F      		sbci r19,-1
 3699 13be 0FB6      		in __tmp_reg__,__SREG__
 3700 13c0 F894      		cli
 3701 13c2 3EBF      		out __SP_H__,r19
 3702 13c4 0FBE      		out __SREG__,__tmp_reg__
 3703 13c6 2DBF      		out __SP_L__,r18
 3704 13c8 8823      		tst r24
 3705 13ca 01F4      		brne .+2
 3706 13cc 00C0      		rjmp .L172
 720:motorctrl.c   ****         if (dir == FORWARD){ //Forward
 721:motorctrl.c   ****             *m->rev_OCR_addr = 0x00; //PWM pulse width
 3708               	.LM320:
 3709 13ce A08D      		ldd r26,Z+24
 3710 13d0 B18D      		ldd r27,Z+25
 3711 13d2 1C92      		st X,__zero_reg__
 722:motorctrl.c   ****             *m->fwd_OCR_addr = pwm; 
 3713               	.LM321:
 3714 13d4 A385      		ldd r26,Z+11
 3715 13d6 B485      		ldd r27,Z+12
 3716 13d8 8C93      		st X,r24
 723:motorctrl.c   ****             *m->rev_port_addr &= ~(1<<m->rev_pin);
 3718               	.LM322:
 3719 13da 8189      		ldd r24,Z+17
 3720 13dc A585      		ldd r26,Z+13
 3721 13de B685      		ldd r27,Z+14
 3722 13e0 2C91      		ld r18,X
 3723 13e2 A501      		movw r20,r10
 3724 13e4 00C0      		rjmp 2f
 3725               		1:
 3726 13e6 440F      		lsl r20
 3727 13e8 551F      		rol r21
 3728               		2:
 3729 13ea 8A95      		dec r24
 3730 13ec 02F4      		brpl 1b
 3731 13ee CA01      		movw r24,r20
 3732 13f0 8095      		com r24
 3733 13f2 9095      		com r25
 3734 13f4 8223      		and r24,r18
 3735 13f6 8C93      		st X,r24
 724:motorctrl.c   ****             *m->rev_TCCRA_addr = 0x00; //Disable reverse
 3737               	.LM323:
 3738 13f8 A289      		ldd r26,Z+18
 3739 13fa B389      		ldd r27,Z+19
 3740 13fc 1C92      		st X,__zero_reg__
 725:motorctrl.c   ****             *m->fwd_TCCRA_addr = m->fwd_TCCRA_value; //Activate PWM forward
 3742               	.LM324:
 3743 13fe A581      		ldd r26,Z+5
 3744 1400 B681      		ldd r27,Z+6
 3745 1402 8781      		ldd r24,Z+7
 3746 1404 8C93      		st X,r24
 726:motorctrl.c   ****             
 727:motorctrl.c   ****             *m->rev_TCCRB_addr = 0x00; //Disable clock Rev
 3748               	.LM325:
 3749 1406 A589      		ldd r26,Z+21
 3750 1408 B689      		ldd r27,Z+22
 3751 140a 1C92      		st X,__zero_reg__
 728:motorctrl.c   ****             *m->fwd_TCCRB_addr = m->fwd_TCCRB_value;
 3753               	.LM326:
 3754 140c A085      		ldd r26,Z+8
 3755 140e B185      		ldd r27,Z+9
 3756 1410 8285      		ldd r24,Z+10
 3757 1412 8C93      		st X,r24
 729:motorctrl.c   ****         }
 730:motorctrl.c   ****         else{ //Backward
 731:motorctrl.c   ****             *m->fwd_OCR_addr = 0x00;
 732:motorctrl.c   ****             *m->rev_OCR_addr = pwm; 
 733:motorctrl.c   ****             *m->fwd_port_addr &= ~(1<<m->fwd_pin);
 734:motorctrl.c   ****             *m->fwd_TCCRA_addr = 0x00; //Disable FWD
 735:motorctrl.c   ****             *m->rev_TCCRA_addr = m->rev_TCCRA_value;
 736:motorctrl.c   **** 
 737:motorctrl.c   ****             *m->fwd_TCCRB_addr = 0x00;
 738:motorctrl.c   ****             *m->rev_TCCRB_addr = m->rev_TCCRB_value;
 739:motorctrl.c   ****         }        
 740:motorctrl.c   ****         *m->enable_port_addr |= 1<<m->enable_pin; 
 3759               	.LM327:
 3760 1414 868D      		ldd r24,Z+30
 3761 1416 028C      		ldd __tmp_reg__,Z+26
 3762 1418 F38D      		ldd r31,Z+27
 3763 141a E02D      		mov r30,__tmp_reg__
 3764 141c 2081      		ld r18,Z
 3765 141e D501      		movw r26,r10
 3766 1420 00C0      		rjmp 2f
 3767               		1:
 3768 1422 AA0F      		lsl r26
 3769 1424 BB1F      		rol r27
 3770               		2:
 3771 1426 8A95      		dec r24
 3772 1428 02F4      		brpl 1b
 3773 142a CD01      		movw r24,r26
 3774 142c 822B      		or r24,r18
 3775 142e 8083      		st Z,r24
 3776               	.L173:
 3777               	.LBE348:
 3778               	.LBE350:
 3779               	.LBB351:
 3780               	.LBB352:
 3782               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 3784               	.LM328:
 3785 1430 5FEF      		ldi r21,lo8(1599999)
 3786 1432 89E6      		ldi r24,hi8(1599999)
 3787 1434 98E1      		ldi r25,hlo8(1599999)
 3788 1436 5150      	1:	subi r21,1
 3789 1438 8040      		sbci r24,0
 3790 143a 9040      		sbci r25,0
 3791 143c 01F4      		brne 1b
 3792 143e 00C0      		rjmp .
 3793 1440 0000      		nop
 3794 1442 94E6      		ldi r25,lo8(100)
 3795 1444 492E      		mov r4,r25
 3796               	.LBE352:
 3797               	.LBE351:
 3799               	.Ltext2:
 592:motorctrl.c   ****         _delay_ms(500);
 3801               	.LM329:
 3802 1446 612C      		mov r6,__zero_reg__
 3803 1448 712C      		mov r7,__zero_reg__
 3804               	.LBB353:
 3805               	.LBB354:
 595:motorctrl.c   ****             if (value > lastval - CALIBRATION_HYSTERESIS && value < lastval + CALIBRATION_HYSTERESI
 3807               	.LM330:
 3808 144a 5E9C      		mul r5,r14
 3809 144c 8001      		movw r16,r0
 3810 144e 5F9C      		mul r5,r15
 3811 1450 100D      		add r17,r0
 3812 1452 1124      		clr __zero_reg__
 3813 1454 0050      		subi r16,lo8(-(motors+31))
 3814 1456 1040      		sbci r17,hi8(-(motors+31))
 3815 1458 00C0      		rjmp .L176
 3816               	.L174:
 3817               	.LBB355:
 3818               	.LBB356:
 3820               	.Ltext3:
 3822               	.LM331:
 3823 145a 5FEF      		ldi r21,lo8(1599999)
 3824 145c 89E6      		ldi r24,hi8(1599999)
 3825 145e 98E1      		ldi r25,hlo8(1599999)
 3826 1460 5150      	1:	subi r21,1
 3827 1462 8040      		sbci r24,0
 3828 1464 9040      		sbci r25,0
 3829 1466 01F4      		brne 1b
 3830 1468 00C0      		rjmp .
 3831 146a 0000      		nop
 3832 146c 4A94      		dec r4
 3833               	.LBE356:
 3834               	.LBE355:
 3836               	.Ltext4:
 595:motorctrl.c   ****             if (value > lastval - CALIBRATION_HYSTERESIS && value < lastval + CALIBRATION_HYSTERESI
 3838               	.LM332:
 3839 146e 3E01      		movw r6,r28
 3840               	.LBE354:
 594:motorctrl.c   ****             uint16_t value = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
 3842               	.LM333:
 3843 1470 4420      		tst r4
 3844 1472 01F4      		brne .+2
 3845 1474 00C0      		rjmp .L186
 3846               	.L176:
 3847               	.LBB357:
 595:motorctrl.c   ****             if (value > lastval - CALIBRATION_HYSTERESIS && value < lastval + CALIBRATION_HYSTERESI
 3849               	.LM334:
 3850 1476 D801      		movw r26,r16
 3851 1478 8C91      		ld r24,X
 3852 147a 44E0      		ldi r20,lo8(4)
 3853 147c 60E4      		ldi r22,lo8(64)
 3854 147e 0E94 0000 		call AVGVoltage
 3855 1482 EC01      		movw r28,r24
 596:motorctrl.c   ****                 fprintf_P(port, PSTR("FW min: "));
 3857               	.LM335:
 3858 1484 C301      		movw r24,r6
 3859 1486 0297      		sbiw r24,2
 3860 1488 8C17      		cp r24,r28
 3861 148a 9D07      		cpc r25,r29
 3862 148c 00F4      		brsh .L174
 596:motorctrl.c   ****                 fprintf_P(port, PSTR("FW min: "));
 3864               	.LM336:
 3865 148e B2E0      		ldi r27,2
 3866 1490 6B0E      		add r6,r27
 3867 1492 711C      		adc r7,__zero_reg__
 3868 1494 C615      		cp r28,r6
 3869 1496 D705      		cpc r29,r7
 3870 1498 00F4      		brsh .L174
 597:motorctrl.c   ****                 fprintf(port, "%d\n",value);
 3872               	.LM337:
 3873 149a A0E0      		ldi r26,lo8(__c.2329)
 3874 149c B0E0      		ldi r27,hi8(__c.2329)
 3875 149e BF93      		push r27
 3876 14a0 AF93      		push r26
 3877 14a2 8091 0000 		lds r24,port+1
 3878 14a6 8F93      		push r24
 3879 14a8 8091 0000 		lds r24,port
 3880 14ac 8F93      		push r24
 3881 14ae 0E94 0000 		call fprintf_P
 598:motorctrl.c   ****                 minval = value;
 3883               	.LM338:
 3884 14b2 DF93      		push r29
 3885 14b4 CF93      		push r28
 3886 14b6 DF92      		push r13
 3887 14b8 CF92      		push r12
 3888 14ba 8091 0000 		lds r24,port+1
 3889 14be 8F93      		push r24
 3890 14c0 8091 0000 		lds r24,port
 3891 14c4 8F93      		push r24
 3892 14c6 0E94 0000 		call fprintf
 600:motorctrl.c   ****             }
 3894               	.LM339:
 3895 14ca 4DB7      		in r20,__SP_L__
 3896 14cc 5EB7      		in r21,__SP_H__
 3897 14ce 465F      		subi r20,-10
 3898 14d0 5F4F      		sbci r21,-1
 3899 14d2 0FB6      		in __tmp_reg__,__SREG__
 3900 14d4 F894      		cli
 3901 14d6 5EBF      		out __SP_H__,r21
 3902 14d8 0FBE      		out __SREG__,__tmp_reg__
 3903 14da 4DBF      		out __SP_L__,r20
 3904               	.L175:
 3905               	.LBE357:
 3906               	.LBE353:
 605:motorctrl.c   ****         lastval = 0; //AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
 3908               	.LM340:
 3909 14dc 5E9C      		mul r5,r14
 3910 14de F001      		movw r30,r0
 3911 14e0 5F9C      		mul r5,r15
 3912 14e2 F00D      		add r31,r0
 3913 14e4 1124      		clr __zero_reg__
 3914 14e6 E050      		subi r30,lo8(-(motors))
 3915 14e8 F040      		sbci r31,hi8(-(motors))
 3916 14ea 86A5      		ldd r24,Z+46
 3917               	.LBB358:
 3918               	.LBB359:
 718:motorctrl.c   ****     if (pwm > 0){
 3920               	.LM341:
 3921 14ec 81A3      		std Z+33,r24
 719:motorctrl.c   ****         if (dir == FORWARD){ //Forward
 3923               	.LM342:
 3924 14ee 8823      		tst r24
 3925 14f0 01F4      		brne .+2
 3926 14f2 00C0      		rjmp .L177
 731:motorctrl.c   ****             *m->rev_OCR_addr = pwm; 
 3928               	.LM343:
 3929 14f4 A385      		ldd r26,Z+11
 3930 14f6 B485      		ldd r27,Z+12
 3931 14f8 1C92      		st X,__zero_reg__
 732:motorctrl.c   ****             *m->fwd_port_addr &= ~(1<<m->fwd_pin);
 3933               	.LM344:
 3934 14fa A08D      		ldd r26,Z+24
 3935 14fc B18D      		ldd r27,Z+25
 3936 14fe 8C93      		st X,r24
 733:motorctrl.c   ****             *m->fwd_TCCRA_addr = 0x00; //Disable FWD
 3938               	.LM345:
 3939 1500 8481      		ldd r24,Z+4
 3940 1502 A081      		ld r26,Z
 3941 1504 B181      		ldd r27,Z+1
 3942 1506 2C91      		ld r18,X
 3943 1508 A501      		movw r20,r10
 3944 150a 00C0      		rjmp 2f
 3945               		1:
 3946 150c 440F      		lsl r20
 3947 150e 551F      		rol r21
 3948               		2:
 3949 1510 8A95      		dec r24
 3950 1512 02F4      		brpl 1b
 3951 1514 CA01      		movw r24,r20
 3952 1516 8095      		com r24
 3953 1518 9095      		com r25
 3954 151a 8223      		and r24,r18
 3955 151c 8C93      		st X,r24
 734:motorctrl.c   ****             *m->rev_TCCRA_addr = m->rev_TCCRA_value;
 3957               	.LM346:
 3958 151e A581      		ldd r26,Z+5
 3959 1520 B681      		ldd r27,Z+6
 3960 1522 1C92      		st X,__zero_reg__
 735:motorctrl.c   **** 
 3962               	.LM347:
 3963 1524 A289      		ldd r26,Z+18
 3964 1526 B389      		ldd r27,Z+19
 3965 1528 8489      		ldd r24,Z+20
 3966 152a 8C93      		st X,r24
 737:motorctrl.c   ****             *m->rev_TCCRB_addr = m->rev_TCCRB_value;
 3968               	.LM348:
 3969 152c A085      		ldd r26,Z+8
 3970 152e B185      		ldd r27,Z+9
 3971 1530 1C92      		st X,__zero_reg__
 738:motorctrl.c   ****         }        
 3973               	.LM349:
 3974 1532 A589      		ldd r26,Z+21
 3975 1534 B689      		ldd r27,Z+22
 3976 1536 8789      		ldd r24,Z+23
 3977 1538 8C93      		st X,r24
 3979               	.LM350:
 3980 153a 868D      		ldd r24,Z+30
 3981 153c 028C      		ldd __tmp_reg__,Z+26
 3982 153e F38D      		ldd r31,Z+27
 3983 1540 E02D      		mov r30,__tmp_reg__
 3984 1542 2081      		ld r18,Z
 3985 1544 D501      		movw r26,r10
 3986 1546 00C0      		rjmp 2f
 3987               		1:
 3988 1548 AA0F      		lsl r26
 3989 154a BB1F      		rol r27
 3990               		2:
 3991 154c 8A95      		dec r24
 3992 154e 02F4      		brpl 1b
 3993 1550 CD01      		movw r24,r26
 3994 1552 822B      		or r24,r18
 3995 1554 8083      		st Z,r24
 3996               	.L178:
 3997               	.LBE359:
 3998               	.LBE358:
 3999               	.LBB363:
 4000               	.LBB364:
 4002               	.Ltext5:
 4004               	.LM351:
 4005 1556 5FEF      		ldi r21,lo8(1599999)
 4006 1558 89E6      		ldi r24,hi8(1599999)
 4007 155a 98E1      		ldi r25,hlo8(1599999)
 4008 155c 5150      	1:	subi r21,1
 4009 155e 8040      		sbci r24,0
 4010 1560 9040      		sbci r25,0
 4011 1562 01F4      		brne 1b
 4012 1564 00C0      		rjmp .
 4013 1566 0000      		nop
 4014 1568 84E6      		ldi r24,lo8(100)
 4015 156a 482E      		mov r4,r24
 4016               	.LBE364:
 4017               	.LBE363:
 4019               	.Ltext6:
 606:motorctrl.c   ****         _delay_ms(500);
 4021               	.LM352:
 4022 156c 612C      		mov r6,__zero_reg__
 4023 156e 712C      		mov r7,__zero_reg__
 4024               	.LBB365:
 4025               	.LBB366:
 609:motorctrl.c   ****             if (value > lastval - CALIBRATION_HYSTERESIS && value < lastval + CALIBRATION_HYSTERESI
 4027               	.LM353:
 4028 1570 5E9C      		mul r5,r14
 4029 1572 8001      		movw r16,r0
 4030 1574 5F9C      		mul r5,r15
 4031 1576 100D      		add r17,r0
 4032 1578 1124      		clr __zero_reg__
 4033 157a 0050      		subi r16,lo8(-(motors+31))
 4034 157c 1040      		sbci r17,hi8(-(motors+31))
 4035 157e 00C0      		rjmp .L181
 4036               	.L179:
 4037               	.LBB367:
 4038               	.LBB368:
 4040               	.Ltext7:
 4042               	.LM354:
 4043 1580 3FEF      		ldi r19,lo8(1599999)
 4044 1582 49E6      		ldi r20,hi8(1599999)
 4045 1584 58E1      		ldi r21,hlo8(1599999)
 4046 1586 3150      	1:	subi r19,1
 4047 1588 4040      		sbci r20,0
 4048 158a 5040      		sbci r21,0
 4049 158c 01F4      		brne 1b
 4050 158e 00C0      		rjmp .
 4051 1590 0000      		nop
 4052 1592 4A94      		dec r4
 4053               	.LBE368:
 4054               	.LBE367:
 4056               	.Ltext8:
 609:motorctrl.c   ****             if (value > lastval - CALIBRATION_HYSTERESIS && value < lastval + CALIBRATION_HYSTERESI
 4058               	.LM355:
 4059 1594 3C01      		movw r6,r24
 4060               	.LBE366:
 608:motorctrl.c   ****             uint16_t value = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
 4062               	.LM356:
 4063 1596 4420      		tst r4
 4064 1598 01F4      		brne .+2
 4065 159a 00C0      		rjmp .L187
 4066               	.L181:
 4067               	.LBB369:
 609:motorctrl.c   ****             if (value > lastval - CALIBRATION_HYSTERESIS && value < lastval + CALIBRATION_HYSTERESI
 4069               	.LM357:
 4070 159c D801      		movw r26,r16
 4071 159e 8C91      		ld r24,X
 4072 15a0 44E0      		ldi r20,lo8(4)
 4073 15a2 60E4      		ldi r22,lo8(64)
 4074 15a4 0E94 0000 		call AVGVoltage
 610:motorctrl.c   ****                 fprintf_P(port, PSTR("RW max: "));
 4076               	.LM358:
 4077 15a8 9301      		movw r18,r6
 4078 15aa 2250      		subi r18,2
 4079 15ac 3109      		sbc r19,__zero_reg__
 4080 15ae 2817      		cp r18,r24
 4081 15b0 3907      		cpc r19,r25
 4082 15b2 00F4      		brsh .L179
 610:motorctrl.c   ****                 fprintf_P(port, PSTR("RW max: "));
 4084               	.LM359:
 4085 15b4 B2E0      		ldi r27,2
 4086 15b6 6B0E      		add r6,r27
 4087 15b8 711C      		adc r7,__zero_reg__
 4088 15ba 8615      		cp r24,r6
 4089 15bc 9705      		cpc r25,r7
 4090 15be 00F4      		brsh .L179
 4091 15c0 8C01      		movw r16,r24
 611:motorctrl.c   ****                 fprintf(port, "%d\n", value);
 4093               	.LM360:
 4094 15c2 A0E0      		ldi r26,lo8(__c.2336)
 4095 15c4 B0E0      		ldi r27,hi8(__c.2336)
 4096 15c6 BF93      		push r27
 4097 15c8 AF93      		push r26
 4098 15ca 8091 0000 		lds r24,port+1
 4099 15ce 8F93      		push r24
 4100 15d0 8091 0000 		lds r24,port
 4101 15d4 8F93      		push r24
 4102 15d6 0E94 0000 		call fprintf_P
 612:motorctrl.c   ****                 maxval = value;
 4104               	.LM361:
 4105 15da 1F93      		push r17
 4106 15dc 0F93      		push r16
 4107 15de DF92      		push r13
 4108 15e0 CF92      		push r12
 4109 15e2 8091 0000 		lds r24,port+1
 4110 15e6 8F93      		push r24
 4111 15e8 8091 0000 		lds r24,port
 4112 15ec 8F93      		push r24
 4113 15ee 0E94 0000 		call fprintf
 614:motorctrl.c   ****             }
 4115               	.LM362:
 4116 15f2 2DB7      		in r18,__SP_L__
 4117 15f4 3EB7      		in r19,__SP_H__
 4118 15f6 265F      		subi r18,-10
 4119 15f8 3F4F      		sbci r19,-1
 4120 15fa 0FB6      		in __tmp_reg__,__SREG__
 4121 15fc F894      		cli
 4122 15fe 3EBF      		out __SP_H__,r19
 4123 1600 0FBE      		out __SREG__,__tmp_reg__
 4124 1602 2DBF      		out __SP_L__,r18
 4125               	.L180:
 4126               	.LBE369:
 4127               	.LBE365:
 619:motorctrl.c   ****         float min = minval;
 4129               	.LM363:
 4130 1604 3F92      		push r3
 4131 1606 2F92      		push r2
 4132 1608 8091 0000 		lds r24,port+1
 4133 160c 8F93      		push r24
 4134 160e 8091 0000 		lds r24,port
 4135 1612 8F93      		push r24
 4136 1614 0E94 0000 		call fprintf_P
 622:motorctrl.c   ****         fprintf(port, "%f Max:%f\n",(4700.0/1024.0)*min,(4700.0/1024.0)*max);
 4138               	.LM364:
 4139 1618 A0E0      		ldi r26,lo8(__c.2345)
 4140 161a B0E0      		ldi r27,hi8(__c.2345)
 4141 161c BF93      		push r27
 4142 161e AF93      		push r26
 4143 1620 8091 0000 		lds r24,port+1
 4144 1624 8F93      		push r24
 4145 1626 8091 0000 		lds r24,port
 4146 162a 8F93      		push r24
 4147 162c 0E94 0000 		call fprintf_P
 621:motorctrl.c   ****         fprintf_P(port, PSTR("Voltage Min:"));
 4149               	.LM365:
 4150 1630 B801      		movw r22,r16
 4151 1632 80E0      		ldi r24,0
 4152 1634 90E0      		ldi r25,0
 4153 1636 0E94 0000 		call __floatunsisf
 623:motorctrl.c   ****     }
 4155               	.LM366:
 4156 163a 20E0      		ldi r18,0
 4157 163c 30EE      		ldi r19,lo8(-32)
 4158 163e 42E9      		ldi r20,lo8(-110)
 4159 1640 50E4      		ldi r21,lo8(64)
 4160 1642 0E94 0000 		call __mulsf3
 4161 1646 9F93      		push r25
 4162 1648 8F93      		push r24
 4163 164a 7F93      		push r23
 4164 164c 6F93      		push r22
 620:motorctrl.c   ****         float max = maxval;
 4166               	.LM367:
 4167 164e BE01      		movw r22,r28
 4168 1650 80E0      		ldi r24,0
 4169 1652 90E0      		ldi r25,0
 4170 1654 0E94 0000 		call __floatunsisf
 623:motorctrl.c   ****     }
 4172               	.LM368:
 4173 1658 20E0      		ldi r18,0
 4174 165a 30EE      		ldi r19,lo8(-32)
 4175 165c 42E9      		ldi r20,lo8(-110)
 4176 165e 50E4      		ldi r21,lo8(64)
 4177 1660 0E94 0000 		call __mulsf3
 4178 1664 9F93      		push r25
 4179 1666 8F93      		push r24
 4180 1668 7F93      		push r23
 4181 166a 6F93      		push r22
 4182 166c A0E0      		ldi r26,lo8(.LC1)
 4183 166e B0E0      		ldi r27,hi8(.LC1)
 4184 1670 BF93      		push r27
 4185 1672 AF93      		push r26
 4186 1674 8091 0000 		lds r24,port+1
 4187 1678 8F93      		push r24
 4188 167a 8091 0000 		lds r24,port
 4189 167e 8F93      		push r24
 4190 1680 0E94 0000 		call fprintf
 4191               	.LBE341:
 585:motorctrl.c   ****         fprintf_P(port, PSTR("calibrating motor:"));
 4193               	.LM369:
 4194 1684 2DB7      		in r18,__SP_L__
 4195 1686 3EB7      		in r19,__SP_H__
 4196 1688 2C5E      		subi r18,-20
 4197 168a 3F4F      		sbci r19,-1
 4198 168c 0FB6      		in __tmp_reg__,__SREG__
 4199 168e F894      		cli
 4200 1690 3EBF      		out __SP_H__,r19
 4201 1692 0FBE      		out __SREG__,__tmp_reg__
 4202 1694 2DBF      		out __SP_L__,r18
 4203 1696 31E0      		ldi r19,1
 4204 1698 E316      		cp r14,r19
 4205 169a F104      		cpc r15,__zero_reg__
 4206 169c 01F4      		brne .L183
 4207               	/* epilogue start */
 4208               	.LBE340:
 625:motorctrl.c   **** 
 4210               	.LM370:
 4211 169e CDB7      		in r28,__SP_L__
 4212 16a0 DEB7      		in r29,__SP_H__
 4213 16a2 E2E1      		ldi r30, lo8(18)
 4214 16a4 0C94 0000 		jmp __epilogue_restores__ + ((18 - 18) * 2)
 4215               	.L183:
 4216               	.LBB373:
 4217 16a8 EE24      		clr r14
 4218 16aa E394      		inc r14
 4219 16ac F12C      		mov r15,__zero_reg__
 4220 16ae 00C0      		rjmp .L182
 4221               	.L177:
 4222               	.LBB372:
 4223               	.LBB370:
 4224               	.LBB362:
 4225               	.LBB360:
 4226               	.LBB361:
 702:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 4228               	.LM371:
 4229 16b0 868D      		ldd r24,Z+30
 4230 16b2 A28D      		ldd r26,Z+26
 4231 16b4 B38D      		ldd r27,Z+27
 4232 16b6 2C91      		ld r18,X
 4233 16b8 A501      		movw r20,r10
 4234 16ba 00C0      		rjmp 2f
 4235               		1:
 4236 16bc 440F      		lsl r20
 4237 16be 551F      		rol r21
 4238               		2:
 4239 16c0 8A95      		dec r24
 4240 16c2 02F4      		brpl 1b
 4241 16c4 CA01      		movw r24,r20
 4242 16c6 8095      		com r24
 4243 16c8 9095      		com r25
 4244 16ca 8223      		and r24,r18
 4245 16cc 8C93      		st X,r24
 703:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 4247               	.LM372:
 4248 16ce A581      		ldd r26,Z+5
 4249 16d0 B681      		ldd r27,Z+6
 4250 16d2 1C92      		st X,__zero_reg__
 704:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 4252               	.LM373:
 4253 16d4 A085      		ldd r26,Z+8
 4254 16d6 B185      		ldd r27,Z+9
 4255 16d8 1C92      		st X,__zero_reg__
 705:motorctrl.c   ****     
 4257               	.LM374:
 4258 16da A385      		ldd r26,Z+11
 4259 16dc B485      		ldd r27,Z+12
 4260 16de 1C92      		st X,__zero_reg__
 708:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 4262               	.LM375:
 4263 16e0 A289      		ldd r26,Z+18
 4264 16e2 B389      		ldd r27,Z+19
 4265 16e4 1C92      		st X,__zero_reg__
 709:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 4267               	.LM376:
 4268 16e6 A589      		ldd r26,Z+21
 4269 16e8 B689      		ldd r27,Z+22
 4270 16ea 1C92      		st X,__zero_reg__
 710:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 4272               	.LM377:
 4273 16ec A08D      		ldd r26,Z+24
 4274 16ee B18D      		ldd r27,Z+25
 4275 16f0 1C92      		st X,__zero_reg__
 711:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 4277               	.LM378:
 4278 16f2 11A2      		std Z+33,__zero_reg__
 712:motorctrl.c   **** } 
 4280               	.LM379:
 4281 16f4 E55B      		subi r30,-75
 4282 16f6 FF4F      		sbci r31,-1
 4283 16f8 1082      		st Z,__zero_reg__
 4284 16fa 1182      		std Z+1,__zero_reg__
 4285 16fc 1282      		std Z+2,__zero_reg__
 4286 16fe 1382      		std Z+3,__zero_reg__
 4287 1700 00C0      		rjmp .L178
 4288               	.L172:
 4289               	.LBE361:
 4290               	.LBE360:
 4291               	.LBE362:
 4292               	.LBE370:
 4293               	.LBB371:
 4294               	.LBB349:
 4295               	.LBB347:
 4296               	.LBB346:
 702:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 4298               	.LM380:
 4299 1702 868D      		ldd r24,Z+30
 4300 1704 A28D      		ldd r26,Z+26
 4301 1706 B38D      		ldd r27,Z+27
 4302 1708 2C91      		ld r18,X
 4303 170a A501      		movw r20,r10
 4304 170c 00C0      		rjmp 2f
 4305               		1:
 4306 170e 440F      		lsl r20
 4307 1710 551F      		rol r21
 4308               		2:
 4309 1712 8A95      		dec r24
 4310 1714 02F4      		brpl 1b
 4311 1716 CA01      		movw r24,r20
 4312 1718 8095      		com r24
 4313 171a 9095      		com r25
 4314 171c 8223      		and r24,r18
 4315 171e 8C93      		st X,r24
 703:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 4317               	.LM381:
 4318 1720 A581      		ldd r26,Z+5
 4319 1722 B681      		ldd r27,Z+6
 4320 1724 1C92      		st X,__zero_reg__
 704:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 4322               	.LM382:
 4323 1726 A085      		ldd r26,Z+8
 4324 1728 B185      		ldd r27,Z+9
 4325 172a 1C92      		st X,__zero_reg__
 705:motorctrl.c   ****     
 4327               	.LM383:
 4328 172c A385      		ldd r26,Z+11
 4329 172e B485      		ldd r27,Z+12
 4330 1730 1C92      		st X,__zero_reg__
 708:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 4332               	.LM384:
 4333 1732 A289      		ldd r26,Z+18
 4334 1734 B389      		ldd r27,Z+19
 4335 1736 1C92      		st X,__zero_reg__
 709:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 4337               	.LM385:
 4338 1738 A589      		ldd r26,Z+21
 4339 173a B689      		ldd r27,Z+22
 4340 173c 1C92      		st X,__zero_reg__
 710:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 4342               	.LM386:
 4343 173e A08D      		ldd r26,Z+24
 4344 1740 B18D      		ldd r27,Z+25
 4345 1742 1C92      		st X,__zero_reg__
 711:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 4347               	.LM387:
 4348 1744 11A2      		std Z+33,__zero_reg__
 712:motorctrl.c   **** } 
 4350               	.LM388:
 4351 1746 E55B      		subi r30,-75
 4352 1748 FF4F      		sbci r31,-1
 4353 174a 1082      		st Z,__zero_reg__
 4354 174c 1182      		std Z+1,__zero_reg__
 4355 174e 1282      		std Z+2,__zero_reg__
 4356 1750 1382      		std Z+3,__zero_reg__
 4357 1752 00C0      		rjmp .L173
 4358               	.L186:
 4359               	.LBE346:
 4360               	.LBE347:
 4361               	.LBE349:
 4362               	.LBE371:
 589:motorctrl.c   ****         uint16_t maxval = 0;
 4364               	.LM389:
 4365 1754 C0E0      		ldi r28,0
 4366 1756 D4E0      		ldi r29,lo8(4)
 4367 1758 00C0      		rjmp .L175
 4368               	.L187:
 590:motorctrl.c   ****         setMotor(m, FORWARD, m->max_pwm);
 4370               	.LM390:
 4371 175a 00E0      		ldi r16,0
 4372 175c 10E0      		ldi r17,0
 4373 175e 00C0      		rjmp .L180
 4374               	.LBE372:
 4375               	.LBE373:
 4377               	.Lscope43:
 4380               	.global	delayLoop_us
 4382               	delayLoop_us:
 627:motorctrl.c   ****     for (uint16_t i = 0; i < delay/50; i++){
 4384               	.LM391:
 4385               	.LFBB44:
 4386               	/* prologue: function */
 4387               	/* frame size = 0 */
 4388               	/* stack size = 0 */
 4389               	.L__stack_usage = 0
 4390               	.LBB374:
 628:motorctrl.c   ****         _delay_us(47);
 4392               	.LM392:
 4393 1760 9C01      		movw r18,r24
 4394 1762 3695      		lsr r19
 4395 1764 2795      		ror r18
 4396 1766 ABE7      		ldi r26,lo8(123)
 4397 1768 B4E1      		ldi r27,lo8(20)
 4398 176a 0E94 0000 		call __umulhisi3
 4399 176e 9695      		lsr r25
 4400 1770 8795      		ror r24
 4401 1772 0097      		sbiw r24,0
 4402 1774 01F0      		breq .L188
 4403 1776 20E0      		ldi r18,0
 4404 1778 30E0      		ldi r19,0
 4405               	.L189:
 4406               	.LBB375:
 4407               	.LBB376:
 4409               	.Ltext9:
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 4411               	.LM393:
 4412 177a 4AEF      		ldi r20,lo8(-6)
 4413 177c 4A95      	1:	dec r20
 4414 177e 01F4      		brne 1b
 4415 1780 00C0      		rjmp .
 4416               	.LBE376:
 4417               	.LBE375:
 4419               	.Ltext10:
 628:motorctrl.c   ****         _delay_us(47);
 4421               	.LM394:
 4422 1782 2F5F      		subi r18,-1
 4423 1784 3F4F      		sbci r19,-1
 4424 1786 2817      		cp r18,r24
 4425 1788 3907      		cpc r19,r25
 4426 178a 01F4      		brne .L189
 4427               	.L188:
 4428 178c 0895      		ret
 4429               	.LBE374:
 4434               	.Lscope44:
 4437               	.global	disableMotorPWM
 4439               	disableMotorPWM:
 700:motorctrl.c   **** 
 4441               	.LM395:
 4442               	.LFBB45:
 4443               	/* prologue: function */
 4444               	/* frame size = 0 */
 4445               	/* stack size = 0 */
 4446               	.L__stack_usage = 0
 4447 178e FC01      		movw r30,r24
 702:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 4449               	.LM396:
 4450 1790 368D      		ldd r19,Z+30
 4451 1792 A28D      		ldd r26,Z+26
 4452 1794 B38D      		ldd r27,Z+27
 4453 1796 2C91      		ld r18,X
 4454 1798 81E0      		ldi r24,lo8(1)
 4455 179a 90E0      		ldi r25,0
 4456 179c 00C0      		rjmp 2f
 4457               		1:
 4458 179e 880F      		lsl r24
 4459 17a0 991F      		rol r25
 4460               		2:
 4461 17a2 3A95      		dec r19
 4462 17a4 02F4      		brpl 1b
 4463 17a6 8095      		com r24
 4464 17a8 9095      		com r25
 4465 17aa 8223      		and r24,r18
 4466 17ac 8C93      		st X,r24
 703:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 4468               	.LM397:
 4469 17ae A581      		ldd r26,Z+5
 4470 17b0 B681      		ldd r27,Z+6
 4471 17b2 1C92      		st X,__zero_reg__
 704:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 4473               	.LM398:
 4474 17b4 A085      		ldd r26,Z+8
 4475 17b6 B185      		ldd r27,Z+9
 4476 17b8 1C92      		st X,__zero_reg__
 705:motorctrl.c   ****     
 4478               	.LM399:
 4479 17ba A385      		ldd r26,Z+11
 4480 17bc B485      		ldd r27,Z+12
 4481 17be 1C92      		st X,__zero_reg__
 708:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 4483               	.LM400:
 4484 17c0 A289      		ldd r26,Z+18
 4485 17c2 B389      		ldd r27,Z+19
 4486 17c4 1C92      		st X,__zero_reg__
 709:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 4488               	.LM401:
 4489 17c6 A589      		ldd r26,Z+21
 4490 17c8 B689      		ldd r27,Z+22
 4491 17ca 1C92      		st X,__zero_reg__
 710:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 4493               	.LM402:
 4494 17cc A08D      		ldd r26,Z+24
 4495 17ce B18D      		ldd r27,Z+25
 4496 17d0 1C92      		st X,__zero_reg__
 711:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 4498               	.LM403:
 4499 17d2 11A2      		std Z+33,__zero_reg__
 712:motorctrl.c   **** } 
 4501               	.LM404:
 4502 17d4 E55B      		subi r30,-75
 4503 17d6 FF4F      		sbci r31,-1
 4504 17d8 1082      		st Z,__zero_reg__
 4505 17da 1182      		std Z+1,__zero_reg__
 4506 17dc 1282      		std Z+2,__zero_reg__
 4507 17de 1382      		std Z+3,__zero_reg__
 4508 17e0 0895      		ret
 4510               	.Lscope45:
 4515               	.global	setMotor
 4517               	setMotor:
 717:motorctrl.c   ****     m->current_pwm = pwm;
 4519               	.LM405:
 4520               	.LFBB46:
 4521               	/* prologue: function */
 4522               	/* frame size = 0 */
 4523               	/* stack size = 0 */
 4524               	.L__stack_usage = 0
 4525 17e2 FC01      		movw r30,r24
 718:motorctrl.c   ****     if (pwm > 0){
 4527               	.LM406:
 4528 17e4 41A3      		std Z+33,r20
 719:motorctrl.c   ****         if (dir == FORWARD){ //Forward
 4530               	.LM407:
 4531 17e6 4423      		tst r20
 4532 17e8 01F0      		breq .L195
 720:motorctrl.c   ****             *m->rev_OCR_addr = 0x00; //PWM pulse width
 4534               	.LM408:
 4535 17ea 6130      		cpi r22,lo8(1)
 4536 17ec 01F4      		brne .+2
 4537 17ee 00C0      		rjmp .L199
 731:motorctrl.c   ****             *m->rev_OCR_addr = pwm; 
 4539               	.LM409:
 4540 17f0 A385      		ldd r26,Z+11
 4541 17f2 B485      		ldd r27,Z+12
 4542 17f4 1C92      		st X,__zero_reg__
 732:motorctrl.c   ****             *m->fwd_port_addr &= ~(1<<m->fwd_pin);
 4544               	.LM410:
 4545 17f6 A08D      		ldd r26,Z+24
 4546 17f8 B18D      		ldd r27,Z+25
 4547 17fa 4C93      		st X,r20
 733:motorctrl.c   ****             *m->fwd_TCCRA_addr = 0x00; //Disable FWD
 4549               	.LM411:
 4550 17fc 3481      		ldd r19,Z+4
 4551 17fe A081      		ld r26,Z
 4552 1800 B181      		ldd r27,Z+1
 4553 1802 2C91      		ld r18,X
 4554 1804 81E0      		ldi r24,lo8(1)
 4555 1806 90E0      		ldi r25,0
 4556 1808 00C0      		rjmp 2f
 4557               		1:
 4558 180a 880F      		lsl r24
 4559 180c 991F      		rol r25
 4560               		2:
 4561 180e 3A95      		dec r19
 4562 1810 02F4      		brpl 1b
 4563 1812 8095      		com r24
 4564 1814 9095      		com r25
 4565 1816 8223      		and r24,r18
 4566 1818 8C93      		st X,r24
 734:motorctrl.c   ****             *m->rev_TCCRA_addr = m->rev_TCCRA_value;
 4568               	.LM412:
 4569 181a A581      		ldd r26,Z+5
 4570 181c B681      		ldd r27,Z+6
 4571 181e 1C92      		st X,__zero_reg__
 735:motorctrl.c   **** 
 4573               	.LM413:
 4574 1820 A289      		ldd r26,Z+18
 4575 1822 B389      		ldd r27,Z+19
 4576 1824 8489      		ldd r24,Z+20
 4577 1826 8C93      		st X,r24
 737:motorctrl.c   ****             *m->rev_TCCRB_addr = m->rev_TCCRB_value;
 4579               	.LM414:
 4580 1828 A085      		ldd r26,Z+8
 4581 182a B185      		ldd r27,Z+9
 4582 182c 1C92      		st X,__zero_reg__
 738:motorctrl.c   ****         }        
 4584               	.LM415:
 4585 182e A589      		ldd r26,Z+21
 4586 1830 B689      		ldd r27,Z+22
 4587 1832 8789      		ldd r24,Z+23
 4588 1834 8C93      		st X,r24
 4589               	.L197:
 4591               	.LM416:
 4592 1836 368D      		ldd r19,Z+30
 4593 1838 028C      		ldd __tmp_reg__,Z+26
 4594 183a F38D      		ldd r31,Z+27
 4595 183c E02D      		mov r30,__tmp_reg__
 4596 183e 2081      		ld r18,Z
 4597 1840 81E0      		ldi r24,lo8(1)
 4598 1842 90E0      		ldi r25,0
 4599 1844 00C0      		rjmp 2f
 4600               		1:
 4601 1846 880F      		lsl r24
 4602               		2:
 4603 1848 3A95      		dec r19
 4604 184a 02F4      		brpl 1b
 4605 184c 822B      		or r24,r18
 4606 184e 8083      		st Z,r24
 4607 1850 0895      		ret
 4608               	.L195:
 4609               	.LBB379:
 4610               	.LBB380:
 702:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 4612               	.LM417:
 4613 1852 368D      		ldd r19,Z+30
 4614 1854 A28D      		ldd r26,Z+26
 4615 1856 B38D      		ldd r27,Z+27
 4616 1858 2C91      		ld r18,X
 4617 185a 81E0      		ldi r24,lo8(1)
 4618 185c 90E0      		ldi r25,0
 4619 185e 00C0      		rjmp 2f
 4620               		1:
 4621 1860 880F      		lsl r24
 4622 1862 991F      		rol r25
 4623               		2:
 4624 1864 3A95      		dec r19
 4625 1866 02F4      		brpl 1b
 4626 1868 8095      		com r24
 4627 186a 9095      		com r25
 4628 186c 8223      		and r24,r18
 4629 186e 8C93      		st X,r24
 703:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 4631               	.LM418:
 4632 1870 A581      		ldd r26,Z+5
 4633 1872 B681      		ldd r27,Z+6
 4634 1874 1C92      		st X,__zero_reg__
 704:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 4636               	.LM419:
 4637 1876 A085      		ldd r26,Z+8
 4638 1878 B185      		ldd r27,Z+9
 4639 187a 1C92      		st X,__zero_reg__
 705:motorctrl.c   ****     
 4641               	.LM420:
 4642 187c A385      		ldd r26,Z+11
 4643 187e B485      		ldd r27,Z+12
 4644 1880 1C92      		st X,__zero_reg__
 708:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 4646               	.LM421:
 4647 1882 A289      		ldd r26,Z+18
 4648 1884 B389      		ldd r27,Z+19
 4649 1886 1C92      		st X,__zero_reg__
 709:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 4651               	.LM422:
 4652 1888 A589      		ldd r26,Z+21
 4653 188a B689      		ldd r27,Z+22
 4654 188c 1C92      		st X,__zero_reg__
 710:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 4656               	.LM423:
 4657 188e A08D      		ldd r26,Z+24
 4658 1890 B18D      		ldd r27,Z+25
 4659 1892 1C92      		st X,__zero_reg__
 711:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 4661               	.LM424:
 4662 1894 11A2      		std Z+33,__zero_reg__
 712:motorctrl.c   **** } 
 4664               	.LM425:
 4665 1896 E55B      		subi r30,-75
 4666 1898 FF4F      		sbci r31,-1
 4667 189a 1082      		st Z,__zero_reg__
 4668 189c 1182      		std Z+1,__zero_reg__
 4669 189e 1282      		std Z+2,__zero_reg__
 4670 18a0 1382      		std Z+3,__zero_reg__
 4671 18a2 0895      		ret
 4672               	.L199:
 4673               	.LBE380:
 4674               	.LBE379:
 721:motorctrl.c   ****             *m->fwd_OCR_addr = pwm; 
 4676               	.LM426:
 4677 18a4 A08D      		ldd r26,Z+24
 4678 18a6 B18D      		ldd r27,Z+25
 4679 18a8 1C92      		st X,__zero_reg__
 722:motorctrl.c   ****             *m->rev_port_addr &= ~(1<<m->rev_pin);
 4681               	.LM427:
 4682 18aa A385      		ldd r26,Z+11
 4683 18ac B485      		ldd r27,Z+12
 4684 18ae 4C93      		st X,r20
 723:motorctrl.c   ****             *m->rev_TCCRA_addr = 0x00; //Disable reverse
 4686               	.LM428:
 4687 18b0 3189      		ldd r19,Z+17
 4688 18b2 A585      		ldd r26,Z+13
 4689 18b4 B685      		ldd r27,Z+14
 4690 18b6 2C91      		ld r18,X
 4691 18b8 81E0      		ldi r24,lo8(1)
 4692 18ba 90E0      		ldi r25,0
 4693 18bc 00C0      		rjmp 2f
 4694               		1:
 4695 18be 880F      		lsl r24
 4696 18c0 991F      		rol r25
 4697               		2:
 4698 18c2 3A95      		dec r19
 4699 18c4 02F4      		brpl 1b
 4700 18c6 8095      		com r24
 4701 18c8 9095      		com r25
 4702 18ca 8223      		and r24,r18
 4703 18cc 8C93      		st X,r24
 724:motorctrl.c   ****             *m->fwd_TCCRA_addr = m->fwd_TCCRA_value; //Activate PWM forward
 4705               	.LM429:
 4706 18ce A289      		ldd r26,Z+18
 4707 18d0 B389      		ldd r27,Z+19
 4708 18d2 1C92      		st X,__zero_reg__
 725:motorctrl.c   ****             
 4710               	.LM430:
 4711 18d4 A581      		ldd r26,Z+5
 4712 18d6 B681      		ldd r27,Z+6
 4713 18d8 8781      		ldd r24,Z+7
 4714 18da 8C93      		st X,r24
 727:motorctrl.c   ****             *m->fwd_TCCRB_addr = m->fwd_TCCRB_value;
 4716               	.LM431:
 4717 18dc A589      		ldd r26,Z+21
 4718 18de B689      		ldd r27,Z+22
 4719 18e0 1C92      		st X,__zero_reg__
 728:motorctrl.c   ****         }
 4721               	.LM432:
 4722 18e2 A085      		ldd r26,Z+8
 4723 18e4 B185      		ldd r27,Z+9
 4724 18e6 8285      		ldd r24,Z+10
 4725 18e8 8C93      		st X,r24
 4726 18ea 00C0      		rjmp .L197
 4728               	.Lscope46:
 4729               		.section	.rodata.str1.1
 4730               	.LC2:
 4731 000f 2564 730A 		.string	"%ds\n"
 4731      00
 4732               	.LC3:
 4733 0014 2564 00   		.string	"%d"
 4734               		.text
 4738               	.global	forceMotors
 4740               	forceMotors:
 554:motorctrl.c   ****     if (dir != FORWARD && dir != BACKWARD){
 4742               	.LM433:
 4743               	.LFBB47:
 4744 18ec A0E0      		ldi r26,0
 4745 18ee B0E0      		ldi r27,0
 4746 18f0 E0E0      		ldi r30,lo8(gs(1f))
 4747 18f2 F0E0      		ldi r31,hi8(gs(1f))
 4748 18f4 0C94 0000 		jmp __prologue_saves__+((18 - 17) * 2)
 4749               	1:
 4750               	/* prologue: function */
 4751               	/* frame size = 0 */
 4752               	/* stack size = 17 */
 4753               	.L__stack_usage = 17
 4754 18f8 C82F      		mov r28,r24
 4755 18fa 862E      		mov r8,r22
 555:motorctrl.c   ****         fprintf_P(port, PSTR("ERR,dir\n"));
 4757               	.LM434:
 4758 18fc 8230      		cpi r24,lo8(2)
 4759 18fe 00F0      		brlo .L201
 556:motorctrl.c   ****         return;
 4761               	.LM435:
 4762 1900 80E0      		ldi r24,lo8(__c.2287)
 4763 1902 90E0      		ldi r25,hi8(__c.2287)
 4764 1904 9F93      		push r25
 4765 1906 8F93      		push r24
 4766 1908 8091 0000 		lds r24,port+1
 4767 190c 8F93      		push r24
 4768 190e 8091 0000 		lds r24,port
 4769 1912 8F93      		push r24
 4770 1914 0E94 0000 		call fprintf_P
 557:motorctrl.c   ****     }
 4772               	.LM436:
 4773 1918 0F90      		pop __tmp_reg__
 4774 191a 0F90      		pop __tmp_reg__
 4775 191c 0F90      		pop __tmp_reg__
 4776 191e 0F90      		pop __tmp_reg__
 4777               	/* epilogue start */
 581:motorctrl.c   **** 
 4779               	.LM437:
 4780 1920 CDB7      		in r28,__SP_L__
 4781 1922 DEB7      		in r29,__SP_H__
 4782 1924 E1E1      		ldi r30, lo8(17)
 4783 1926 0C94 0000 		jmp __epilogue_restores__ + ((18 - 17) * 2)
 4784 192a 00C0      		rjmp .L209
 4785               	.L201:
 559:motorctrl.c   ****     fprintf(port, "%ds\n",time);
 4787               	.LM438:
 4788 192c 80E0      		ldi r24,lo8(__c.2289)
 4789 192e 90E0      		ldi r25,hi8(__c.2289)
 4790 1930 9F93      		push r25
 4791 1932 8F93      		push r24
 4792 1934 8091 0000 		lds r24,port+1
 4793 1938 8F93      		push r24
 4794 193a 8091 0000 		lds r24,port
 4795 193e 8F93      		push r24
 4796 1940 0E94 0000 		call fprintf_P
 560:motorctrl.c   ****     for (uint8_t i=0; i< 1; i++){
 4798               	.LM439:
 4799 1944 1F92      		push __zero_reg__
 4800 1946 8F92      		push r8
 4801 1948 80E0      		ldi r24,lo8(.LC2)
 4802 194a 90E0      		ldi r25,hi8(.LC2)
 4803 194c 9F93      		push r25
 4804 194e 8F93      		push r24
 4805 1950 8091 0000 		lds r24,port+1
 4806 1954 8F93      		push r24
 4807 1956 8091 0000 		lds r24,port
 4808 195a 8F93      		push r24
 4809 195c 0E94 0000 		call fprintf
 4810               	.LBB399:
 4811               	.LBB400:
 563:motorctrl.c   ****     }
 4813               	.LM440:
 4814 1960 4091 0000 		lds r20,motors+46
 4815 1964 6C2F      		mov r22,r28
 4816 1966 80E0      		ldi r24,lo8(motors)
 4817 1968 90E0      		ldi r25,hi8(motors)
 4818 196a 0E94 0000 		call setMotor
 4819               	.LBE400:
 4820               	.LBE399:
 4821               	.LBB401:
 565:motorctrl.c   ****         for (uint8_t j=0;j<2;j++){
 4823               	.LM441:
 4824 196e 24E1      		ldi r18,lo8(20)
 4825 1970 829E      		mul r8,r18
 4826 1972 4001      		movw r8,r0
 4827 1974 1124      		clr __zero_reg__
 4828 1976 8DB7      		in r24,__SP_L__
 4829 1978 9EB7      		in r25,__SP_H__
 4830 197a 0A96      		adiw r24,10
 4831 197c 0FB6      		in __tmp_reg__,__SREG__
 4832 197e F894      		cli
 4833 1980 9EBF      		out __SP_H__,r25
 4834 1982 0FBE      		out __SREG__,__tmp_reg__
 4835 1984 8DBF      		out __SP_L__,r24
 4836 1986 8114      		cp r8,__zero_reg__
 4837 1988 9104      		cpc r9,__zero_reg__
 4838 198a 01F4      		brne .+2
 4839 198c 00C0      		rjmp .L205
 4840 198e A12C      		mov r10,__zero_reg__
 4841 1990 B12C      		mov r11,__zero_reg__
 4842               	.LBB402:
 4843               	.LBB403:
 568:motorctrl.c   ****             fprintf_P(port, PSTR("motor:"));
 4845               	.LM442:
 4846 1992 84E6      		ldi r24,lo8(100)
 4847 1994 582E      		mov r5,r24
 569:motorctrl.c   ****             fprintf(port, "%d", j);
 4849               	.LM443:
 4850 1996 90E0      		ldi r25,lo8(__c.2300)
 4851 1998 C92E      		mov r12,r25
 4852 199a 90E0      		ldi r25,hi8(__c.2300)
 4853 199c D92E      		mov r13,r25
 570:motorctrl.c   ****             fprintf_P(port, PSTR(" ADC_value:"));
 4855               	.LM444:
 4856 199e 20E0      		ldi r18,lo8(.LC3)
 4857 19a0 E22E      		mov r14,r18
 4858 19a2 20E0      		ldi r18,hi8(.LC3)
 4859 19a4 F22E      		mov r15,r18
 571:motorctrl.c   ****             fprintf(port,"%d\n",value);
 4861               	.LM445:
 4862 19a6 00E0      		ldi r16,lo8(__c.2302)
 4863 19a8 10E0      		ldi r17,hi8(__c.2302)
 572:motorctrl.c   ****         }
 4865               	.LM446:
 4866 19aa C0E0      		ldi r28,lo8(.LC0)
 4867 19ac D0E0      		ldi r29,hi8(.LC0)
 4868 19ae 00C0      		rjmp .L203
 4869               	.L210:
 4870               	.LBE403:
 4871               	.LBE402:
 4872               	.LBB405:
 4873               	.LBB406:
 4875               	.Ltext11:
 163:/usr/lib/avr/include/util/delay.h **** 
 4877               	.LM447:
 4878 19b0 2FEF      		ldi r18,lo8(159999)
 4879 19b2 80E7      		ldi r24,hi8(159999)
 4880 19b4 92E0      		ldi r25,hlo8(159999)
 4881 19b6 2150      	1:	subi r18,1
 4882 19b8 8040      		sbci r24,0
 4883 19ba 9040      		sbci r25,0
 4884 19bc 01F4      		brne 1b
 4885 19be 00C0      		rjmp .
 4886 19c0 0000      		nop
 4887               	.LBE406:
 4888               	.LBE405:
 4890               	.Ltext12:
 565:motorctrl.c   ****         for (uint8_t j=0;j<2;j++){
 4892               	.LM448:
 4893 19c2 2FEF      		ldi r18,-1
 4894 19c4 A21A      		sub r10,r18
 4895 19c6 B20A      		sbc r11,r18
 4896 19c8 8A14      		cp r8,r10
 4897 19ca 9B04      		cpc r9,r11
 4898 19cc 01F4      		brne .+2
 4899 19ce 00C0      		rjmp .L205
 4900               	.L203:
 4901               	.LBB407:
 4902 19d0 612C      		mov r6,__zero_reg__
 4903 19d2 712C      		mov r7,__zero_reg__
 4904               	.L204:
 4905               	.LBB404:
 568:motorctrl.c   ****             fprintf_P(port, PSTR("motor:"));
 4907               	.LM449:
 4908 19d4 569C      		mul r5,r6
 4909 19d6 F001      		movw r30,r0
 4910 19d8 579C      		mul r5,r7
 4911 19da F00D      		add r31,r0
 4912 19dc 1124      		clr __zero_reg__
 4913 19de E050      		subi r30,lo8(-(motors))
 4914 19e0 F040      		sbci r31,hi8(-(motors))
 4915 19e2 878D      		ldd r24,Z+31
 4916 19e4 44E0      		ldi r20,lo8(4)
 4917 19e6 60E4      		ldi r22,lo8(64)
 4918 19e8 0E94 0000 		call AVGVoltage
 4919 19ec 482E      		mov r4,r24
 4920 19ee 392E      		mov r3,r25
 569:motorctrl.c   ****             fprintf(port, "%d", j);
 4922               	.LM450:
 4923 19f0 DF92      		push r13
 4924 19f2 CF92      		push r12
 4925 19f4 8091 0000 		lds r24,port+1
 4926 19f8 8F93      		push r24
 4927 19fa 8091 0000 		lds r24,port
 4928 19fe 8F93      		push r24
 4929 1a00 0E94 0000 		call fprintf_P
 570:motorctrl.c   ****             fprintf_P(port, PSTR(" ADC_value:"));
 4931               	.LM451:
 4932 1a04 7F92      		push r7
 4933 1a06 6F92      		push r6
 4934 1a08 FF92      		push r15
 4935 1a0a EF92      		push r14
 4936 1a0c 8091 0000 		lds r24,port+1
 4937 1a10 8F93      		push r24
 4938 1a12 8091 0000 		lds r24,port
 4939 1a16 8F93      		push r24
 4940 1a18 0E94 0000 		call fprintf
 571:motorctrl.c   ****             fprintf(port,"%d\n",value);
 4942               	.LM452:
 4943 1a1c 1F93      		push r17
 4944 1a1e 0F93      		push r16
 4945 1a20 8091 0000 		lds r24,port+1
 4946 1a24 8F93      		push r24
 4947 1a26 8091 0000 		lds r24,port
 4948 1a2a 8F93      		push r24
 4949 1a2c 0E94 0000 		call fprintf_P
 572:motorctrl.c   ****         }
 4951               	.LM453:
 4952 1a30 3F92      		push r3
 4953 1a32 4F92      		push r4
 4954 1a34 DF93      		push r29
 4955 1a36 CF93      		push r28
 4956 1a38 8091 0000 		lds r24,port+1
 4957 1a3c 8F93      		push r24
 4958 1a3e 8091 0000 		lds r24,port
 4959 1a42 8F93      		push r24
 4960 1a44 0E94 0000 		call fprintf
 4961               	.LBE404:
 566:motorctrl.c   ****             volatile motor *m = &motors[j];
 4963               	.LM454:
 4964 1a48 8DB7      		in r24,__SP_L__
 4965 1a4a 9EB7      		in r25,__SP_H__
 4966 1a4c 4496      		adiw r24,20
 4967 1a4e 0FB6      		in __tmp_reg__,__SREG__
 4968 1a50 F894      		cli
 4969 1a52 9EBF      		out __SP_H__,r25
 4970 1a54 0FBE      		out __SREG__,__tmp_reg__
 4971 1a56 8DBF      		out __SP_L__,r24
 4972 1a58 91E0      		ldi r25,1
 4973 1a5a 6916      		cp r6,r25
 4974 1a5c 7104      		cpc r7,__zero_reg__
 4975 1a5e 01F4      		brne .+2
 4976 1a60 00C0      		rjmp .L210
 4977 1a62 6624      		clr r6
 4978 1a64 6394      		inc r6
 4979 1a66 712C      		mov r7,__zero_reg__
 4980 1a68 00C0      		rjmp .L204
 4981               	.L205:
 4982               	.LBE407:
 4983               	.LBE401:
 576:motorctrl.c   ****     for (uint8_t i=0; i< 1; i++){
 4985               	.LM455:
 4986 1a6a 80E0      		ldi r24,lo8(__c.2310)
 4987 1a6c 90E0      		ldi r25,hi8(__c.2310)
 4988 1a6e 9F93      		push r25
 4989 1a70 8F93      		push r24
 4990 1a72 8091 0000 		lds r24,port+1
 4991 1a76 8F93      		push r24
 4992 1a78 8091 0000 		lds r24,port
 4993 1a7c 8F93      		push r24
 4994 1a7e 0E94 0000 		call fprintf_P
 4995               	.LBB408:
 4996               	.LBB409:
 4997               	.LBB410:
 4998               	.LBB411:
 718:motorctrl.c   ****     if (pwm > 0){
 5000               	.LM456:
 5001 1a82 1092 0000 		sts motors+33,__zero_reg__
 5002               	.LBB412:
 5003               	.LBB413:
 702:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 5005               	.LM457:
 5006 1a86 3091 0000 		lds r19,motors+30
 5007 1a8a E091 0000 		lds r30,motors+26
 5008 1a8e F091 0000 		lds r31,motors+26+1
 5009 1a92 2081      		ld r18,Z
 5010 1a94 81E0      		ldi r24,lo8(1)
 5011 1a96 90E0      		ldi r25,0
 5012 1a98 00C0      		rjmp 2f
 5013               		1:
 5014 1a9a 880F      		lsl r24
 5015 1a9c 991F      		rol r25
 5016               		2:
 5017 1a9e 3A95      		dec r19
 5018 1aa0 02F4      		brpl 1b
 5019 1aa2 8095      		com r24
 5020 1aa4 9095      		com r25
 5021 1aa6 8223      		and r24,r18
 5022 1aa8 8083      		st Z,r24
 703:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 5024               	.LM458:
 5025 1aaa E091 0000 		lds r30,motors+5
 5026 1aae F091 0000 		lds r31,motors+5+1
 5027 1ab2 1082      		st Z,__zero_reg__
 704:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 5029               	.LM459:
 5030 1ab4 E091 0000 		lds r30,motors+8
 5031 1ab8 F091 0000 		lds r31,motors+8+1
 5032 1abc 1082      		st Z,__zero_reg__
 705:motorctrl.c   ****     
 5034               	.LM460:
 5035 1abe E091 0000 		lds r30,motors+11
 5036 1ac2 F091 0000 		lds r31,motors+11+1
 5037 1ac6 1082      		st Z,__zero_reg__
 708:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 5039               	.LM461:
 5040 1ac8 E091 0000 		lds r30,motors+18
 5041 1acc F091 0000 		lds r31,motors+18+1
 5042 1ad0 1082      		st Z,__zero_reg__
 709:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 5044               	.LM462:
 5045 1ad2 E091 0000 		lds r30,motors+21
 5046 1ad6 F091 0000 		lds r31,motors+21+1
 5047 1ada 1082      		st Z,__zero_reg__
 710:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 5049               	.LM463:
 5050 1adc E091 0000 		lds r30,motors+24
 5051 1ae0 F091 0000 		lds r31,motors+24+1
 5052 1ae4 1082      		st Z,__zero_reg__
 711:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 5054               	.LM464:
 5055 1ae6 1092 0000 		sts motors+33,__zero_reg__
 712:motorctrl.c   **** } 
 5057               	.LM465:
 5058 1aea 1092 0000 		sts motors+75,__zero_reg__
 5059 1aee 1092 0000 		sts motors+75+1,__zero_reg__
 5060 1af2 1092 0000 		sts motors+75+2,__zero_reg__
 5061 1af6 1092 0000 		sts motors+75+3,__zero_reg__
 5062               	.LBE413:
 5063               	.LBE412:
 5064               	.LBE411:
 5065               	.LBE410:
 5066               	.LBE409:
 5067 1afa 0F90      		pop __tmp_reg__
 5068 1afc 0F90      		pop __tmp_reg__
 5069 1afe 0F90      		pop __tmp_reg__
 5070 1b00 0F90      		pop __tmp_reg__
 5071               	/* epilogue start */
 5072               	.LBE408:
 581:motorctrl.c   **** 
 5074               	.LM466:
 5075 1b02 CDB7      		in r28,__SP_L__
 5076 1b04 DEB7      		in r29,__SP_H__
 5077 1b06 E1E1      		ldi r30, lo8(17)
 5078 1b08 0C94 0000 		jmp __epilogue_restores__ + ((18 - 17) * 2)
 5079               	.L209:
 5084               	.Lscope47:
 5089               	.global	motorControl
 5091               	motorControl:
 633:motorctrl.c   ****     if (pwm > m->max_pwm){
 5093               	.LM467:
 5094               	.LFBB48:
 5095 1b0c 0F93      		push r16
 5096 1b0e 1F93      		push r17
 5097 1b10 CF93      		push r28
 5098 1b12 DF93      		push r29
 5099               	/* prologue: function */
 5100               	/* frame size = 0 */
 5101               	/* stack size = 4 */
 5102               	.L__stack_usage = 4
 5103 1b14 EC01      		movw r28,r24
 5104 1b16 062F      		mov r16,r22
 5105 1b18 142F      		mov r17,r20
 634:motorctrl.c   ****         pwm = m->max_pwm;
 5107               	.LM468:
 5108 1b1a 8EA5      		ldd r24,Y+46
 5109 1b1c 8417      		cp r24,r20
 5110 1b1e 00F4      		brsh .L212
 635:motorctrl.c   ****     }
 5112               	.LM469:
 5113 1b20 1EA5      		ldd r17,Y+46
 5114               	.L212:
 639:motorctrl.c   ****         for(; m->current_pwm < pwm; m->current_pwm++){
 5116               	.LM470:
 5117 1b22 89A1      		ldd r24,Y+33
 5118 1b24 8117      		cp r24,r17
 5119 1b26 00F0      		brlo .+2
 5120 1b28 00C0      		rjmp .L213
 640:motorctrl.c   ****             setMotor(m, dir, m->current_pwm);
 5122               	.LM471:
 5123 1b2a 89A1      		ldd r24,Y+33
 5124 1b2c 8117      		cp r24,r17
 5125 1b2e 00F0      		brlo .+2
 5126 1b30 00C0      		rjmp .L225
 5127               	.LBB426:
 5128               	.LBB427:
 5130               	.LM472:
 5131 1b32 41E0      		ldi r20,lo8(1)
 5132 1b34 50E0      		ldi r21,0
 5133               	.LBB428:
 5134               	.LBB429:
 712:motorctrl.c   **** } 
 5136               	.LM473:
 5137 1b36 FE01      		movw r30,r28
 5138 1b38 E55B      		subi r30,-75
 5139 1b3a FF4F      		sbci r31,-1
 5140               	.L229:
 5141               	.LBE429:
 5142               	.LBE428:
 5143               	.LBE427:
 5144               	.LBE426:
 641:motorctrl.c   ****             delayLoop_us(m->acceleration_time);
 5146               	.LM474:
 5147 1b3c 89A1      		ldd r24,Y+33
 5148               	.LBB434:
 5149               	.LBB432:
 718:motorctrl.c   ****     if (pwm > 0){
 5151               	.LM475:
 5152 1b3e 89A3      		std Y+33,r24
 719:motorctrl.c   ****         if (dir == FORWARD){ //Forward
 5154               	.LM476:
 5155 1b40 8823      		tst r24
 5156 1b42 01F4      		brne .+2
 5157 1b44 00C0      		rjmp .L216
 720:motorctrl.c   ****             *m->rev_OCR_addr = 0x00; //PWM pulse width
 5159               	.LM477:
 5160 1b46 0130      		cpi r16,lo8(1)
 5161 1b48 01F4      		brne .+2
 5162 1b4a 00C0      		rjmp .L236
 731:motorctrl.c   ****             *m->rev_OCR_addr = pwm; 
 5164               	.LM478:
 5165 1b4c AB85      		ldd r26,Y+11
 5166 1b4e BC85      		ldd r27,Y+12
 5167 1b50 1C92      		st X,__zero_reg__
 732:motorctrl.c   ****             *m->fwd_port_addr &= ~(1<<m->fwd_pin);
 5169               	.LM479:
 5170 1b52 A88D      		ldd r26,Y+24
 5171 1b54 B98D      		ldd r27,Y+25
 5172 1b56 8C93      		st X,r24
 733:motorctrl.c   ****             *m->fwd_TCCRA_addr = 0x00; //Disable FWD
 5174               	.LM480:
 5175 1b58 8C81      		ldd r24,Y+4
 5176 1b5a A881      		ld r26,Y
 5177 1b5c B981      		ldd r27,Y+1
 5178 1b5e 2C91      		ld r18,X
 5179 1b60 BA01      		movw r22,r20
 5180 1b62 00C0      		rjmp 2f
 5181               		1:
 5182 1b64 660F      		lsl r22
 5183 1b66 771F      		rol r23
 5184               		2:
 5185 1b68 8A95      		dec r24
 5186 1b6a 02F4      		brpl 1b
 5187 1b6c CB01      		movw r24,r22
 5188 1b6e 8095      		com r24
 5189 1b70 9095      		com r25
 5190 1b72 8223      		and r24,r18
 5191 1b74 8C93      		st X,r24
 734:motorctrl.c   ****             *m->rev_TCCRA_addr = m->rev_TCCRA_value;
 5193               	.LM481:
 5194 1b76 AD81      		ldd r26,Y+5
 5195 1b78 BE81      		ldd r27,Y+6
 5196 1b7a 1C92      		st X,__zero_reg__
 735:motorctrl.c   **** 
 5198               	.LM482:
 5199 1b7c AA89      		ldd r26,Y+18
 5200 1b7e BB89      		ldd r27,Y+19
 5201 1b80 8C89      		ldd r24,Y+20
 5202 1b82 8C93      		st X,r24
 737:motorctrl.c   ****             *m->rev_TCCRB_addr = m->rev_TCCRB_value;
 5204               	.LM483:
 5205 1b84 A885      		ldd r26,Y+8
 5206 1b86 B985      		ldd r27,Y+9
 5207 1b88 1C92      		st X,__zero_reg__
 738:motorctrl.c   ****         }        
 5209               	.LM484:
 5210 1b8a AD89      		ldd r26,Y+21
 5211 1b8c BE89      		ldd r27,Y+22
 5212 1b8e 8F89      		ldd r24,Y+23
 5213 1b90 8C93      		st X,r24
 5214               	.L218:
 5216               	.LM485:
 5217 1b92 8E8D      		ldd r24,Y+30
 5218 1b94 AA8D      		ldd r26,Y+26
 5219 1b96 BB8D      		ldd r27,Y+27
 5220 1b98 2C91      		ld r18,X
 5221 1b9a BA01      		movw r22,r20
 5222 1b9c 00C0      		rjmp 2f
 5223               		1:
 5224 1b9e 660F      		lsl r22
 5225 1ba0 771F      		rol r23
 5226               		2:
 5227 1ba2 8A95      		dec r24
 5228 1ba4 02F4      		brpl 1b
 5229 1ba6 CB01      		movw r24,r22
 5230 1ba8 822B      		or r24,r18
 5231 1baa 8C93      		st X,r24
 5232               	.L219:
 5233               	.LBE432:
 5234               	.LBE434:
 642:motorctrl.c   ****         }
 5236               	.LM486:
 5237 1bac 29A5      		ldd r18,Y+41
 5238 1bae 3AA5      		ldd r19,Y+42
 5239               	.LBB435:
 5240               	.LBB436:
 628:motorctrl.c   ****         _delay_us(47);
 5242               	.LM487:
 5243 1bb0 3695      		lsr r19
 5244 1bb2 2795      		ror r18
 5245 1bb4 ABE7      		ldi r26,lo8(123)
 5246 1bb6 B4E1      		ldi r27,lo8(20)
 5247 1bb8 0E94 0000 		call __umulhisi3
 5248 1bbc 9695      		lsr r25
 5249 1bbe 8795      		ror r24
 5250 1bc0 0097      		sbiw r24,0
 5251 1bc2 01F0      		breq .L222
 628:motorctrl.c   ****         _delay_us(47);
 5253               	.LM488:
 5254 1bc4 20E0      		ldi r18,0
 5255 1bc6 30E0      		ldi r19,0
 5256               	.L220:
 5257               	.LBB437:
 5258               	.LBB438:
 5260               	.Ltext13:
 5262               	.LM489:
 5263 1bc8 7AEF      		ldi r23,lo8(-6)
 5264 1bca 7A95      	1:	dec r23
 5265 1bcc 01F4      		brne 1b
 5266 1bce 00C0      		rjmp .
 5267               	.LBE438:
 5268               	.LBE437:
 5270               	.Ltext14:
 628:motorctrl.c   ****         _delay_us(47);
 5272               	.LM490:
 5273 1bd0 2F5F      		subi r18,-1
 5274 1bd2 3F4F      		sbci r19,-1
 5275 1bd4 2817      		cp r18,r24
 5276 1bd6 3907      		cpc r19,r25
 5277 1bd8 01F4      		brne .L220
 5278               	.L222:
 5279               	.LBE436:
 5280               	.LBE435:
 640:motorctrl.c   ****             setMotor(m, dir, m->current_pwm);
 5282               	.LM491:
 5283 1bda 89A1      		ldd r24,Y+33
 5284 1bdc 8F5F      		subi r24,lo8(-(1))
 5285 1bde 89A3      		std Y+33,r24
 5286 1be0 89A1      		ldd r24,Y+33
 5287 1be2 8117      		cp r24,r17
 5288 1be4 00F4      		brsh .+2
 5289 1be6 00C0      		rjmp .L229
 5290               	.L225:
 651:motorctrl.c   ****     }
 5292               	.LM492:
 5293 1be8 49A1      		ldd r20,Y+33
 5294 1bea 602F      		mov r22,r16
 5295 1bec CE01      		movw r24,r28
 5296 1bee 0E94 0000 		call setMotor
 5297               	.L215:
 653:motorctrl.c   **** }
 5299               	.LM493:
 5300 1bf2 0AA3      		std Y+34,r16
 5301               	/* epilogue start */
 654:motorctrl.c   **** 
 5303               	.LM494:
 5304 1bf4 DF91      		pop r29
 5305 1bf6 CF91      		pop r28
 5306 1bf8 1F91      		pop r17
 5307 1bfa 0F91      		pop r16
 5308 1bfc 0895      		ret
 5309               	.L213:
 646:motorctrl.c   ****         for(; m->current_pwm > pwm; m->current_pwm--){
 5311               	.LM495:
 5312 1bfe 89A1      		ldd r24,Y+33
 5313 1c00 1817      		cp r17,r24
 5314 1c02 00F4      		brsh .L215
 5315               	.L235:
 647:motorctrl.c   ****             setMotor(m, dir, m->current_pwm);
 5317               	.LM496:
 5318 1c04 89A1      		ldd r24,Y+33
 5319 1c06 1817      		cp r17,r24
 5320 1c08 00F4      		brsh .L225
 648:motorctrl.c   ****             delayLoop_us(m->deacceleration_time);
 5322               	.LM497:
 5323 1c0a 49A1      		ldd r20,Y+33
 5324 1c0c 602F      		mov r22,r16
 5325 1c0e CE01      		movw r24,r28
 5326 1c10 0E94 0000 		call setMotor
 649:motorctrl.c   ****         } 
 5328               	.LM498:
 5329 1c14 2BA5      		ldd r18,Y+43
 5330 1c16 3CA5      		ldd r19,Y+44
 5331               	.LBB439:
 5332               	.LBB440:
 628:motorctrl.c   ****         _delay_us(47);
 5334               	.LM499:
 5335 1c18 3695      		lsr r19
 5336 1c1a 2795      		ror r18
 5337 1c1c ABE7      		ldi r26,lo8(123)
 5338 1c1e B4E1      		ldi r27,lo8(20)
 5339 1c20 0E94 0000 		call __umulhisi3
 5340 1c24 9695      		lsr r25
 5341 1c26 8795      		ror r24
 5342 1c28 0097      		sbiw r24,0
 5343 1c2a 01F0      		breq .L226
 628:motorctrl.c   ****         _delay_us(47);
 5345               	.LM500:
 5346 1c2c 20E0      		ldi r18,0
 5347 1c2e 30E0      		ldi r19,0
 5348               	.L224:
 5349               	.LBB441:
 5350               	.LBB442:
 5352               	.Ltext15:
 5354               	.LM501:
 5355 1c30 4AEF      		ldi r20,lo8(-6)
 5356 1c32 4A95      	1:	dec r20
 5357 1c34 01F4      		brne 1b
 5358 1c36 00C0      		rjmp .
 5359               	.LBE442:
 5360               	.LBE441:
 5362               	.Ltext16:
 628:motorctrl.c   ****         _delay_us(47);
 5364               	.LM502:
 5365 1c38 2F5F      		subi r18,-1
 5366 1c3a 3F4F      		sbci r19,-1
 5367 1c3c 2817      		cp r18,r24
 5368 1c3e 3907      		cpc r19,r25
 5369 1c40 01F4      		brne .L224
 5370               	.L226:
 5371               	.LBE440:
 5372               	.LBE439:
 647:motorctrl.c   ****             setMotor(m, dir, m->current_pwm);
 5374               	.LM503:
 5375 1c42 89A1      		ldd r24,Y+33
 5376 1c44 8150      		subi r24,lo8(-(-1))
 5377 1c46 89A3      		std Y+33,r24
 5378 1c48 00C0      		rjmp .L235
 5379               	.L216:
 5380               	.LBB443:
 5381               	.LBB433:
 5382               	.LBB431:
 5383               	.LBB430:
 702:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 5385               	.LM504:
 5386 1c4a 8E8D      		ldd r24,Y+30
 5387 1c4c AA8D      		ldd r26,Y+26
 5388 1c4e BB8D      		ldd r27,Y+27
 5389 1c50 2C91      		ld r18,X
 5390 1c52 BA01      		movw r22,r20
 5391 1c54 00C0      		rjmp 2f
 5392               		1:
 5393 1c56 660F      		lsl r22
 5394 1c58 771F      		rol r23
 5395               		2:
 5396 1c5a 8A95      		dec r24
 5397 1c5c 02F4      		brpl 1b
 5398 1c5e CB01      		movw r24,r22
 5399 1c60 8095      		com r24
 5400 1c62 9095      		com r25
 5401 1c64 8223      		and r24,r18
 5402 1c66 8C93      		st X,r24
 703:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 5404               	.LM505:
 5405 1c68 AD81      		ldd r26,Y+5
 5406 1c6a BE81      		ldd r27,Y+6
 5407 1c6c 1C92      		st X,__zero_reg__
 704:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 5409               	.LM506:
 5410 1c6e A885      		ldd r26,Y+8
 5411 1c70 B985      		ldd r27,Y+9
 5412 1c72 1C92      		st X,__zero_reg__
 705:motorctrl.c   ****     
 5414               	.LM507:
 5415 1c74 AB85      		ldd r26,Y+11
 5416 1c76 BC85      		ldd r27,Y+12
 5417 1c78 1C92      		st X,__zero_reg__
 708:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 5419               	.LM508:
 5420 1c7a AA89      		ldd r26,Y+18
 5421 1c7c BB89      		ldd r27,Y+19
 5422 1c7e 1C92      		st X,__zero_reg__
 709:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 5424               	.LM509:
 5425 1c80 AD89      		ldd r26,Y+21
 5426 1c82 BE89      		ldd r27,Y+22
 5427 1c84 1C92      		st X,__zero_reg__
 710:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 5429               	.LM510:
 5430 1c86 A88D      		ldd r26,Y+24
 5431 1c88 B98D      		ldd r27,Y+25
 5432 1c8a 1C92      		st X,__zero_reg__
 711:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 5434               	.LM511:
 5435 1c8c 19A2      		std Y+33,__zero_reg__
 712:motorctrl.c   **** } 
 5437               	.LM512:
 5438 1c8e 1082      		st Z,__zero_reg__
 5439 1c90 1182      		std Z+1,__zero_reg__
 5440 1c92 1282      		std Z+2,__zero_reg__
 5441 1c94 1382      		std Z+3,__zero_reg__
 5442 1c96 00C0      		rjmp .L219
 5443               	.L236:
 5444               	.LBE430:
 5445               	.LBE431:
 721:motorctrl.c   ****             *m->fwd_OCR_addr = pwm; 
 5447               	.LM513:
 5448 1c98 A88D      		ldd r26,Y+24
 5449 1c9a B98D      		ldd r27,Y+25
 5450 1c9c 1C92      		st X,__zero_reg__
 722:motorctrl.c   ****             *m->rev_port_addr &= ~(1<<m->rev_pin);
 5452               	.LM514:
 5453 1c9e AB85      		ldd r26,Y+11
 5454 1ca0 BC85      		ldd r27,Y+12
 5455 1ca2 8C93      		st X,r24
 723:motorctrl.c   ****             *m->rev_TCCRA_addr = 0x00; //Disable reverse
 5457               	.LM515:
 5458 1ca4 8989      		ldd r24,Y+17
 5459 1ca6 AD85      		ldd r26,Y+13
 5460 1ca8 BE85      		ldd r27,Y+14
 5461 1caa 2C91      		ld r18,X
 5462 1cac BA01      		movw r22,r20
 5463 1cae 00C0      		rjmp 2f
 5464               		1:
 5465 1cb0 660F      		lsl r22
 5466 1cb2 771F      		rol r23
 5467               		2:
 5468 1cb4 8A95      		dec r24
 5469 1cb6 02F4      		brpl 1b
 5470 1cb8 CB01      		movw r24,r22
 5471 1cba 8095      		com r24
 5472 1cbc 9095      		com r25
 5473 1cbe 8223      		and r24,r18
 5474 1cc0 8C93      		st X,r24
 724:motorctrl.c   ****             *m->fwd_TCCRA_addr = m->fwd_TCCRA_value; //Activate PWM forward
 5476               	.LM516:
 5477 1cc2 AA89      		ldd r26,Y+18
 5478 1cc4 BB89      		ldd r27,Y+19
 5479 1cc6 1C92      		st X,__zero_reg__
 725:motorctrl.c   ****             
 5481               	.LM517:
 5482 1cc8 AD81      		ldd r26,Y+5
 5483 1cca BE81      		ldd r27,Y+6
 5484 1ccc 8F81      		ldd r24,Y+7
 5485 1cce 8C93      		st X,r24
 727:motorctrl.c   ****             *m->fwd_TCCRB_addr = m->fwd_TCCRB_value;
 5487               	.LM518:
 5488 1cd0 AD89      		ldd r26,Y+21
 5489 1cd2 BE89      		ldd r27,Y+22
 5490 1cd4 1C92      		st X,__zero_reg__
 728:motorctrl.c   ****         }
 5492               	.LM519:
 5493 1cd6 A885      		ldd r26,Y+8
 5494 1cd8 B985      		ldd r27,Y+9
 5495 1cda 8A85      		ldd r24,Y+10
 5496 1cdc 8C93      		st X,r24
 5497 1cde 00C0      		rjmp .L218
 5498               	.LBE433:
 5499               	.LBE443:
 5507               	.Lscope48:
 5510               	.global	getActuatorLength
 5512               	getActuatorLength:
 326:motorctrl.c   ****     uint32_t voltage = AVGVoltage(m->actuator_adc_channel, 0x40, NUMOFSAMPLES);
 5514               	.LM520:
 5515               	.LFBB49:
 5516 1ce0 A0E0      		ldi r26,0
 5517 1ce2 B0E0      		ldi r27,0
 5518 1ce4 E0E0      		ldi r30,lo8(gs(1f))
 5519 1ce6 F0E0      		ldi r31,hi8(gs(1f))
 5520 1ce8 0C94 0000 		jmp __prologue_saves__+((18 - 18) * 2)
 5521               	1:
 5522               	/* prologue: function */
 5523               	/* frame size = 0 */
 5524               	/* stack size = 18 */
 5525               	.L__stack_usage = 18
 5526 1cec EC01      		movw r28,r24
 327:motorctrl.c   ****     
 5528               	.LM521:
 5529 1cee 8F8D      		ldd r24,Y+31
 5530 1cf0 44E0      		ldi r20,lo8(4)
 5531 1cf2 60E4      		ldi r22,lo8(64)
 5532 1cf4 0E94 0000 		call AVGVoltage
 5533 1cf8 6C01      		movw r12,r24
 5534 1cfa E12C      		mov r14,__zero_reg__
 5535 1cfc F12C      		mov r15,__zero_reg__
 330:motorctrl.c   ****         m->status = ACTUATOR_ERROR;
 5537               	.LM522:
 5538 1cfe FE01      		movw r30,r28
 5539 1d00 EE5A      		subi r30,-82
 5540 1d02 FF4F      		sbci r31,-1
 5541 1d04 8081      		ld r24,Z
 5542 1d06 9181      		ldd r25,Z+1
 5543 1d08 A0E0      		ldi r26,0
 5544 1d0a B0E0      		ldi r27,0
 5545 1d0c C816      		cp r12,r24
 5546 1d0e D906      		cpc r13,r25
 5547 1d10 EA06      		cpc r14,r26
 5548 1d12 FB06      		cpc r15,r27
 5549 1d14 00F4      		brsh .+2
 5550 1d16 00C0      		rjmp .L238
 330:motorctrl.c   ****         m->status = ACTUATOR_ERROR;
 5552               	.LM523:
 5553 1d18 DE01      		movw r26,r28
 5554 1d1a AC5A      		subi r26,-84
 5555 1d1c BF4F      		sbci r27,-1
 5556 1d1e 8D91      		ld r24,X+
 5557 1d20 9C91      		ld r25,X
 5558 1d22 C296      		adiw r24,50
 5559 1d24 A0E0      		ldi r26,0
 5560 1d26 B0E0      		ldi r27,0
 5561 1d28 8C15      		cp r24,r12
 5562 1d2a 9D05      		cpc r25,r13
 5563 1d2c AE05      		cpc r26,r14
 5564 1d2e BF05      		cpc r27,r15
 5565 1d30 00F4      		brsh .+2
 5566 1d32 00C0      		rjmp .L238
 341:motorctrl.c   ****     uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); /
 5568               	.LM524:
 5569 1d34 2080      		ld r2,Z
 5570 1d36 3180      		ldd r3,Z+1
 342:motorctrl.c   ****     
 5572               	.LM525:
 5573 1d38 6BAD      		ldd r22,Y+59
 5574 1d3a 7CAD      		ldd r23,Y+60
 5575 1d3c FE01      		movw r30,r28
 5576 1d3e FF96      		adiw r30,63
 5577 1d40 4080      		ld r4,Z
 5578 1d42 5180      		ldd r5,Z+1
 5579 1d44 6280      		ldd r6,Z+2
 5580 1d46 7380      		ldd r7,Z+3
 5581 1d48 7796      		adiw r30,23
 5582 1d4a 0081      		ld r16,Z
 5583 1d4c 1181      		ldd r17,Z+1
 5584 1d4e 80E0      		ldi r24,0
 5585 1d50 90E0      		ldi r25,0
 5586 1d52 0E94 0000 		call __floatunsisf
 5587 1d56 4B01      		movw r8,r22
 5588 1d58 5C01      		movw r10,r24
 5589 1d5a B801      		movw r22,r16
 5590 1d5c 80E0      		ldi r24,0
 5591 1d5e 90E0      		ldi r25,0
 5592 1d60 0E94 0000 		call __floatunsisf
 5593 1d64 9B01      		movw r18,r22
 5594 1d66 AC01      		movw r20,r24
 5595 1d68 C301      		movw r24,r6
 5596 1d6a B201      		movw r22,r4
 5597 1d6c 0E94 0000 		call __divsf3
 5598 1d70 2B01      		movw r4,r22
 5599 1d72 3C01      		movw r6,r24
 341:motorctrl.c   ****     uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); /
 5601               	.LM526:
 5602 1d74 C701      		movw r24,r14
 5603 1d76 B601      		movw r22,r12
 5604 1d78 6219      		sub r22,r2
 5605 1d7a 7309      		sbc r23,r3
 5606 1d7c 8109      		sbc r24,__zero_reg__
 5607 1d7e 9109      		sbc r25,__zero_reg__
 342:motorctrl.c   ****     
 5609               	.LM527:
 5610 1d80 0E94 0000 		call __floatunsisf
 5611 1d84 9B01      		movw r18,r22
 5612 1d86 AC01      		movw r20,r24
 5613 1d88 C301      		movw r24,r6
 5614 1d8a B201      		movw r22,r4
 5615 1d8c 0E94 0000 		call __mulsf3
 5616 1d90 9B01      		movw r18,r22
 5617 1d92 AC01      		movw r20,r24
 5618 1d94 C501      		movw r24,r10
 5619 1d96 B401      		movw r22,r8
 5620 1d98 0E94 0000 		call __addsf3
 5621 1d9c 0E94 0000 		call __fixunssfsi
 5622 1da0 6B01      		movw r12,r22
 5623 1da2 7C01      		movw r14,r24
 5624 1da4 CB01      		movw r24,r22
 345:motorctrl.c   ****         m->status = MAX_LIMIT;
 5626               	.LM528:
 5627 1da6 FE01      		movw r30,r28
 5628 1da8 EB5B      		subi r30,-69
 5629 1daa FF4F      		sbci r31,-1
 5630 1dac 2081      		ld r18,Z
 5631 1dae 3181      		ldd r19,Z+1
 5632 1db0 2617      		cp r18,r22
 5633 1db2 3707      		cpc r19,r23
 5634 1db4 00F4      		brsh .L241
 345:motorctrl.c   ****         m->status = MAX_LIMIT;
 5636               	.LM529:
 5637 1db6 3A96      		adiw r30,10
 5638 1db8 2081      		ld r18,Z
 5639 1dba 2130      		cpi r18,lo8(1)
 5640 1dbc 01F4      		brne .+2
 5641 1dbe 00C0      		rjmp .L245
 5642               	.L241:
 352:motorctrl.c   ****         m->status = MIN_LIMIT;
 5644               	.LM530:
 5645 1dc0 FE01      		movw r30,r28
 5646 1dc2 ED5B      		subi r30,-67
 5647 1dc4 FF4F      		sbci r31,-1
 5648 1dc6 2081      		ld r18,Z
 5649 1dc8 3181      		ldd r19,Z+1
 5650 1dca 8217      		cp r24,r18
 5651 1dcc 9307      		cpc r25,r19
 5652 1dce 00F4      		brsh .L243
 352:motorctrl.c   ****         m->status = MIN_LIMIT;
 5654               	.LM531:
 5655 1dd0 3C96      		adiw r30,12
 5656 1dd2 8081      		ld r24,Z
 5657 1dd4 8230      		cpi r24,lo8(2)
 5658 1dd6 01F0      		breq .L246
 5659               	.L243:
 5660 1dd8 C601      		movw r24,r12
 5661               	/* epilogue start */
 360:motorctrl.c   **** //Returns angle between -90.0 - 90.0, input value is in millimeters.
 5663               	.LM532:
 5664 1dda CDB7      		in r28,__SP_L__
 5665 1ddc DEB7      		in r29,__SP_H__
 5666 1dde E2E1      		ldi r30, lo8(18)
 5667 1de0 0C94 0000 		jmp __epilogue_restores__ + ((18 - 18) * 2)
 5668 1de4 00C0      		rjmp .L247
 5669               	.L238:
 331:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);
 5671               	.LM533:
 5672 1de6 FE01      		movw r30,r28
 5673 1de8 E15B      		subi r30,-79
 5674 1dea FF4F      		sbci r31,-1
 5675 1dec 87E0      		ldi r24,lo8(7)
 5676 1dee 8083      		st Z,r24
 332:motorctrl.c   ****         running_motor = -1;
 5678               	.LM534:
 5679 1df0 6AA1      		ldd r22,Y+34
 5680 1df2 40E0      		ldi r20,0
 5681 1df4 CE01      		movw r24,r28
 5682 1df6 0E94 0000 		call motorControl
 333:motorctrl.c   ****         m->set_length = m->current_length;
 5684               	.LM535:
 5685 1dfa 8FEF      		ldi r24,lo8(-1)
 5686 1dfc 8093 0000 		sts running_motor,r24
 334:motorctrl.c   ****         fprintf_P(port, PSTR("AERR\n"));
 5688               	.LM536:
 5689 1e00 8BA1      		ldd r24,Y+35
 5690 1e02 9CA1      		ldd r25,Y+36
 5691 1e04 9EA3      		std Y+38,r25
 5692 1e06 8DA3      		std Y+37,r24
 335:motorctrl.c   ****         _delay_ms(500);
 5694               	.LM537:
 5695 1e08 80E0      		ldi r24,lo8(__c.2218)
 5696 1e0a 90E0      		ldi r25,hi8(__c.2218)
 5697 1e0c 9F93      		push r25
 5698 1e0e 8F93      		push r24
 5699 1e10 8091 0000 		lds r24,port+1
 5700 1e14 8F93      		push r24
 5701 1e16 8091 0000 		lds r24,port
 5702 1e1a 8F93      		push r24
 5703 1e1c 0E94 0000 		call fprintf_P
 5704               	.LBB447:
 5705               	.LBB448:
 5707               	.Ltext17:
 163:/usr/lib/avr/include/util/delay.h **** 
 5709               	.LM538:
 5710 1e20 2FEF      		ldi r18,lo8(1599999)
 5711 1e22 89E6      		ldi r24,hi8(1599999)
 5712 1e24 98E1      		ldi r25,hlo8(1599999)
 5713 1e26 2150      	1:	subi r18,1
 5714 1e28 8040      		sbci r24,0
 5715 1e2a 9040      		sbci r25,0
 5716 1e2c 01F4      		brne 1b
 5717 1e2e 00C0      		rjmp .
 5718 1e30 0000      		nop
 5719               	.LBE448:
 5720               	.LBE447:
 5722               	.Ltext18:
 337:motorctrl.c   ****     } 
 5724               	.LM539:
 5725 1e32 8BA1      		ldd r24,Y+35
 5726 1e34 9CA1      		ldd r25,Y+36
 5727 1e36 0F90      		pop __tmp_reg__
 5728 1e38 0F90      		pop __tmp_reg__
 5729 1e3a 0F90      		pop __tmp_reg__
 5730 1e3c 0F90      		pop __tmp_reg__
 5731               	.L240:
 5732               	/* epilogue start */
 360:motorctrl.c   **** //Returns angle between -90.0 - 90.0, input value is in millimeters.
 5734               	.LM540:
 5735 1e3e CDB7      		in r28,__SP_L__
 5736 1e40 DEB7      		in r29,__SP_H__
 5737 1e42 E2E1      		ldi r30, lo8(18)
 5738 1e44 0C94 0000 		jmp __epilogue_restores__ + ((18 - 18) * 2)
 5739 1e48 00C0      		rjmp .L247
 5740               	.L246:
 353:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
 5742               	.LM541:
 5743 1e4a 84E0      		ldi r24,lo8(4)
 5744               	.L244:
 5745 1e4c 8083      		st Z,r24
 354:motorctrl.c   ****         running_motor = -1;
 5747               	.LM542:
 5748 1e4e 6AA1      		ldd r22,Y+34
 5749 1e50 40E0      		ldi r20,0
 5750 1e52 CE01      		movw r24,r28
 5751 1e54 0E94 0000 		call motorControl
 355:motorctrl.c   ****         m->set_length = length;
 5753               	.LM543:
 5754 1e58 8FEF      		ldi r24,lo8(-1)
 5755 1e5a 8093 0000 		sts running_motor,r24
 356:motorctrl.c   ****        // fprintf_P(port, PSTR("MINLERR\n"));
 5757               	.LM544:
 5758 1e5e DEA2      		std Y+38,r13
 5759 1e60 CDA2      		std Y+37,r12
 5760 1e62 C601      		movw r24,r12
 5761 1e64 00C0      		rjmp .L240
 5762               	.L245:
 346:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 5764               	.LM545:
 5765 1e66 85E0      		ldi r24,lo8(5)
 5766 1e68 00C0      		rjmp .L244
 5767               	.L247:
 5772               	.Lscope49:
 5775               	.global	initMotor
 5777               	initMotor:
 657:motorctrl.c   ****     port = debugport;
 5779               	.LM546:
 5780               	.LFBB50:
 5781 1e6a A8E0      		ldi r26,lo8(8)
 5782 1e6c B0E0      		ldi r27,0
 5783 1e6e E0E0      		ldi r30,lo8(gs(1f))
 5784 1e70 F0E0      		ldi r31,hi8(gs(1f))
 5785 1e72 0C94 0000 		jmp __prologue_saves__+((18 - 18) * 2)
 5786               	1:
 5787               	/* prologue: function */
 5788               	/* frame size = 8 */
 5789               	/* stack size = 26 */
 5790               	.L__stack_usage = 26
 658:motorctrl.c   **** 
 5792               	.LM547:
 5793 1e76 9093 0000 		sts port+1,r25
 5794 1e7a 8093 0000 		sts port,r24
 5795 1e7e 90E0      		ldi r25,lo8(motors)
 5796 1e80 A92E      		mov r10,r25
 5797 1e82 90E0      		ldi r25,hi8(motors)
 5798 1e84 B92E      		mov r11,r25
 5799 1e86 212C      		mov r2,__zero_reg__
 5800 1e88 312C      		mov r3,__zero_reg__
 5801               	.LBB458:
 5802               	.LBB459:
 663:motorctrl.c   ****         *m->rev_dir_addr |= 1<<m->rev_pin;
 5804               	.LM548:
 5805 1e8a 01E0      		ldi r16,lo8(1)
 5806 1e8c 10E0      		ldi r17,0
 5807               	.L253:
 663:motorctrl.c   ****         *m->rev_dir_addr |= 1<<m->rev_pin;
 5809               	.LM549:
 5810 1e8e 44E6      		ldi r20,lo8(100)
 5811 1e90 429D      		mul r20,r2
 5812 1e92 9001      		movw r18,r0
 5813 1e94 439D      		mul r20,r3
 5814 1e96 300D      		add r19,r0
 5815 1e98 1124      		clr __zero_reg__
 5816 1e9a C901      		movw r24,r18
 5817 1e9c 8050      		subi r24,lo8(-(motors))
 5818 1e9e 9040      		sbci r25,hi8(-(motors))
 5819 1ea0 9887      		std Y+8,r25
 5820 1ea2 8F83      		std Y+7,r24
 5821 1ea4 DC01      		movw r26,r24
 5822 1ea6 1496      		adiw r26,4
 5823 1ea8 8C91      		ld r24,X
 5824 1eaa 1497      		sbiw r26,4
 5825 1eac 1296      		adiw r26,2
 5826 1eae ED91      		ld r30,X+
 5827 1eb0 FC91      		ld r31,X
 5828 1eb2 1397      		sbiw r26,2+1
 5829 1eb4 2081      		ld r18,Z
 5830 1eb6 A801      		movw r20,r16
 5831 1eb8 00C0      		rjmp 2f
 5832               		1:
 5833 1eba 440F      		lsl r20
 5834 1ebc 551F      		rol r21
 5835               		2:
 5836 1ebe 8A95      		dec r24
 5837 1ec0 02F4      		brpl 1b
 5838 1ec2 CA01      		movw r24,r20
 5839 1ec4 822B      		or r24,r18
 5840 1ec6 8083      		st Z,r24
 664:motorctrl.c   ****         *m->enable_dir_addr |= 1<<m->enable_pin;
 5842               	.LM550:
 5843 1ec8 5196      		adiw r26,17
 5844 1eca 8C91      		ld r24,X
 5845 1ecc 5197      		sbiw r26,17
 5846 1ece 1F96      		adiw r26,15
 5847 1ed0 ED91      		ld r30,X+
 5848 1ed2 FC91      		ld r31,X
 5849 1ed4 5097      		sbiw r26,15+1
 5850 1ed6 2081      		ld r18,Z
 5851 1ed8 D801      		movw r26,r16
 5852 1eda 00C0      		rjmp 2f
 5853               		1:
 5854 1edc AA0F      		lsl r26
 5855 1ede BB1F      		rol r27
 5856               		2:
 5857 1ee0 8A95      		dec r24
 5858 1ee2 02F4      		brpl 1b
 5859 1ee4 CD01      		movw r24,r26
 5860 1ee6 822B      		or r24,r18
 5861 1ee8 8083      		st Z,r24
 665:motorctrl.c   ****         
 5863               	.LM551:
 5864 1eea EF81      		ldd r30,Y+7
 5865 1eec F885      		ldd r31,Y+8
 5866 1eee 868D      		ldd r24,Z+30
 5867 1ef0 048C      		ldd __tmp_reg__,Z+28
 5868 1ef2 F58D      		ldd r31,Z+29
 5869 1ef4 E02D      		mov r30,__tmp_reg__
 5870 1ef6 2081      		ld r18,Z
 5871 1ef8 A801      		movw r20,r16
 5872 1efa 00C0      		rjmp 2f
 5873               		1:
 5874 1efc 440F      		lsl r20
 5875 1efe 551F      		rol r21
 5876               		2:
 5877 1f00 8A95      		dec r24
 5878 1f02 02F4      		brpl 1b
 5879 1f04 CA01      		movw r24,r20
 5880 1f06 822B      		or r24,r18
 5881 1f08 8083      		st Z,r24
 668:motorctrl.c   ****         *m->rev_port_addr &= ~(1<<m->rev_pin);
 5883               	.LM552:
 5884 1f0a AF81      		ldd r26,Y+7
 5885 1f0c B885      		ldd r27,Y+8
 5886 1f0e 1496      		adiw r26,4
 5887 1f10 8C91      		ld r24,X
 5888 1f12 1497      		sbiw r26,4
 5889 1f14 ED91      		ld r30,X+
 5890 1f16 FC91      		ld r31,X
 5891 1f18 1197      		sbiw r26,1
 5892 1f1a 2081      		ld r18,Z
 5893 1f1c A801      		movw r20,r16
 5894 1f1e 00C0      		rjmp 2f
 5895               		1:
 5896 1f20 440F      		lsl r20
 5897 1f22 551F      		rol r21
 5898               		2:
 5899 1f24 8A95      		dec r24
 5900 1f26 02F4      		brpl 1b
 5901 1f28 CA01      		movw r24,r20
 5902 1f2a 8095      		com r24
 5903 1f2c 9095      		com r25
 5904 1f2e 8223      		and r24,r18
 5905 1f30 8083      		st Z,r24
 669:motorctrl.c   ****         *m->enable_port_addr &= ~(1<<m->enable_pin);
 5907               	.LM553:
 5908 1f32 5196      		adiw r26,17
 5909 1f34 8C91      		ld r24,X
 5910 1f36 5197      		sbiw r26,17
 5911 1f38 1D96      		adiw r26,13
 5912 1f3a ED91      		ld r30,X+
 5913 1f3c FC91      		ld r31,X
 5914 1f3e 1E97      		sbiw r26,13+1
 5915 1f40 2081      		ld r18,Z
 5916 1f42 D801      		movw r26,r16
 5917 1f44 00C0      		rjmp 2f
 5918               		1:
 5919 1f46 AA0F      		lsl r26
 5920 1f48 BB1F      		rol r27
 5921               		2:
 5922 1f4a 8A95      		dec r24
 5923 1f4c 02F4      		brpl 1b
 5924 1f4e CD01      		movw r24,r26
 5925 1f50 8095      		com r24
 5926 1f52 9095      		com r25
 5927 1f54 8223      		and r24,r18
 5928 1f56 8083      		st Z,r24
 670:motorctrl.c   ****         
 5930               	.LM554:
 5931 1f58 EF81      		ldd r30,Y+7
 5932 1f5a F885      		ldd r31,Y+8
 5933 1f5c 868D      		ldd r24,Z+30
 5934 1f5e 028C      		ldd __tmp_reg__,Z+26
 5935 1f60 F38D      		ldd r31,Z+27
 5936 1f62 E02D      		mov r30,__tmp_reg__
 5937 1f64 2081      		ld r18,Z
 5938 1f66 A801      		movw r20,r16
 5939 1f68 00C0      		rjmp 2f
 5940               		1:
 5941 1f6a 440F      		lsl r20
 5942 1f6c 551F      		rol r21
 5943               		2:
 5944 1f6e 8A95      		dec r24
 5945 1f70 02F4      		brpl 1b
 5946 1f72 CA01      		movw r24,r20
 5947 1f74 8095      		com r24
 5948 1f76 9095      		com r25
 5949 1f78 8223      		and r24,r18
 5950 1f7a 8083      		st Z,r24
 673:motorctrl.c   ****         *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 5952               	.LM555:
 5953 1f7c AF81      		ldd r26,Y+7
 5954 1f7e B885      		ldd r27,Y+8
 5955 1f80 1596      		adiw r26,5
 5956 1f82 ED91      		ld r30,X+
 5957 1f84 FC91      		ld r31,X
 5958 1f86 1697      		sbiw r26,5+1
 5959 1f88 1082      		st Z,__zero_reg__
 674:motorctrl.c   ****         *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 5961               	.LM556:
 5962 1f8a 1896      		adiw r26,8
 5963 1f8c ED91      		ld r30,X+
 5964 1f8e FC91      		ld r31,X
 5965 1f90 1997      		sbiw r26,8+1
 5966 1f92 1082      		st Z,__zero_reg__
 675:motorctrl.c   ****         
 5968               	.LM557:
 5969 1f94 1B96      		adiw r26,11
 5970 1f96 ED91      		ld r30,X+
 5971 1f98 FC91      		ld r31,X
 5972 1f9a 1C97      		sbiw r26,11+1
 5973 1f9c 1082      		st Z,__zero_reg__
 678:motorctrl.c   ****         *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 5975               	.LM558:
 5976 1f9e 5296      		adiw r26,18
 5977 1fa0 ED91      		ld r30,X+
 5978 1fa2 FC91      		ld r31,X
 5979 1fa4 5397      		sbiw r26,18+1
 5980 1fa6 1082      		st Z,__zero_reg__
 679:motorctrl.c   ****         *m->rev_OCR_addr = 0x00; //Init PWM to zero
 5982               	.LM559:
 5983 1fa8 5596      		adiw r26,21
 5984 1faa ED91      		ld r30,X+
 5985 1fac FC91      		ld r31,X
 5986 1fae 5697      		sbiw r26,21+1
 5987 1fb0 1082      		st Z,__zero_reg__
 680:motorctrl.c   ****         
 5989               	.LM560:
 5990 1fb2 5896      		adiw r26,24
 5991 1fb4 ED91      		ld r30,X+
 5992 1fb6 FC91      		ld r31,X
 5993 1fb8 5997      		sbiw r26,24+1
 5994 1fba 1082      		st Z,__zero_reg__
 5995               	.LBB460:
 5996               	.LBB461:
 5998               	.Ltext19:
 163:/usr/lib/avr/include/util/delay.h **** 
 6000               	.LM561:
 6001 1fbc EFE3      		ldi r30,lo8(-25537)
 6002 1fbe FCE9      		ldi r31,hi8(-25537)
 6003 1fc0 3197      	1:	sbiw r30,1
 6004 1fc2 01F4      		brne 1b
 6005 1fc4 00C0      		rjmp .
 6006 1fc6 0000      		nop
 6007               	.LBE461:
 6008               	.LBE460:
 6009               	.LBB462:
 6010               	.LBB463:
 6012               	.Ltext20:
 327:motorctrl.c   ****     
 6014               	.LM562:
 6015 1fc8 5F96      		adiw r26,31
 6016 1fca 8C91      		ld r24,X
 6017 1fcc 44E0      		ldi r20,lo8(4)
 6018 1fce 60E4      		ldi r22,lo8(64)
 6019 1fd0 0E94 0000 		call AVGVoltage
 6020 1fd4 2C01      		movw r4,r24
 6021 1fd6 612C      		mov r6,__zero_reg__
 6022 1fd8 712C      		mov r7,__zero_reg__
 330:motorctrl.c   ****         m->status = ACTUATOR_ERROR;
 6024               	.LM563:
 6025 1fda EF81      		ldd r30,Y+7
 6026 1fdc F885      		ldd r31,Y+8
 6027 1fde EE5A      		subi r30,-82
 6028 1fe0 FF4F      		sbci r31,-1
 6029 1fe2 8081      		ld r24,Z
 6030 1fe4 9181      		ldd r25,Z+1
 6031 1fe6 A0E0      		ldi r26,0
 6032 1fe8 B0E0      		ldi r27,0
 6033 1fea 4816      		cp r4,r24
 6034 1fec 5906      		cpc r5,r25
 6035 1fee 6A06      		cpc r6,r26
 6036 1ff0 7B06      		cpc r7,r27
 6037 1ff2 00F4      		brsh .+2
 6038 1ff4 00C0      		rjmp .L249
 330:motorctrl.c   ****         m->status = ACTUATOR_ERROR;
 6040               	.LM564:
 6041 1ff6 AF81      		ldd r26,Y+7
 6042 1ff8 B885      		ldd r27,Y+8
 6043 1ffa AC5A      		subi r26,-84
 6044 1ffc BF4F      		sbci r27,-1
 6045 1ffe 8D91      		ld r24,X+
 6046 2000 9C91      		ld r25,X
 6047 2002 C296      		adiw r24,50
 6048 2004 A0E0      		ldi r26,0
 6049 2006 B0E0      		ldi r27,0
 6050 2008 8415      		cp r24,r4
 6051 200a 9505      		cpc r25,r5
 6052 200c A605      		cpc r26,r6
 6053 200e B705      		cpc r27,r7
 6054 2010 00F4      		brsh .+2
 6055 2012 00C0      		rjmp .L249
 341:motorctrl.c   ****     uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); /
 6057               	.LM565:
 6058 2014 8080      		ld r8,Z
 6059 2016 9180      		ldd r9,Z+1
 342:motorctrl.c   ****     
 6061               	.LM566:
 6062 2018 EF81      		ldd r30,Y+7
 6063 201a F885      		ldd r31,Y+8
 6064 201c 63AD      		ldd r22,Z+59
 6065 201e 74AD      		ldd r23,Z+60
 6066 2020 FF96      		adiw r30,63
 6067 2022 C080      		ld r12,Z
 6068 2024 D180      		ldd r13,Z+1
 6069 2026 E280      		ldd r14,Z+2
 6070 2028 F380      		ldd r15,Z+3
 6071 202a EF81      		ldd r30,Y+7
 6072 202c F885      		ldd r31,Y+8
 6073 202e EA5A      		subi r30,-86
 6074 2030 FF4F      		sbci r31,-1
 6075 2032 2081      		ld r18,Z
 6076 2034 3181      		ldd r19,Z+1
 6077 2036 80E0      		ldi r24,0
 6078 2038 90E0      		ldi r25,0
 6079 203a 2D83      		std Y+5,r18
 6080 203c 3E83      		std Y+6,r19
 6081 203e 0E94 0000 		call __floatunsisf
 6082 2042 6983      		std Y+1,r22
 6083 2044 7A83      		std Y+2,r23
 6084 2046 8B83      		std Y+3,r24
 6085 2048 9C83      		std Y+4,r25
 6086 204a 2D81      		ldd r18,Y+5
 6087 204c 3E81      		ldd r19,Y+6
 6088 204e B901      		movw r22,r18
 6089 2050 80E0      		ldi r24,0
 6090 2052 90E0      		ldi r25,0
 6091 2054 0E94 0000 		call __floatunsisf
 6092 2058 9B01      		movw r18,r22
 6093 205a AC01      		movw r20,r24
 6094 205c C701      		movw r24,r14
 6095 205e B601      		movw r22,r12
 6096 2060 0E94 0000 		call __divsf3
 6097 2064 6B01      		movw r12,r22
 6098 2066 7C01      		movw r14,r24
 341:motorctrl.c   ****     uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); /
 6100               	.LM567:
 6101 2068 C301      		movw r24,r6
 6102 206a B201      		movw r22,r4
 6103 206c 6819      		sub r22,r8
 6104 206e 7909      		sbc r23,r9
 6105 2070 8109      		sbc r24,__zero_reg__
 6106 2072 9109      		sbc r25,__zero_reg__
 342:motorctrl.c   ****     
 6108               	.LM568:
 6109 2074 0E94 0000 		call __floatunsisf
 6110 2078 9B01      		movw r18,r22
 6111 207a AC01      		movw r20,r24
 6112 207c C701      		movw r24,r14
 6113 207e B601      		movw r22,r12
 6114 2080 0E94 0000 		call __mulsf3
 6115 2084 9B01      		movw r18,r22
 6116 2086 AC01      		movw r20,r24
 6117 2088 6981      		ldd r22,Y+1
 6118 208a 7A81      		ldd r23,Y+2
 6119 208c 8B81      		ldd r24,Y+3
 6120 208e 9C81      		ldd r25,Y+4
 6121 2090 0E94 0000 		call __addsf3
 6122 2094 0E94 0000 		call __fixunssfsi
 6123 2098 6B01      		movw r12,r22
 6124 209a 7C01      		movw r14,r24
 6125 209c CB01      		movw r24,r22
 345:motorctrl.c   ****         m->status = MAX_LIMIT;
 6127               	.LM569:
 6128 209e EF81      		ldd r30,Y+7
 6129 20a0 F885      		ldd r31,Y+8
 6130 20a2 EB5B      		subi r30,-69
 6131 20a4 FF4F      		sbci r31,-1
 6132 20a6 2081      		ld r18,Z
 6133 20a8 3181      		ldd r19,Z+1
 6134 20aa 2617      		cp r18,r22
 6135 20ac 3707      		cpc r19,r23
 6136 20ae 00F4      		brsh .L252
 6137 20b0 EF81      		ldd r30,Y+7
 6138 20b2 F885      		ldd r31,Y+8
 6139 20b4 E15B      		subi r30,-79
 6140 20b6 FF4F      		sbci r31,-1
 6141 20b8 2081      		ld r18,Z
 6142 20ba 2130      		cpi r18,lo8(1)
 6143 20bc 01F4      		brne .+2
 6144 20be 00C0      		rjmp .L257
 6145               	.L252:
 352:motorctrl.c   ****         m->status = MIN_LIMIT;
 6147               	.LM570:
 6148 20c0 F4E6      		ldi r31,lo8(100)
 6149 20c2 F29D      		mul r31,r2
 6150 20c4 A001      		movw r20,r0
 6151 20c6 F39D      		mul r31,r3
 6152 20c8 500D      		add r21,r0
 6153 20ca 1124      		clr __zero_reg__
 6154 20cc 9A01      		movw r18,r20
 6155 20ce 2050      		subi r18,lo8(-(motors))
 6156 20d0 3040      		sbci r19,hi8(-(motors))
 6157 20d2 4901      		movw r8,r18
 6158 20d4 F901      		movw r30,r18
 6159 20d6 ED5B      		subi r30,-67
 6160 20d8 FF4F      		sbci r31,-1
 6161 20da 2081      		ld r18,Z
 6162 20dc 3181      		ldd r19,Z+1
 6163 20de 8217      		cp r24,r18
 6164 20e0 9307      		cpc r25,r19
 6165 20e2 00F4      		brsh .+2
 6166 20e4 00C0      		rjmp .L258
 6167               	.L251:
 6168               	.LBE463:
 6169               	.LBE462:
 685:motorctrl.c   ****         m->set_length = m->current_length;
 6171               	.LM571:
 6172 20e6 24E6      		ldi r18,lo8(100)
 6173 20e8 229D      		mul r18,r2
 6174 20ea F001      		movw r30,r0
 6175 20ec 239D      		mul r18,r3
 6176 20ee F00D      		add r31,r0
 6177 20f0 1124      		clr __zero_reg__
 6178 20f2 E050      		subi r30,lo8(-(motors))
 6179 20f4 F040      		sbci r31,hi8(-(motors))
 6180 20f6 D4A2      		std Z+36,r13
 6181 20f8 C3A2      		std Z+35,r12
 686:motorctrl.c   ****    }
 6183               	.LM572:
 6184 20fa 83A1      		ldd r24,Z+35
 6185 20fc 94A1      		ldd r25,Z+36
 6186 20fe 96A3      		std Z+38,r25
 6187 2100 85A3      		std Z+37,r24
 6188 2102 34E6      		ldi r19,100
 6189 2104 A30E      		add r10,r19
 6190 2106 B11C      		adc r11,__zero_reg__
 6191               	.LBE459:
 660:motorctrl.c   ****         volatile motor *m = &motors[i];
 6193               	.LM573:
 6194 2108 41E0      		ldi r20,1
 6195 210a 2416      		cp r2,r20
 6196 210c 3104      		cpc r3,__zero_reg__
 6197 210e 01F0      		breq .+2
 6198 2110 00C0      		rjmp .L256
 6199               	.LBE458:
 690:motorctrl.c   ****    //clock frequency = 16MHz / 1024 = 15625Hz
 6201               	.LM574:
 6202 2112 1092 8000 		sts 128,__zero_reg__
 692:motorctrl.c   ****    OCR1AH = 0x00; //Zero this when tests are done
 6204               	.LM575:
 6205 2116 8DE0      		ldi r24,lo8(13)
 6206 2118 8093 8100 		sts 129,r24
 693:motorctrl.c   ****    OCR1AL = 0x9C;  // interrupt 100 times per second 15625/156~about 100 
 6208               	.LM576:
 6209 211c 1092 8900 		sts 137,__zero_reg__
 694:motorctrl.c   ****    //Set interrupt to TIMER1 COMPA
 6211               	.LM577:
 6212 2120 8CE9      		ldi r24,lo8(-100)
 6213 2122 8093 8800 		sts 136,r24
 696:motorctrl.c   ****   
 6215               	.LM578:
 6216 2126 82E0      		ldi r24,lo8(2)
 6217 2128 8093 6F00 		sts 111,r24
 6218               	/* epilogue start */
 699:motorctrl.c   **** void disableMotorPWM(volatile motor *m){
 6220               	.LM579:
 6221 212c 2896      		adiw r28,8
 6222 212e E2E1      		ldi r30, lo8(18)
 6223 2130 0C94 0000 		jmp __epilogue_restores__ + ((18 - 18) * 2)
 6224               	.L249:
 6225               	.LBB472:
 6226               	.LBB470:
 6227               	.LBB468:
 6228               	.LBB466:
 331:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);
 6230               	.LM580:
 6231 2134 F4E6      		ldi r31,lo8(100)
 6232 2136 F29D      		mul r31,r2
 6233 2138 9001      		movw r18,r0
 6234 213a F39D      		mul r31,r3
 6235 213c 300D      		add r19,r0
 6236 213e 1124      		clr __zero_reg__
 6237 2140 A901      		movw r20,r18
 6238 2142 4050      		subi r20,lo8(-(motors))
 6239 2144 5040      		sbci r21,hi8(-(motors))
 6240 2146 7A01      		movw r14,r20
 6241 2148 FA01      		movw r30,r20
 6242 214a E15B      		subi r30,-79
 6243 214c FF4F      		sbci r31,-1
 6244 214e 57E0      		ldi r21,lo8(7)
 6245 2150 5083      		st Z,r21
 332:motorctrl.c   ****         running_motor = -1;
 6247               	.LM581:
 6248 2152 D701      		movw r26,r14
 6249 2154 9296      		adiw r26,34
 6250 2156 6C91      		ld r22,X
 6251 2158 40E0      		ldi r20,0
 6252 215a C501      		movw r24,r10
 6253 215c 0E94 0000 		call motorControl
 333:motorctrl.c   ****         m->set_length = m->current_length;
 6255               	.LM582:
 6256 2160 BFEF      		ldi r27,lo8(-1)
 6257 2162 B093 0000 		sts running_motor,r27
 334:motorctrl.c   ****         fprintf_P(port, PSTR("AERR\n"));
 6259               	.LM583:
 6260 2166 F701      		movw r30,r14
 6261 2168 83A1      		ldd r24,Z+35
 6262 216a 94A1      		ldd r25,Z+36
 6263 216c 96A3      		std Z+38,r25
 6264 216e 85A3      		std Z+37,r24
 335:motorctrl.c   ****         _delay_ms(500);
 6266               	.LM584:
 6267 2170 A0E0      		ldi r26,lo8(__c.2218)
 6268 2172 B0E0      		ldi r27,hi8(__c.2218)
 6269 2174 BF93      		push r27
 6270 2176 AF93      		push r26
 6271 2178 8091 0000 		lds r24,port+1
 6272 217c 8F93      		push r24
 6273 217e 8091 0000 		lds r24,port
 6274 2182 8F93      		push r24
 6275 2184 0E94 0000 		call fprintf_P
 6276               	.LBB464:
 6277               	.LBB465:
 6279               	.Ltext21:
 163:/usr/lib/avr/include/util/delay.h **** 
 6281               	.LM585:
 6282 2188 FFEF      		ldi r31,lo8(1599999)
 6283 218a 29E6      		ldi r18,hi8(1599999)
 6284 218c 38E1      		ldi r19,hlo8(1599999)
 6285 218e F150      	1:	subi r31,1
 6286 2190 2040      		sbci r18,0
 6287 2192 3040      		sbci r19,0
 6288 2194 01F4      		brne 1b
 6289 2196 00C0      		rjmp .
 6290 2198 0000      		nop
 6291               	.LBE465:
 6292               	.LBE464:
 6294               	.Ltext22:
 337:motorctrl.c   ****     } 
 6296               	.LM586:
 6297 219a D701      		movw r26,r14
 6298 219c 9396      		adiw r26,35
 6299 219e CD90      		ld r12,X+
 6300 21a0 DC90      		ld r13,X
 6301 21a2 9497      		sbiw r26,35+1
 6302 21a4 0F90      		pop __tmp_reg__
 6303 21a6 0F90      		pop __tmp_reg__
 6304 21a8 0F90      		pop __tmp_reg__
 6305 21aa 0F90      		pop __tmp_reg__
 6306 21ac 00C0      		rjmp .L251
 6307               	.L256:
 6308               	.LBE466:
 6309               	.LBE468:
 6310               	.LBE470:
 6311 21ae 2224      		clr r2
 6312 21b0 2394      		inc r2
 6313 21b2 312C      		mov r3,__zero_reg__
 6314 21b4 00C0      		rjmp .L253
 6315               	.L258:
 6316               	.LBB471:
 6317               	.LBB469:
 6318               	.LBB467:
 352:motorctrl.c   ****         m->status = MIN_LIMIT;
 6320               	.LM587:
 6321 21b6 3C96      		adiw r30,12
 6322 21b8 8081      		ld r24,Z
 6323 21ba 8230      		cpi r24,lo8(2)
 6324 21bc 01F0      		breq .+2
 6325 21be 00C0      		rjmp .L251
 353:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
 6327               	.LM588:
 6328 21c0 84E0      		ldi r24,lo8(4)
 6329 21c2 8083      		st Z,r24
 354:motorctrl.c   ****         running_motor = -1;
 6331               	.LM589:
 6332 21c4 D401      		movw r26,r8
 6333 21c6 9296      		adiw r26,34
 6334 21c8 6C91      		ld r22,X
 6335 21ca 40E0      		ldi r20,0
 6336 21cc C501      		movw r24,r10
 6337 21ce 0E94 0000 		call motorControl
 355:motorctrl.c   ****         m->set_length = length;
 6339               	.LM590:
 6340 21d2 BFEF      		ldi r27,lo8(-1)
 6341 21d4 B093 0000 		sts running_motor,r27
 356:motorctrl.c   ****        // fprintf_P(port, PSTR("MINLERR\n"));
 6343               	.LM591:
 6344 21d8 F401      		movw r30,r8
 6345 21da D6A2      		std Z+38,r13
 6346 21dc C5A2      		std Z+37,r12
 6347 21de 00C0      		rjmp .L251
 6348               	.L257:
 346:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 6350               	.LM592:
 6351 21e0 25E0      		ldi r18,lo8(5)
 6352 21e2 2083      		st Z,r18
 347:motorctrl.c   ****         running_motor = -1;
 6354               	.LM593:
 6355 21e4 AF81      		ldd r26,Y+7
 6356 21e6 B885      		ldd r27,Y+8
 6357 21e8 9296      		adiw r26,34
 6358 21ea 6C91      		ld r22,X
 6359 21ec 40E0      		ldi r20,0
 6360 21ee C501      		movw r24,r10
 6361 21f0 0E94 0000 		call motorControl
 348:motorctrl.c   ****         m->set_length = length;
 6363               	.LM594:
 6364 21f4 BFEF      		ldi r27,lo8(-1)
 6365 21f6 B093 0000 		sts running_motor,r27
 349:motorctrl.c   ****        // fprintf_P(port, PSTR("MAXLERR\n"));
 6367               	.LM595:
 6368 21fa EF81      		ldd r30,Y+7
 6369 21fc F885      		ldd r31,Y+8
 6370 21fe D6A2      		std Z+38,r13
 6371 2200 C5A2      		std Z+37,r12
 6372 2202 00C0      		rjmp .L251
 6373               	.LBE467:
 6374               	.LBE469:
 6375               	.LBE471:
 6376               	.LBE472:
 6387               	.Lscope50:
 6389               	.global	setLengthLoop
 6391               	setLengthLoop:
 489:motorctrl.c   ****     //uint8_t status = 0;
 6393               	.LM596:
 6394               	.LFBB51:
 6395 2204 A6E0      		ldi r26,lo8(6)
 6396 2206 B0E0      		ldi r27,0
 6397 2208 E0E0      		ldi r30,lo8(gs(1f))
 6398 220a F0E0      		ldi r31,hi8(gs(1f))
 6399 220c 0C94 0000 		jmp __prologue_saves__+((18 - 18) * 2)
 6400               	1:
 6401               	/* prologue: function */
 6402               	/* frame size = 6 */
 6403               	/* stack size = 24 */
 6404               	.L__stack_usage = 24
 6405 2210 40E0      		ldi r20,lo8(motors)
 6406 2212 A42E      		mov r10,r20
 6407 2214 40E0      		ldi r20,hi8(motors)
 6408 2216 B42E      		mov r11,r20
 6409               	.LBB500:
 6410 2218 212C      		mov r2,__zero_reg__
 6411 221a 312C      		mov r3,__zero_reg__
 6412               	.L277:
 6413               	.LBB501:
 6414               	.LBB502:
 6415               	.LBB503:
 327:motorctrl.c   ****     
 6417               	.LM597:
 6418 221c 44E6      		ldi r20,lo8(100)
 6419 221e 429D      		mul r20,r2
 6420 2220 9001      		movw r18,r0
 6421 2222 439D      		mul r20,r3
 6422 2224 300D      		add r19,r0
 6423 2226 1124      		clr __zero_reg__
 6424 2228 C901      		movw r24,r18
 6425 222a 8050      		subi r24,lo8(-(motors))
 6426 222c 9040      		sbci r25,hi8(-(motors))
 6427 222e 9E83      		std Y+6,r25
 6428 2230 8D83      		std Y+5,r24
 6429 2232 DC01      		movw r26,r24
 6430 2234 5F96      		adiw r26,31
 6431 2236 8C91      		ld r24,X
 6432 2238 44E0      		ldi r20,lo8(4)
 6433 223a 60E4      		ldi r22,lo8(64)
 6434 223c 0E94 0000 		call AVGVoltage
 6435 2240 6C01      		movw r12,r24
 6436 2242 E12C      		mov r14,__zero_reg__
 6437 2244 F12C      		mov r15,__zero_reg__
 330:motorctrl.c   ****         m->status = ACTUATOR_ERROR;
 6439               	.LM598:
 6440 2246 ED81      		ldd r30,Y+5
 6441 2248 FE81      		ldd r31,Y+6
 6442 224a EE5A      		subi r30,-82
 6443 224c FF4F      		sbci r31,-1
 6444 224e 8081      		ld r24,Z
 6445 2250 9181      		ldd r25,Z+1
 6446 2252 A0E0      		ldi r26,0
 6447 2254 B0E0      		ldi r27,0
 6448 2256 C816      		cp r12,r24
 6449 2258 D906      		cpc r13,r25
 6450 225a EA06      		cpc r14,r26
 6451 225c FB06      		cpc r15,r27
 6452 225e 00F4      		brsh .+2
 6453 2260 00C0      		rjmp .L260
 6454 2262 AD81      		ldd r26,Y+5
 6455 2264 BE81      		ldd r27,Y+6
 6456 2266 AC5A      		subi r26,-84
 6457 2268 BF4F      		sbci r27,-1
 6458 226a 8D91      		ld r24,X+
 6459 226c 9C91      		ld r25,X
 6460 226e C296      		adiw r24,50
 6461 2270 A0E0      		ldi r26,0
 6462 2272 B0E0      		ldi r27,0
 6463 2274 8C15      		cp r24,r12
 6464 2276 9D05      		cpc r25,r13
 6465 2278 AE05      		cpc r26,r14
 6466 227a BF05      		cpc r27,r15
 6467 227c 00F4      		brsh .+2
 6468 227e 00C0      		rjmp .L260
 341:motorctrl.c   ****     uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); /
 6470               	.LM599:
 6471 2280 8080      		ld r8,Z
 6472 2282 9180      		ldd r9,Z+1
 342:motorctrl.c   ****     
 6474               	.LM600:
 6475 2284 ED81      		ldd r30,Y+5
 6476 2286 FE81      		ldd r31,Y+6
 6477 2288 63AD      		ldd r22,Z+59
 6478 228a 74AD      		ldd r23,Z+60
 6479 228c FF96      		adiw r30,63
 6480 228e 4080      		ld r4,Z
 6481 2290 5180      		ldd r5,Z+1
 6482 2292 6280      		ldd r6,Z+2
 6483 2294 7380      		ldd r7,Z+3
 6484 2296 ED81      		ldd r30,Y+5
 6485 2298 FE81      		ldd r31,Y+6
 6486 229a EA5A      		subi r30,-86
 6487 229c FF4F      		sbci r31,-1
 6488 229e 0081      		ld r16,Z
 6489 22a0 1181      		ldd r17,Z+1
 6490 22a2 80E0      		ldi r24,0
 6491 22a4 90E0      		ldi r25,0
 6492 22a6 0E94 0000 		call __floatunsisf
 6493 22aa 6983      		std Y+1,r22
 6494 22ac 7A83      		std Y+2,r23
 6495 22ae 8B83      		std Y+3,r24
 6496 22b0 9C83      		std Y+4,r25
 6497 22b2 B801      		movw r22,r16
 6498 22b4 80E0      		ldi r24,0
 6499 22b6 90E0      		ldi r25,0
 6500 22b8 0E94 0000 		call __floatunsisf
 6501 22bc 9B01      		movw r18,r22
 6502 22be AC01      		movw r20,r24
 6503 22c0 C301      		movw r24,r6
 6504 22c2 B201      		movw r22,r4
 6505 22c4 0E94 0000 		call __divsf3
 6506 22c8 2B01      		movw r4,r22
 6507 22ca 3C01      		movw r6,r24
 341:motorctrl.c   ****     uint16_t length =  m->actuator_min_length + (m->actuator_range / m->voltage_range * voltage); /
 6509               	.LM601:
 6510 22cc C701      		movw r24,r14
 6511 22ce B601      		movw r22,r12
 6512 22d0 6819      		sub r22,r8
 6513 22d2 7909      		sbc r23,r9
 6514 22d4 8109      		sbc r24,__zero_reg__
 6515 22d6 9109      		sbc r25,__zero_reg__
 342:motorctrl.c   ****     
 6517               	.LM602:
 6518 22d8 0E94 0000 		call __floatunsisf
 6519 22dc 9B01      		movw r18,r22
 6520 22de AC01      		movw r20,r24
 6521 22e0 C301      		movw r24,r6
 6522 22e2 B201      		movw r22,r4
 6523 22e4 0E94 0000 		call __mulsf3
 6524 22e8 9B01      		movw r18,r22
 6525 22ea AC01      		movw r20,r24
 6526 22ec 6981      		ldd r22,Y+1
 6527 22ee 7A81      		ldd r23,Y+2
 6528 22f0 8B81      		ldd r24,Y+3
 6529 22f2 9C81      		ldd r25,Y+4
 6530 22f4 0E94 0000 		call __addsf3
 6531 22f8 0E94 0000 		call __fixunssfsi
 6532 22fc 6B01      		movw r12,r22
 6533 22fe 7C01      		movw r14,r24
 6534 2300 CB01      		movw r24,r22
 345:motorctrl.c   ****         m->status = MAX_LIMIT;
 6536               	.LM603:
 6537 2302 ED81      		ldd r30,Y+5
 6538 2304 FE81      		ldd r31,Y+6
 6539 2306 EB5B      		subi r30,-69
 6540 2308 FF4F      		sbci r31,-1
 6541 230a 2081      		ld r18,Z
 6542 230c 3181      		ldd r19,Z+1
 6543 230e 2617      		cp r18,r22
 6544 2310 3707      		cpc r19,r23
 6545 2312 00F4      		brsh .L263
 6546 2314 ED81      		ldd r30,Y+5
 6547 2316 FE81      		ldd r31,Y+6
 6548 2318 E15B      		subi r30,-79
 6549 231a FF4F      		sbci r31,-1
 6550 231c 2081      		ld r18,Z
 6551 231e 2130      		cpi r18,lo8(1)
 6552 2320 01F4      		brne .+2
 6553 2322 00C0      		rjmp .L297
 6554               	.L263:
 352:motorctrl.c   ****         m->status = MIN_LIMIT;
 6556               	.LM604:
 6557 2324 F4E6      		ldi r31,lo8(100)
 6558 2326 F29D      		mul r31,r2
 6559 2328 8001      		movw r16,r0
 6560 232a F39D      		mul r31,r3
 6561 232c 100D      		add r17,r0
 6562 232e 1124      		clr __zero_reg__
 6563 2330 0050      		subi r16,lo8(-(motors))
 6564 2332 1040      		sbci r17,hi8(-(motors))
 6565 2334 F801      		movw r30,r16
 6566 2336 ED5B      		subi r30,-67
 6567 2338 FF4F      		sbci r31,-1
 6568 233a 2081      		ld r18,Z
 6569 233c 3181      		ldd r19,Z+1
 6570 233e 8217      		cp r24,r18
 6571 2340 9307      		cpc r25,r19
 6572 2342 00F4      		brsh .+2
 6573 2344 00C0      		rjmp .L298
 6574               	.L262:
 6575               	.LBE503:
 6576               	.LBE502:
 493:motorctrl.c   **** 
 6578               	.LM605:
 6579 2346 24E6      		ldi r18,lo8(100)
 6580 2348 229D      		mul r18,r2
 6581 234a F001      		movw r30,r0
 6582 234c 239D      		mul r18,r3
 6583 234e F00D      		add r31,r0
 6584 2350 1124      		clr __zero_reg__
 6585 2352 E050      		subi r30,lo8(-(motors))
 6586 2354 F040      		sbci r31,hi8(-(motors))
 6587 2356 D4A2      		std Z+36,r13
 6588 2358 C3A2      		std Z+35,r12
 496:motorctrl.c   ****             if (m->timeout_value >= m->timeout_setting){
 6590               	.LM606:
 6591 235a 8091 0000 		lds r24,running_motor
 6592 235e 082E      		mov __tmp_reg__,r24
 6593 2360 000C      		lsl r0
 6594 2362 990B      		sbc r25,r25
 6595 2364 2816      		cp r2,r24
 6596 2366 3906      		cpc r3,r25
 6597 2368 01F4      		brne .+2
 6598 236a 00C0      		rjmp .L264
 496:motorctrl.c   ****             if (m->timeout_value >= m->timeout_setting){
 6600               	.LM607:
 6601 236c 8091 0000 		lds r24,running_motor
 6602 2370 8F3F      		cpi r24,lo8(-1)
 6603 2372 01F4      		brne .+2
 6604 2374 00C0      		rjmp .L264
 6605               	.L265:
 6606 2376 A4E6      		ldi r26,100
 6607 2378 AA0E      		add r10,r26
 6608 237a B11C      		adc r11,__zero_reg__
 6609               	.LBE501:
 491:motorctrl.c   ****         volatile motor *m = &motors[i];
 6611               	.LM608:
 6612 237c B1E0      		ldi r27,1
 6613 237e 2B16      		cp r2,r27
 6614 2380 3104      		cpc r3,__zero_reg__
 6615 2382 01F0      		breq .+2
 6616 2384 00C0      		rjmp .L281
 6617               	/* epilogue start */
 6618               	.LBE500:
 540:motorctrl.c   **** 
 6620               	.LM609:
 6621 2386 2696      		adiw r28,6
 6622 2388 E2E1      		ldi r30, lo8(18)
 6623 238a 0C94 0000 		jmp __epilogue_restores__ + ((18 - 18) * 2)
 6624               	.L260:
 6625               	.LBB532:
 6626               	.LBB530:
 6627               	.LBB509:
 6628               	.LBB506:
 331:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);
 6630               	.LM610:
 6631 238e B4E6      		ldi r27,lo8(100)
 6632 2390 B29D      		mul r27,r2
 6633 2392 8001      		movw r16,r0
 6634 2394 B39D      		mul r27,r3
 6635 2396 100D      		add r17,r0
 6636 2398 1124      		clr __zero_reg__
 6637 239a 0050      		subi r16,lo8(-(motors))
 6638 239c 1040      		sbci r17,hi8(-(motors))
 6639 239e F801      		movw r30,r16
 6640 23a0 E15B      		subi r30,-79
 6641 23a2 FF4F      		sbci r31,-1
 6642 23a4 27E0      		ldi r18,lo8(7)
 6643 23a6 2083      		st Z,r18
 332:motorctrl.c   ****         running_motor = -1;
 6645               	.LM611:
 6646 23a8 D801      		movw r26,r16
 6647 23aa 9296      		adiw r26,34
 6648 23ac 6C91      		ld r22,X
 6649 23ae 40E0      		ldi r20,0
 6650 23b0 C501      		movw r24,r10
 6651 23b2 0E94 0000 		call motorControl
 333:motorctrl.c   ****         m->set_length = m->current_length;
 6653               	.LM612:
 6654 23b6 BFEF      		ldi r27,lo8(-1)
 6655 23b8 B093 0000 		sts running_motor,r27
 334:motorctrl.c   ****         fprintf_P(port, PSTR("AERR\n"));
 6657               	.LM613:
 6658 23bc F801      		movw r30,r16
 6659 23be 83A1      		ldd r24,Z+35
 6660 23c0 94A1      		ldd r25,Z+36
 6661 23c2 96A3      		std Z+38,r25
 6662 23c4 85A3      		std Z+37,r24
 335:motorctrl.c   ****         _delay_ms(500);
 6664               	.LM614:
 6665 23c6 A0E0      		ldi r26,lo8(__c.2218)
 6666 23c8 B0E0      		ldi r27,hi8(__c.2218)
 6667 23ca BF93      		push r27
 6668 23cc AF93      		push r26
 6669 23ce 8091 0000 		lds r24,port+1
 6670 23d2 8F93      		push r24
 6671 23d4 8091 0000 		lds r24,port
 6672 23d8 8F93      		push r24
 6673 23da 0E94 0000 		call fprintf_P
 6674               	.LBB504:
 6675               	.LBB505:
 6677               	.Ltext23:
 163:/usr/lib/avr/include/util/delay.h **** 
 6679               	.LM615:
 6680 23de FFEF      		ldi r31,lo8(1599999)
 6681 23e0 29E6      		ldi r18,hi8(1599999)
 6682 23e2 48E1      		ldi r20,hlo8(1599999)
 6683 23e4 F150      	1:	subi r31,1
 6684 23e6 2040      		sbci r18,0
 6685 23e8 4040      		sbci r20,0
 6686 23ea 01F4      		brne 1b
 6687 23ec 00C0      		rjmp .
 6688 23ee 0000      		nop
 6689               	.LBE505:
 6690               	.LBE504:
 6692               	.Ltext24:
 337:motorctrl.c   ****     } 
 6694               	.LM616:
 6695 23f0 D801      		movw r26,r16
 6696 23f2 9396      		adiw r26,35
 6697 23f4 CD90      		ld r12,X+
 6698 23f6 DC90      		ld r13,X
 6699 23f8 9497      		sbiw r26,35+1
 6700 23fa 0F90      		pop __tmp_reg__
 6701 23fc 0F90      		pop __tmp_reg__
 6702 23fe 0F90      		pop __tmp_reg__
 6703 2400 0F90      		pop __tmp_reg__
 6704 2402 00C0      		rjmp .L262
 6705               	.L281:
 6706               	.LBE506:
 6707               	.LBE509:
 6708               	.LBE530:
 6709 2404 2224      		clr r2
 6710 2406 2394      		inc r2
 6711 2408 312C      		mov r3,__zero_reg__
 6712 240a 00C0      		rjmp .L277
 6713               	.L264:
 6714               	.LBB531:
 496:motorctrl.c   ****             if (m->timeout_value >= m->timeout_setting){
 6716               	.LM617:
 6717 240c 44E6      		ldi r20,lo8(100)
 6718 240e 429D      		mul r20,r2
 6719 2410 9001      		movw r18,r0
 6720 2412 439D      		mul r20,r3
 6721 2414 300D      		add r19,r0
 6722 2416 1124      		clr __zero_reg__
 6723 2418 C901      		movw r24,r18
 6724 241a 8050      		subi r24,lo8(-(motors))
 6725 241c 9040      		sbci r25,hi8(-(motors))
 6726 241e 6C01      		movw r12,r24
 6727 2420 8C01      		movw r16,r24
 6728 2422 015B      		subi r16,-79
 6729 2424 1F4F      		sbci r17,-1
 6730 2426 D801      		movw r26,r16
 6731 2428 8C91      		ld r24,X
 6732 242a 8823      		tst r24
 6733 242c 01F4      		brne .+2
 6734 242e 00C0      		rjmp .L265
 497:motorctrl.c   ****                 motorControl(m, m->current_dir, SHUTDOWN); //Shutdown motor if it has been running 
 6736               	.LM618:
 6737 2430 7601      		movw r14,r12
 6738 2432 BBE4      		ldi r27,75
 6739 2434 EB0E      		add r14,r27
 6740 2436 F11C      		adc r15,__zero_reg__
 6741 2438 F701      		movw r30,r14
 6742 243a 4081      		ld r20,Z
 6743 243c 5181      		ldd r21,Z+1
 6744 243e 6281      		ldd r22,Z+2
 6745 2440 7381      		ldd r23,Z+3
 6746 2442 3497      		sbiw r30,4
 6747 2444 8081      		ld r24,Z
 6748 2446 9181      		ldd r25,Z+1
 6749 2448 A281      		ldd r26,Z+2
 6750 244a B381      		ldd r27,Z+3
 6751 244c 4817      		cp r20,r24
 6752 244e 5907      		cpc r21,r25
 6753 2450 6A07      		cpc r22,r26
 6754 2452 7B07      		cpc r23,r27
 6755 2454 00F0      		brlo .+2
 6756 2456 00C0      		rjmp .L299
 505:motorctrl.c   ****                     motorControl(m, BACKWARD, m->max_pwm);
 6758               	.LM619:
 6759 2458 F601      		movw r30,r12
 6760 245a 23A1      		ldd r18,Z+35
 6761 245c 34A1      		ldd r19,Z+36
 6762 245e 85A1      		ldd r24,Z+37
 6763 2460 96A1      		ldd r25,Z+38
 6764 2462 45A5      		ldd r20,Z+45
 6765 2464 840F      		add r24,r20
 6766 2466 911D      		adc r25,__zero_reg__
 6767 2468 8217      		cp r24,r18
 6768 246a 9307      		cpc r25,r19
 6769 246c 00F4      		brsh .+2
 6770 246e 00C0      		rjmp .L300
 514:motorctrl.c   ****                     motorControl(m, FORWARD, m->max_pwm);
 6772               	.LM620:
 6773 2470 23A1      		ldd r18,Z+35
 6774 2472 34A1      		ldd r19,Z+36
 6775 2474 85A1      		ldd r24,Z+37
 6776 2476 96A1      		ldd r25,Z+38
 6777 2478 45A5      		ldd r20,Z+45
 6778 247a 841B      		sub r24,r20
 6779 247c 9109      		sbc r25,__zero_reg__
 6780 247e 2817      		cp r18,r24
 6781 2480 3907      		cpc r19,r25
 6782 2482 00F4      		brsh .+2
 6783 2484 00C0      		rjmp .L301
 6784               	.LBB510:
 6785               	.LBB511:
 320:motorctrl.c   ****     m->avg_move_current = (m->avg_move_current*9.0 + voltage) / 10.0; //one sample is effecting 1/5
 6787               	.LM621:
 6788 2486 80A1      		ldd r24,Z+32
 6789 2488 42E0      		ldi r20,lo8(2)
 6790 248a 60E4      		ldi r22,lo8(64)
 6791 248c 0E94 0000 		call AVGVoltage
 6792 2490 8C01      		movw r16,r24
 321:motorctrl.c   **** }
 6794               	.LM622:
 6795 2492 7601      		movw r14,r12
 6796 2494 BAE5      		ldi r27,90
 6797 2496 EB0E      		add r14,r27
 6798 2498 F11C      		adc r15,__zero_reg__
 6799 249a F701      		movw r30,r14
 6800 249c 6081      		ld r22,Z
 6801 249e 7181      		ldd r23,Z+1
 6802 24a0 8281      		ldd r24,Z+2
 6803 24a2 9381      		ldd r25,Z+3
 6804 24a4 20E0      		ldi r18,0
 6805 24a6 30E0      		ldi r19,0
 6806 24a8 40E1      		ldi r20,lo8(16)
 6807 24aa 51E4      		ldi r21,lo8(65)
 6808 24ac 0E94 0000 		call __mulsf3
 6809 24b0 2B01      		movw r4,r22
 6810 24b2 3C01      		movw r6,r24
 6811 24b4 B801      		movw r22,r16
 6812 24b6 80E0      		ldi r24,0
 6813 24b8 90E0      		ldi r25,0
 6814 24ba 0E94 0000 		call __floatunsisf
 6815 24be 9B01      		movw r18,r22
 6816 24c0 AC01      		movw r20,r24
 6817 24c2 C301      		movw r24,r6
 6818 24c4 B201      		movw r22,r4
 6819 24c6 0E94 0000 		call __addsf3
 6820 24ca 20E0      		ldi r18,0
 6821 24cc 30E0      		ldi r19,0
 6822 24ce 40E2      		ldi r20,lo8(32)
 6823 24d0 51E4      		ldi r21,lo8(65)
 6824 24d2 0E94 0000 		call __divsf3
 6825 24d6 D701      		movw r26,r14
 6826 24d8 6D93      		st X+,r22
 6827 24da 7D93      		st X+,r23
 6828 24dc 8D93      		st X+,r24
 6829 24de 9C93      		st X,r25
 6830 24e0 1397      		sbiw r26,3
 6831               	.LBE511:
 6832               	.LBE510:
 525:motorctrl.c   ****                         setMotor(m, m->current_dir, m->current_pwm);
 6834               	.LM623:
 6835 24e2 7601      		movw r14,r12
 6836 24e4 B1E2      		ldi r27,33
 6837 24e6 EB0E      		add r14,r27
 6838 24e8 F11C      		adc r15,__zero_reg__
 6839 24ea F601      		movw r30,r12
 6840 24ec 81A1      		ldd r24,Z+33
 6841 24ee 8823      		tst r24
 6842 24f0 01F0      		breq .L274
 526:motorctrl.c   ****                         delayLoop_us(m->deacceleration_time);
 6844               	.LM624:
 6845 24f2 8601      		movw r16,r12
 6846 24f4 0E5D      		subi r16,-34
 6847 24f6 1F4F      		sbci r17,-1
 527:motorctrl.c   ****                     }
 6849               	.LM625:
 6850 24f8 BBE2      		ldi r27,43
 6851 24fa CB0E      		add r12,r27
 6852 24fc D11C      		adc r13,__zero_reg__
 6853 24fe C601      		movw r24,r12
 6854 2500 6701      		movw r12,r14
 6855 2502 7C01      		movw r14,r24
 6856               	.L288:
 526:motorctrl.c   ****                         delayLoop_us(m->deacceleration_time);
 6858               	.LM626:
 6859 2504 F601      		movw r30,r12
 6860 2506 4081      		ld r20,Z
 6861 2508 D801      		movw r26,r16
 6862 250a 6C91      		ld r22,X
 6863 250c C501      		movw r24,r10
 6864 250e 0E94 0000 		call setMotor
 527:motorctrl.c   ****                     }
 6866               	.LM627:
 6867 2512 F701      		movw r30,r14
 6868 2514 2081      		ld r18,Z
 6869 2516 3181      		ldd r19,Z+1
 6870               	.LBB512:
 6871               	.LBB513:
 628:motorctrl.c   ****         _delay_us(47);
 6873               	.LM628:
 6874 2518 3695      		lsr r19
 6875 251a 2795      		ror r18
 6876 251c ABE7      		ldi r26,lo8(123)
 6877 251e B4E1      		ldi r27,lo8(20)
 6878 2520 0E94 0000 		call __umulhisi3
 6879 2524 9695      		lsr r25
 6880 2526 8795      		ror r24
 6881 2528 0097      		sbiw r24,0
 6882 252a 01F0      		breq .L275
 628:motorctrl.c   ****         _delay_us(47);
 6884               	.LM629:
 6885 252c 20E0      		ldi r18,0
 6886 252e 30E0      		ldi r19,0
 6887               	.L273:
 6888               	.LBB514:
 6889               	.LBB515:
 6891               	.Ltext25:
 6893               	.LM630:
 6894 2530 BAEF      		ldi r27,lo8(-6)
 6895 2532 BA95      	1:	dec r27
 6896 2534 01F4      		brne 1b
 6897 2536 00C0      		rjmp .
 6898               	.LBE515:
 6899               	.LBE514:
 6901               	.Ltext26:
 628:motorctrl.c   ****         _delay_us(47);
 6903               	.LM631:
 6904 2538 2F5F      		subi r18,-1
 6905 253a 3F4F      		sbci r19,-1
 6906 253c 2817      		cp r18,r24
 6907 253e 3907      		cpc r19,r25
 6908 2540 01F4      		brne .L273
 6909               	.L275:
 6910               	.LBE513:
 6911               	.LBE512:
 525:motorctrl.c   ****                         setMotor(m, m->current_dir, m->current_pwm);
 6913               	.LM632:
 6914 2542 D601      		movw r26,r12
 6915 2544 8C91      		ld r24,X
 6916 2546 8150      		subi r24,lo8(-(-1))
 6917 2548 8C93      		st X,r24
 6918 254a 8C91      		ld r24,X
 6919 254c 8111      		cpse r24,__zero_reg__
 6920 254e 00C0      		rjmp .L288
 6921               	.L274:
 529:motorctrl.c   ****                     m->status = STATUS_OK;
 6923               	.LM633:
 6924 2550 F4E6      		ldi r31,lo8(100)
 6925 2552 F29D      		mul r31,r2
 6926 2554 9001      		movw r18,r0
 6927 2556 F39D      		mul r31,r3
 6928 2558 300D      		add r19,r0
 6929 255a 1124      		clr __zero_reg__
 6930 255c A901      		movw r20,r18
 6931 255e 4050      		subi r20,lo8(-(motors))
 6932 2560 5040      		sbci r21,hi8(-(motors))
 6933 2562 4A01      		movw r8,r20
 6934 2564 BA01      		movw r22,r20
 6935 2566 655B      		subi r22,-75
 6936 2568 7F4F      		sbci r23,-1
 6937 256a DB01      		movw r26,r22
 6938 256c 1D92      		st X+,__zero_reg__
 6939 256e 1D92      		st X+,__zero_reg__
 6940 2570 1D92      		st X+,__zero_reg__
 6941 2572 1C92      		st X,__zero_reg__
 6942 2574 1397      		sbiw r26,3
 530:motorctrl.c   ****                     disableMotorPWM(m);
 6944               	.LM634:
 6945 2576 1496      		adiw r26,4
 6946 2578 1C92      		st X,__zero_reg__
 6947               	.LBB516:
 6948               	.LBB517:
 702:motorctrl.c   ****     *m->fwd_TCCRA_addr = 0x00;//m.fwd_TCCRA_value;
 6950               	.LM635:
 6951 257a FA01      		movw r30,r20
 6952 257c 868D      		ldd r24,Z+30
 6953 257e A28D      		ldd r26,Z+26
 6954 2580 B38D      		ldd r27,Z+27
 6955 2582 2C91      		ld r18,X
 6956 2584 41E0      		ldi r20,lo8(1)
 6957 2586 50E0      		ldi r21,0
 6958 2588 00C0      		rjmp 2f
 6959               		1:
 6960 258a 440F      		lsl r20
 6961 258c 551F      		rol r21
 6962               		2:
 6963 258e 8A95      		dec r24
 6964 2590 02F4      		brpl 1b
 6965 2592 CA01      		movw r24,r20
 6966 2594 8095      		com r24
 6967 2596 9095      		com r25
 6968 2598 8223      		and r24,r18
 6969 259a 8C93      		st X,r24
 703:motorctrl.c   ****     *m->fwd_TCCRB_addr = 0x00;//m.fwd_TCCRB_value;
 6971               	.LM636:
 6972 259c A581      		ldd r26,Z+5
 6973 259e B681      		ldd r27,Z+6
 6974 25a0 1C92      		st X,__zero_reg__
 704:motorctrl.c   ****     *m->fwd_OCR_addr = 0x00; //Init PWM to zero
 6976               	.LM637:
 6977 25a2 A085      		ldd r26,Z+8
 6978 25a4 B185      		ldd r27,Z+9
 6979 25a6 1C92      		st X,__zero_reg__
 705:motorctrl.c   ****     
 6981               	.LM638:
 6982 25a8 A385      		ldd r26,Z+11
 6983 25aa B485      		ldd r27,Z+12
 6984 25ac 1C92      		st X,__zero_reg__
 708:motorctrl.c   ****     *m->rev_TCCRB_addr = 0x00; //m.rev_TCCRB_value;
 6986               	.LM639:
 6987 25ae A289      		ldd r26,Z+18
 6988 25b0 B389      		ldd r27,Z+19
 6989 25b2 1C92      		st X,__zero_reg__
 709:motorctrl.c   ****     *m->rev_OCR_addr = 0x00; //Init PWM to zero
 6991               	.LM640:
 6992 25b4 A589      		ldd r26,Z+21
 6993 25b6 B689      		ldd r27,Z+22
 6994 25b8 1C92      		st X,__zero_reg__
 710:motorctrl.c   ****     m->current_pwm = 0; //set PWM to zero
 6996               	.LM641:
 6997 25ba A08D      		ldd r26,Z+24
 6998 25bc B18D      		ldd r27,Z+25
 6999 25be 1C92      		st X,__zero_reg__
 711:motorctrl.c   ****     m->timeout_value = 0; //Reset timeout values
 7001               	.LM642:
 7002 25c0 11A2      		std Z+33,__zero_reg__
 712:motorctrl.c   **** } 
 7004               	.LM643:
 7005 25c2 DB01      		movw r26,r22
 7006 25c4 1D92      		st X+,__zero_reg__
 7007 25c6 1D92      		st X+,__zero_reg__
 7008 25c8 1D92      		st X+,__zero_reg__
 7009 25ca 1C92      		st X,__zero_reg__
 7010 25cc 1397      		sbiw r26,3
 7011               	.LBE517:
 7012               	.LBE516:
 532:motorctrl.c   ****                     _delay_ms(25);  
 7014               	.LM644:
 7015 25ce 0091 0000 		lds r16,systick
 7016 25d2 1091 0000 		lds r17,systick+1
 7017               	.LBB518:
 7018               	.LBB519:
 543:motorctrl.c   ****         float milliseconds = tick;
 7020               	.LM645:
 7021 25d6 0115      		cp r16,__zero_reg__
 7022 25d8 1105      		cpc r17,__zero_reg__
 7023 25da 01F0      		breq .L272
 7024 25dc F401      		movw r30,r8
 7025 25de EE59      		subi r30,-98
 7026 25e0 FF4F      		sbci r31,-1
 7027 25e2 8081      		ld r24,Z
 7028 25e4 9181      		ldd r25,Z+1
 7029 25e6 892B      		or r24,r25
 7030 25e8 01F0      		breq .+2
 7031 25ea 00C0      		rjmp .L302
 7032               	.L272:
 549:motorctrl.c   ****     }
 7034               	.LM646:
 7035 25ec 24E6      		ldi r18,lo8(100)
 7036 25ee 229D      		mul r18,r2
 7037 25f0 F001      		movw r30,r0
 7038 25f2 239D      		mul r18,r3
 7039 25f4 F00D      		add r31,r0
 7040 25f6 1124      		clr __zero_reg__
 7041 25f8 E050      		subi r30,lo8(-(motors+94))
 7042 25fa F040      		sbci r31,hi8(-(motors+94))
 7043 25fc 1082      		st Z,__zero_reg__
 7044 25fe 1182      		std Z+1,__zero_reg__
 7045 2600 1282      		std Z+2,__zero_reg__
 7046 2602 1382      		std Z+3,__zero_reg__
 7047               	.L276:
 7048               	.LBE519:
 7049               	.LBE518:
 7050               	.LBB523:
 7051               	.LBB524:
 7053               	.Ltext27:
 163:/usr/lib/avr/include/util/delay.h **** 
 7055               	.LM647:
 7056 2604 4FE7      		ldi r20,lo8(79999)
 7057 2606 58E3      		ldi r21,hi8(79999)
 7058 2608 81E0      		ldi r24,hlo8(79999)
 7059 260a 4150      	1:	subi r20,1
 7060 260c 5040      		sbci r21,0
 7061 260e 8040      		sbci r24,0
 7062 2610 01F4      		brne 1b
 7063 2612 00C0      		rjmp .
 7064 2614 0000      		nop
 7065               	.LBE524:
 7066               	.LBE523:
 7068               	.Ltext28:
 534:motorctrl.c   ****                     systick = 0;
 7070               	.LM648:
 7071 2616 9FEF      		ldi r25,lo8(-1)
 7072 2618 9093 0000 		sts running_motor,r25
 535:motorctrl.c   ****                 }
 7074               	.LM649:
 7075 261c 1092 0000 		sts systick+1,__zero_reg__
 7076 2620 1092 0000 		sts systick,__zero_reg__
 7077 2624 00C0      		rjmp .L265
 7078               	.L298:
 7079               	.LBB525:
 7080               	.LBB507:
 352:motorctrl.c   ****         m->status = MIN_LIMIT;
 7082               	.LM650:
 7083 2626 3C96      		adiw r30,12
 7084 2628 8081      		ld r24,Z
 7085 262a 8230      		cpi r24,lo8(2)
 7086 262c 01F0      		breq .+2
 7087 262e 00C0      		rjmp .L262
 353:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN);  //SHUTDOWN motor
 7089               	.LM651:
 7090 2630 84E0      		ldi r24,lo8(4)
 7091 2632 8083      		st Z,r24
 354:motorctrl.c   ****         running_motor = -1;
 7093               	.LM652:
 7094 2634 D801      		movw r26,r16
 7095 2636 9296      		adiw r26,34
 7096 2638 6C91      		ld r22,X
 7097 263a 40E0      		ldi r20,0
 7098 263c C501      		movw r24,r10
 7099 263e 0E94 0000 		call motorControl
 355:motorctrl.c   ****         m->set_length = length;
 7101               	.LM653:
 7102 2642 BFEF      		ldi r27,lo8(-1)
 7103 2644 B093 0000 		sts running_motor,r27
 356:motorctrl.c   ****        // fprintf_P(port, PSTR("MINLERR\n"));
 7105               	.LM654:
 7106 2648 F801      		movw r30,r16
 7107 264a D6A2      		std Z+38,r13
 7108 264c C5A2      		std Z+37,r12
 7109 264e 00C0      		rjmp .L262
 7110               	.L301:
 7111               	.LBE507:
 7112               	.LBE525:
 515:motorctrl.c   ****                     m->timeout_value ++; //update timeout variables
 7114               	.LM655:
 7115 2650 46A5      		ldd r20,Z+46
 7116 2652 61E0      		ldi r22,lo8(1)
 7117 2654 C501      		movw r24,r10
 7118 2656 0E94 0000 		call motorControl
 516:motorctrl.c   ****                     m->status = RUNNING_FORWARD;
 7120               	.LM656:
 7121 265a F701      		movw r30,r14
 7122 265c 8081      		ld r24,Z
 7123 265e 9181      		ldd r25,Z+1
 7124 2660 A281      		ldd r26,Z+2
 7125 2662 B381      		ldd r27,Z+3
 7126 2664 0196      		adiw r24,1
 7127 2666 A11D      		adc r26,__zero_reg__
 7128 2668 B11D      		adc r27,__zero_reg__
 7129 266a 8083      		st Z,r24
 7130 266c 9183      		std Z+1,r25
 7131 266e A283      		std Z+2,r26
 7132 2670 B383      		std Z+3,r27
 517:motorctrl.c   ****                     running_motor = i;
 7134               	.LM657:
 7135 2672 81E0      		ldi r24,lo8(1)
 7136               	.L296:
 7137 2674 D801      		movw r26,r16
 7138 2676 8C93      		st X,r24
 518:motorctrl.c   ****                     if (m->timeout_value%100 == 0){
 7140               	.LM658:
 7141 2678 2092 0000 		sts running_motor,r2
 519:motorctrl.c   ****                         measureActuatorCurrent(m);
 7143               	.LM659:
 7144 267c 6081      		ld r22,Z
 7145 267e 7181      		ldd r23,Z+1
 7146 2680 8281      		ldd r24,Z+2
 7147 2682 9381      		ldd r25,Z+3
 7148 2684 24E6      		ldi r18,lo8(100)
 7149 2686 30E0      		ldi r19,0
 7150 2688 40E0      		ldi r20,0
 7151 268a 50E0      		ldi r21,0
 7152 268c 0E94 0000 		call __udivmodsi4
 7153 2690 672B      		or r22,r23
 7154 2692 682B      		or r22,r24
 7155 2694 692B      		or r22,r25
 7156 2696 01F0      		breq .+2
 7157 2698 00C0      		rjmp .L265
 7158               	.LBB526:
 7159               	.LBB527:
 320:motorctrl.c   ****     m->avg_move_current = (m->avg_move_current*9.0 + voltage) / 10.0; //one sample is effecting 1/5
 7161               	.LM660:
 7162 269a F601      		movw r30,r12
 7163 269c 80A1      		ldd r24,Z+32
 7164 269e 42E0      		ldi r20,lo8(2)
 7165 26a0 60E4      		ldi r22,lo8(64)
 7166 26a2 0E94 0000 		call AVGVoltage
 7167 26a6 8C01      		movw r16,r24
 321:motorctrl.c   **** }
 7169               	.LM661:
 7170 26a8 4601      		movw r8,r12
 7171 26aa FAE5      		ldi r31,90
 7172 26ac 8F0E      		add r8,r31
 7173 26ae 911C      		adc r9,__zero_reg__
 7174 26b0 D401      		movw r26,r8
 7175 26b2 6D91      		ld r22,X+
 7176 26b4 7D91      		ld r23,X+
 7177 26b6 8D91      		ld r24,X+
 7178 26b8 9C91      		ld r25,X
 7179 26ba 20E0      		ldi r18,0
 7180 26bc 30E0      		ldi r19,0
 7181 26be 40E1      		ldi r20,lo8(16)
 7182 26c0 51E4      		ldi r21,lo8(65)
 7183 26c2 0E94 0000 		call __mulsf3
 7184 26c6 6B01      		movw r12,r22
 7185 26c8 7C01      		movw r14,r24
 7186 26ca B801      		movw r22,r16
 7187 26cc 80E0      		ldi r24,0
 7188 26ce 90E0      		ldi r25,0
 7189 26d0 0E94 0000 		call __floatunsisf
 7190 26d4 9B01      		movw r18,r22
 7191 26d6 AC01      		movw r20,r24
 7192 26d8 C701      		movw r24,r14
 7193 26da B601      		movw r22,r12
 7194 26dc 0E94 0000 		call __addsf3
 7195 26e0 20E0      		ldi r18,0
 7196 26e2 30E0      		ldi r19,0
 7197 26e4 40E2      		ldi r20,lo8(32)
 7198 26e6 51E4      		ldi r21,lo8(65)
 7199 26e8 0E94 0000 		call __divsf3
 7200 26ec F401      		movw r30,r8
 7201 26ee 6083      		st Z,r22
 7202 26f0 7183      		std Z+1,r23
 7203 26f2 8283      		std Z+2,r24
 7204 26f4 9383      		std Z+3,r25
 7205 26f6 00C0      		rjmp .L265
 7206               	.L297:
 7207               	.LBE527:
 7208               	.LBE526:
 7209               	.LBB528:
 7210               	.LBB508:
 346:motorctrl.c   ****         motorControl(m, m->current_dir, SHUTDOWN); //SHUTDOWN motor
 7212               	.LM662:
 7213 26f8 25E0      		ldi r18,lo8(5)
 7214 26fa 2083      		st Z,r18
 347:motorctrl.c   ****         running_motor = -1;
 7216               	.LM663:
 7217 26fc AD81      		ldd r26,Y+5
 7218 26fe BE81      		ldd r27,Y+6
 7219 2700 9296      		adiw r26,34
 7220 2702 6C91      		ld r22,X
 7221 2704 40E0      		ldi r20,0
 7222 2706 C501      		movw r24,r10
 7223 2708 0E94 0000 		call motorControl
 348:motorctrl.c   ****         m->set_length = length;
 7225               	.LM664:
 7226 270c BFEF      		ldi r27,lo8(-1)
 7227 270e B093 0000 		sts running_motor,r27
 349:motorctrl.c   ****        // fprintf_P(port, PSTR("MAXLERR\n"));
 7229               	.LM665:
 7230 2712 ED81      		ldd r30,Y+5
 7231 2714 FE81      		ldd r31,Y+6
 7232 2716 D6A2      		std Z+38,r13
 7233 2718 C5A2      		std Z+37,r12
 7234 271a 00C0      		rjmp .L262
 7235               	.L299:
 7236               	.LBE508:
 7237               	.LBE528:
 498:motorctrl.c   ****                 m->status = TIMEOUT_ERROR;
 7239               	.LM666:
 7240 271c D601      		movw r26,r12
 7241 271e 9296      		adiw r26,34
 7242 2720 6C91      		ld r22,X
 7243 2722 40E0      		ldi r20,0
 7244 2724 C501      		movw r24,r10
 7245 2726 0E94 0000 		call motorControl
 499:motorctrl.c   ****                 fprintf_P(port, PSTR("timeout\n"));
 7247               	.LM667:
 7248 272a 23E0      		ldi r18,lo8(3)
 7249 272c F801      		movw r30,r16
 7250 272e 2083      		st Z,r18
 500:motorctrl.c   ****                 m->set_length = m->current_length; //REset movement
 7252               	.LM668:
 7253 2730 A0E0      		ldi r26,lo8(__c.2269)
 7254 2732 B0E0      		ldi r27,hi8(__c.2269)
 7255 2734 BF93      		push r27
 7256 2736 AF93      		push r26
 7257 2738 8091 0000 		lds r24,port+1
 7258 273c 8F93      		push r24
 7259 273e 8091 0000 		lds r24,port
 7260 2742 8F93      		push r24
 7261 2744 0E94 0000 		call fprintf_P
 501:motorctrl.c   ****                 running_motor = -1;
 7263               	.LM669:
 7264 2748 D601      		movw r26,r12
 7265 274a 9396      		adiw r26,35
 7266 274c 8D91      		ld r24,X+
 7267 274e 9C91      		ld r25,X
 7268 2750 9497      		sbiw r26,35+1
 7269 2752 9696      		adiw r26,37+1
 7270 2754 9C93      		st X,r25
 7271 2756 8E93      		st -X,r24
 7272 2758 9597      		sbiw r26,37
 502:motorctrl.c   ****             } 
 7274               	.LM670:
 7275 275a BFEF      		ldi r27,lo8(-1)
 7276 275c B093 0000 		sts running_motor,r27
 7277 2760 0F90      		pop __tmp_reg__
 7278 2762 0F90      		pop __tmp_reg__
 7279 2764 0F90      		pop __tmp_reg__
 7280 2766 0F90      		pop __tmp_reg__
 7281 2768 00C0      		rjmp .L265
 7282               	.L300:
 506:motorctrl.c   ****                     m->timeout_value ++; //update timeout variables
 7284               	.LM671:
 7285 276a 46A5      		ldd r20,Z+46
 7286 276c 60E0      		ldi r22,0
 7287 276e C501      		movw r24,r10
 7288 2770 0E94 0000 		call motorControl
 507:motorctrl.c   ****                     m->status = RUNNING_BACKWARD;
 7290               	.LM672:
 7291 2774 F701      		movw r30,r14
 7292 2776 8081      		ld r24,Z
 7293 2778 9181      		ldd r25,Z+1
 7294 277a A281      		ldd r26,Z+2
 7295 277c B381      		ldd r27,Z+3
 7296 277e 0196      		adiw r24,1
 7297 2780 A11D      		adc r26,__zero_reg__
 7298 2782 B11D      		adc r27,__zero_reg__
 7299 2784 8083      		st Z,r24
 7300 2786 9183      		std Z+1,r25
 7301 2788 A283      		std Z+2,r26
 7302 278a B383      		std Z+3,r27
 508:motorctrl.c   ****                     running_motor = i;
 7304               	.LM673:
 7305 278c 82E0      		ldi r24,lo8(2)
 7306 278e 00C0      		rjmp .L296
 7307               	.L302:
 7308               	.LBB529:
 7309               	.LBB522:
 7310               	.LBB520:
 7311               	.LBB521:
 545:motorctrl.c   ****         m->move_speed_mm = mlen / (milliseconds/100);
 7313               	.LM674:
 7314 2790 6081      		ld r22,Z
 7315 2792 7181      		ldd r23,Z+1
 7316 2794 80E0      		ldi r24,0
 7317 2796 90E0      		ldi r25,0
 7318 2798 0E94 0000 		call __floatunsisf
 7319 279c 6B01      		movw r12,r22
 7320 279e 7C01      		movw r14,r24
 544:motorctrl.c   ****         float mlen = m->move_length_mm;
 7322               	.LM675:
 7323 27a0 B801      		movw r22,r16
 7324 27a2 80E0      		ldi r24,0
 7325 27a4 90E0      		ldi r25,0
 7326 27a6 0E94 0000 		call __floatunsisf
 546:motorctrl.c   ****     }
 7328               	.LM676:
 7329 27aa 20E0      		ldi r18,0
 7330 27ac 30E0      		ldi r19,0
 7331 27ae 48EC      		ldi r20,lo8(-56)
 7332 27b0 52E4      		ldi r21,lo8(66)
 7333 27b2 0E94 0000 		call __divsf3
 7334 27b6 9B01      		movw r18,r22
 7335 27b8 AC01      		movw r20,r24
 7336 27ba C701      		movw r24,r14
 7337 27bc B601      		movw r22,r12
 7338 27be 0E94 0000 		call __divsf3
 7339 27c2 F401      		movw r30,r8
 7340 27c4 E25A      		subi r30,-94
 7341 27c6 FF4F      		sbci r31,-1
 7342 27c8 6083      		st Z,r22
 7343 27ca 7183      		std Z+1,r23
 7344 27cc 8283      		std Z+2,r24
 7345 27ce 9383      		std Z+3,r25
 7346 27d0 00C0      		rjmp .L276
 7347               	.LBE521:
 7348               	.LBE520:
 7349               	.LBE522:
 7350               	.LBE529:
 7351               	.LBE531:
 7352               	.LBE532:
 7375               	.Lscope51:
 7376               		.section	.progmem.data,"a",@progbits
 7379               	__c.2345:
 7380 0000 566F 6C74 		.string	"Voltage Min:"
 7380      6167 6520 
 7380      4D69 6E3A 
 7380      00
 7383               	__c.2341:
 7384 000d 6361 6C69 		.string	"calibration ready\n"
 7384      6272 6174 
 7384      696F 6E20 
 7384      7265 6164 
 7384      790A 00
 7387               	__c.2336:
 7388 0020 5257 206D 		.string	"RW max: "
 7388      6178 3A20 
 7388      00
 7391               	__c.2329:
 7392 0029 4657 206D 		.string	"FW min: "
 7392      696E 3A20 
 7392      00
 7395               	__c.2321:
 7396 0032 6361 6C69 		.string	"calibrating motor:"
 7396      6272 6174 
 7396      696E 6720 
 7396      6D6F 746F 
 7396      723A 00
 7399               	__c.2310:
 7400 0045 5368 7574 		.string	"Shutdown\n"
 7400      646F 776E 
 7400      0A00 
 7403               	__c.2302:
 7404 004f 2041 4443 		.string	" ADC_value:"
 7404      5F76 616C 
 7404      7565 3A00 
 7407               	__c.2300:
 7408 005b 6D6F 746F 		.string	"motor:"
 7408      723A 00
 7411               	__c.2289:
 7412 0062 5275 6E6E 		.string	"Running motor "
 7412      696E 6720 
 7412      6D6F 746F 
 7412      7220 00
 7415               	__c.2287:
 7416 0071 4552 522C 		.string	"ERR,dir\n"
 7416      6469 720A 
 7416      00
 7419               	__c.2269:
 7420 007a 7469 6D65 		.string	"timeout\n"
 7420      6F75 740A 
 7420      00
 7423               	__c.2218:
 7424 0083 4145 5252 		.string	"AERR\n"
 7424      0A00 
 7425               		.comm	port,2,1
 7426               	.global	running_motor
 7427               		.data
 7430               	running_motor:
 7431 0000 FF        		.byte	-1
 7432               	.global	systick
 7433               		.section .bss
 7436               	systick:
 7437 0000 0000      		.zero	2
 7438               	.global	motors
 7439               		.data
 7442               	motors:
 7443 0001 2500      		.word	37
 7444 0003 2400      		.word	36
 7445 0005 03        		.byte	3
 7446 0006 B000      		.word	176
 7447 0008 83        		.byte	-125
 7448 0009 B100      		.word	177
 7449 000b 02        		.byte	2
 7450 000c B300      		.word	179
 7451 000e 2B00      		.word	43
 7452 0010 2A00      		.word	42
 7453 0012 03        		.byte	3
 7454 0013 B000      		.word	176
 7455 0015 23        		.byte	35
 7456 0016 B100      		.word	177
 7457 0018 02        		.byte	2
 7458 0019 B400      		.word	180
 7459 001b 2500      		.word	37
 7460 001d 2400      		.word	36
 7461 001f 04        		.byte	4
 7462 0020 00        		.byte	0
 7463 0021 07        		.byte	7
 7464 0022 00        		.byte	0
 7465 0023 01        		.byte	1
 7466 0024 0000      		.word	0
 7467 0026 0000      		.word	0
 7468 0028 01        		.byte	1
 7469 0029 01        		.byte	1
 7470 002a F401      		.word	500
 7471 002c F401      		.word	500
 7472 002e 04        		.byte	4
 7473 002f 9A        		.byte	-102
 7474 0030 00        		.byte	0
 7475 0031 00        		.byte	0
 7476 0032 D2        		.byte	-46
 7477 0033 42        		.byte	66
 7478 0034 00        		.byte	0
 7479 0035 00        		.byte	0
 7480 0036 F6        		.byte	-10
 7481 0037 42        		.byte	66
 7482 0038 00        		.byte	0
 7483 0039 00        		.byte	0
 7484 003a 25        		.byte	37
 7485 003b 43        		.byte	67
 7486 003c 0302      		.word	515
 7487 003e 7A03      		.word	890
 7488 0040 00        		.byte	0
 7489 0041 80        		.byte	-128
 7490 0042 BB        		.byte	-69
 7491 0043 43        		.byte	67
 7492 0044 1C02      		.word	540
 7493 0046 6603      		.word	870
 7494 0048 60        		.byte	96
 7495 0049 EA        		.byte	-22
 7496 004a 00        		.byte	0
 7497 004b 00        		.byte	0
 7498 004c 00        		.byte	0
 7499 004d 00        		.byte	0
 7500 004e 00        		.byte	0
 7501 004f 00        		.byte	0
 7502 0050 00        		.byte	0
 7503 0051 0000      		.word	gs(angleConversion)
 7504 0053 CA00      		.word	202
 7505 0055 3103      		.word	817
 7506 0057 6602      		.word	614
 7507 0059 0000      		.word	gs(angleDegToLength)
 7508 005b 00        		.byte	0
 7509 005c 00        		.byte	0
 7510 005d 00        		.byte	0
 7511 005e 00        		.byte	0
 7512 005f 00        		.byte	0
 7513 0060 00        		.byte	0
 7514 0061 00        		.byte	0
 7515 0062 00        		.byte	0
 7516 0063 0000      		.word	0
 7517 0065 2B00      		.word	43
 7518 0067 2A00      		.word	42
 7519 0069 06        		.byte	6
 7520 006a 4400      		.word	68
 7521 006c 23        		.byte	35
 7522 006d 4500      		.word	69
 7523 006f 02        		.byte	2
 7524 0070 4800      		.word	72
 7525 0072 2B00      		.word	43
 7526 0074 2A00      		.word	42
 7527 0076 05        		.byte	5
 7528 0077 4400      		.word	68
 7529 0079 83        		.byte	-125
 7530 007a 4500      		.word	69
 7531 007c 02        		.byte	2
 7532 007d 4700      		.word	71
 7533 007f 2B00      		.word	43
 7534 0081 2A00      		.word	42
 7535 0083 07        		.byte	7
 7536 0084 01        		.byte	1
 7537 0085 06        		.byte	6
 7538 0086 00        		.byte	0
 7539 0087 01        		.byte	1
 7540 0088 0000      		.word	0
 7541 008a 0000      		.word	0
 7542 008c 01        		.byte	1
 7543 008d 01        		.byte	1
 7544 008e F401      		.word	500
 7545 0090 F401      		.word	500
 7546 0092 03        		.byte	3
 7547 0093 FF        		.byte	-1
 7548 0094 00        		.byte	0
 7549 0095 00        		.byte	0
 7550 0096 08        		.byte	8
 7551 0097 41        		.byte	65
 7552 0098 00        		.byte	0
 7553 0099 00        		.byte	0
 7554 009a AA        		.byte	-86
 7555 009b 42        		.byte	66
 7556 009c 00        		.byte	0
 7557 009d 00        		.byte	0
 7558 009e 00        		.byte	0
 7559 009f 00        		.byte	0
 7560 00a0 5401      		.word	340
 7561 00a2 1C02      		.word	540
 7562 00a4 00        		.byte	0
 7563 00a5 00        		.byte	0
 7564 00a6 48        		.byte	72
 7565 00a7 43        		.byte	67
 7566 00a8 7701      		.word	375
 7567 00aa 1C02      		.word	540
 7568 00ac 40        		.byte	64
 7569 00ad 9C        		.byte	-100
 7570 00ae 00        		.byte	0
 7571 00af 00        		.byte	0
 7572 00b0 00        		.byte	0
 7573 00b1 00        		.byte	0
 7574 00b2 00        		.byte	0
 7575 00b3 00        		.byte	0
 7576 00b4 00        		.byte	0
 7577 00b5 0000      		.word	gs(tiltConversion)
 7578 00b7 5601      		.word	342
 7579 00b9 A502      		.word	677
 7580 00bb 4F01      		.word	335
 7581 00bd 0000      		.word	gs(tiltDegToLength)
 7582 00bf 00        		.byte	0
 7583 00c0 00        		.byte	0
 7584 00c1 00        		.byte	0
 7585 00c2 00        		.byte	0
 7586 00c3 00        		.byte	0
 7587 00c4 00        		.byte	0
 7588 00c5 00        		.byte	0
 7589 00c6 00        		.byte	0
 7590 00c7 0000      		.word	0
 7595               		.text
 7597               	.Letext0:
 7598               		.ident	"GCC: (GNU) 4.9.2"
 7599               	.global __do_copy_data
 7600               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 motorctrl.c
     /tmp/ccCrnZna.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccCrnZna.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccCrnZna.s:4      *ABS*:0000003f __SREG__
     /tmp/ccCrnZna.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccCrnZna.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccCrnZna.s:128    .text:00000000 angleConversion
     /tmp/ccCrnZna.s:293    .text:00000136 tiltConversion
     /tmp/ccCrnZna.s:469    .text:0000027a angleDegToLength
     /tmp/ccCrnZna.s:574    .text:0000033e tiltDegToLength
     /tmp/ccCrnZna.s:678    .text:00000402 __vector_11
     /tmp/ccCrnZna.s:7436   .bss:00000000 systick
     /tmp/ccCrnZna.s:715    .text:00000430 getTiltMotorMinAngle
     /tmp/ccCrnZna.s:7442   .data:00000001 motors
     /tmp/ccCrnZna.s:741    .text:00000442 getAngleMotorMinAngle
     /tmp/ccCrnZna.s:767    .text:00000454 getTiltMotorMaxAngle
     /tmp/ccCrnZna.s:798    .text:0000047a getAngleMotorMaxAngle
     /tmp/ccCrnZna.s:831    .text:00000494 getTiltActuatorCurrentLength
     /tmp/ccCrnZna.s:851    .text:0000049e getAngleActuatorCurrentLength
     /tmp/ccCrnZna.s:871    .text:000004a8 getTiltActuatorSetLength
     /tmp/ccCrnZna.s:891    .text:000004b2 getAngleActuatorSetLength
     /tmp/ccCrnZna.s:911    .text:000004bc getAngle
     /tmp/ccCrnZna.s:955    .text:000004e4 getTilt
     /tmp/ccCrnZna.s:992    .text:0000050c getSetAngle
     /tmp/ccCrnZna.s:1036   .text:00000534 getSetTilt
     /tmp/ccCrnZna.s:1078   .text:0000055c setAngle
     /tmp/ccCrnZna.s:1493   .text:00000860 setTilt
     /tmp/ccCrnZna.s:1908   .text:00000b64 setTiltMotorLength
     /tmp/ccCrnZna.s:2053   .text:00000c3c setAngleMotorLength
     /tmp/ccCrnZna.s:2197   .text:00000d14 getAngleMotorStatus
     /tmp/ccCrnZna.s:2216   .text:00000d1a getTiltMotorStatus
     /tmp/ccCrnZna.s:2235   .text:00000d20 getTiltMotorAVGcurrent
     /tmp/ccCrnZna.s:2261   .text:00000d32 getAngleMotorAVGcurrent
     /tmp/ccCrnZna.s:2287   .text:00000d44 getTiltMotorMoveSpeed
     /tmp/ccCrnZna.s:2313   .text:00000d56 getAngleMotorMoveSpeed
     /tmp/ccCrnZna.s:2339   .text:00000d68 getTiltMoveLength
     /tmp/ccCrnZna.s:2363   .text:00000d72 getAngleMoveLength
     /tmp/ccCrnZna.s:2388   .text:00000d7c getMotorAVGcurrent
     /tmp/ccCrnZna.s:2414   .text:00000d8c getMotorMoveSpeed
     /tmp/ccCrnZna.s:2440   .text:00000d9c getMotorMoveLength
     /tmp/ccCrnZna.s:2464   .text:00000da8 getMotorPosition
     /tmp/ccCrnZna.s:2510   .text:00000dd6 getMotorSetPosition
     /tmp/ccCrnZna.s:2556   .text:00000e04 measureActuatorCurrent
     /tmp/ccCrnZna.s:2628   .text:00000e6e setMotorPosition
     /tmp/ccCrnZna.s:3077   .text:000010c4 calculateMoveLength
     /tmp/ccCrnZna.s:3142   .text:0000110e getMotorMinAngle
     /tmp/ccCrnZna.s:3166   .text:0000111a getMotorMaxAngle
     /tmp/ccCrnZna.s:3194   .text:00001132 shutdownMotors
     /tmp/ccCrnZna.s:3350   .text:00001218 setMotorLength
     /tmp/ccCrnZna.s:3499   .text:000012c0 calculateMoveSpeed
     /tmp/ccCrnZna.s:3604   .text:00001346 calibrateMotors
     /tmp/ccCrnZna.s:7395   .progmem.data:00000032 __c.2321
     /tmp/ccCrnZna.s:7383   .progmem.data:0000000d __c.2341
                            *COM*:00000002 port
     /tmp/ccCrnZna.s:7391   .progmem.data:00000029 __c.2329
     /tmp/ccCrnZna.s:7387   .progmem.data:00000020 __c.2336
     /tmp/ccCrnZna.s:7379   .progmem.data:00000000 __c.2345
     /tmp/ccCrnZna.s:4382   .text:00001760 delayLoop_us
     /tmp/ccCrnZna.s:4439   .text:0000178e disableMotorPWM
     /tmp/ccCrnZna.s:4517   .text:000017e2 setMotor
     /tmp/ccCrnZna.s:4740   .text:000018ec forceMotors
     /tmp/ccCrnZna.s:7415   .progmem.data:00000071 __c.2287
     /tmp/ccCrnZna.s:7411   .progmem.data:00000062 __c.2289
     /tmp/ccCrnZna.s:7407   .progmem.data:0000005b __c.2300
     /tmp/ccCrnZna.s:7403   .progmem.data:0000004f __c.2302
     /tmp/ccCrnZna.s:7399   .progmem.data:00000045 __c.2310
     /tmp/ccCrnZna.s:5091   .text:00001b0c motorControl
     /tmp/ccCrnZna.s:5512   .text:00001ce0 getActuatorLength
     /tmp/ccCrnZna.s:7430   .data:00000000 running_motor
     /tmp/ccCrnZna.s:7423   .progmem.data:00000083 __c.2218
     /tmp/ccCrnZna.s:5777   .text:00001e6a initMotor
     /tmp/ccCrnZna.s:6391   .text:00002204 setLengthLoop
     /tmp/ccCrnZna.s:7419   .progmem.data:0000007a __c.2269

UNDEFINED SYMBOLS
__floatunsisf
__mulsf3
__floatsisf
__subsf3
__addsf3
__divsf3
__umulhisi3
sqrt
atan
__fixunssfsi
cos
sin
__gesf2
__lesf2
__gtsf2
__ltsf2
__prologue_saves__
AVGVoltage
__epilogue_restores__
fprintf_P
fprintf
__udivmodsi4
__do_copy_data
__do_clear_bss
